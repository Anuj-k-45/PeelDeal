(() => { var e = { 755: function (e, t) { var n; !function (t, n) { "use strict"; "object" == typeof e.exports ? e.exports = t.document ? n(t, !0) : function (e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return n(e) } : n(t) }("undefined" != typeof window ? window : this, (function (i, r) { "use strict"; var s = [], a = Object.getPrototypeOf, o = s.slice, l = s.flat ? function (e) { return s.flat.call(e) } : function (e) { return s.concat.apply([], e) }, c = s.push, u = s.indexOf, h = {}, d = h.toString, p = h.hasOwnProperty, f = p.toString, m = f.call(Object), g = {}, v = function (e) { return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item }, _ = function (e) { return null != e && e === e.window }, y = i.document, x = { type: !0, src: !0, nonce: !0, noModule: !0 }; function b(e, t, n) { var i, r, s = (n = n || y).createElement("script"); if (s.text = e, t) for (i in x) (r = t[i] || t.getAttribute && t.getAttribute(i)) && s.setAttribute(i, r); n.head.appendChild(s).parentNode.removeChild(s) } function E(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? h[d.call(e)] || "object" : typeof e } var T = "3.7.0", S = /HTML$/i, M = function (e, t) { return new M.fn.init(e, t) }; function w(e) { var t = !!e && "length" in e && e.length, n = E(e); return !v(e) && !_(e) && ("array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e) } function A(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() } M.fn = M.prototype = { jquery: T, constructor: M, length: 0, toArray: function () { return o.call(this) }, get: function (e) { return null == e ? o.call(this) : e < 0 ? this[e + this.length] : this[e] }, pushStack: function (e) { var t = M.merge(this.constructor(), e); return t.prevObject = this, t }, each: function (e) { return M.each(this, e) }, map: function (e) { return this.pushStack(M.map(this, (function (t, n) { return e.call(t, n, t) }))) }, slice: function () { return this.pushStack(o.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, even: function () { return this.pushStack(M.grep(this, (function (e, t) { return (t + 1) % 2 }))) }, odd: function () { return this.pushStack(M.grep(this, (function (e, t) { return t % 2 }))) }, eq: function (e) { var t = this.length, n = +e + (e < 0 ? t : 0); return this.pushStack(n >= 0 && n < t ? [this[n]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: c, sort: s.sort, splice: s.splice }, M.extend = M.fn.extend = function () { var e, t, n, i, r, s, a = arguments[0] || {}, o = 1, l = arguments.length, c = !1; for ("boolean" == typeof a && (c = a, a = arguments[o] || {}, o++), "object" == typeof a || v(a) || (a = {}), o === l && (a = this, o--); o < l; o++)if (null != (e = arguments[o])) for (t in e) i = e[t], "__proto__" !== t && a !== i && (c && i && (M.isPlainObject(i) || (r = Array.isArray(i))) ? (n = a[t], s = r && !Array.isArray(n) ? [] : r || M.isPlainObject(n) ? n : {}, r = !1, a[t] = M.extend(c, s, i)) : void 0 !== i && (a[t] = i)); return a }, M.extend({ expando: "jQuery" + (T + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) { throw new Error(e) }, noop: function () { }, isPlainObject: function (e) { var t, n; return !(!e || "[object Object]" !== d.call(e)) && (!(t = a(e)) || "function" == typeof (n = p.call(t, "constructor") && t.constructor) && f.call(n) === m) }, isEmptyObject: function (e) { var t; for (t in e) return !1; return !0 }, globalEval: function (e, t, n) { b(e, { nonce: t && t.nonce }, n) }, each: function (e, t) { var n, i = 0; if (w(e)) for (n = e.length; i < n && !1 !== t.call(e[i], i, e[i]); i++); else for (i in e) if (!1 === t.call(e[i], i, e[i])) break; return e }, text: function (e) { var t, n = "", i = 0, r = e.nodeType; if (r) { if (1 === r || 9 === r || 11 === r) return e.textContent; if (3 === r || 4 === r) return e.nodeValue } else for (; t = e[i++];)n += M.text(t); return n }, makeArray: function (e, t) { var n = t || []; return null != e && (w(Object(e)) ? M.merge(n, "string" == typeof e ? [e] : e) : c.call(n, e)), n }, inArray: function (e, t, n) { return null == t ? -1 : u.call(t, e, n) }, isXMLDoc: function (e) { var t = e && e.namespaceURI, n = e && (e.ownerDocument || e).documentElement; return !S.test(t || n && n.nodeName || "HTML") }, merge: function (e, t) { for (var n = +t.length, i = 0, r = e.length; i < n; i++)e[r++] = t[i]; return e.length = r, e }, grep: function (e, t, n) { for (var i = [], r = 0, s = e.length, a = !n; r < s; r++)!t(e[r], r) !== a && i.push(e[r]); return i }, map: function (e, t, n) { var i, r, s = 0, a = []; if (w(e)) for (i = e.length; s < i; s++)null != (r = t(e[s], s, n)) && a.push(r); else for (s in e) null != (r = t(e[s], s, n)) && a.push(r); return l(a) }, guid: 1, support: g }), "function" == typeof Symbol && (M.fn[Symbol.iterator] = s[Symbol.iterator]), M.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function (e, t) { h["[object " + t + "]"] = t.toLowerCase() })); var D = s.pop, C = s.sort, R = s.splice, L = "[\\x20\\t\\r\\n\\f]", P = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"); M.contains = function (e, t) { var n = t && t.parentNode; return e === n || !(!n || 1 !== n.nodeType || !(e.contains ? e.contains(n) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(n))) }; var I = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g; function N(e, t) { return t ? "\0" === e ? "ï¿½" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e } M.escapeSelector = function (e) { return (e + "").replace(I, N) }; var O = y, F = c; !function () { var e, t, n, r, a, l, c, h, d, f, m = F, v = M.expando, _ = 0, y = 0, x = ee(), b = ee(), E = ee(), T = ee(), S = function (e, t) { return e === t && (a = !0), 0 }, w = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", I = "(?:\\\\[\\da-fA-F]{1,6}" + L + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", N = "\\[" + L + "*(" + I + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + L + "*\\]", U = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + N + ")*)|.*)\\)|)", B = new RegExp(L + "+", "g"), k = new RegExp("^" + L + "*," + L + "*"), z = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"), H = new RegExp(L + "|>"), G = new RegExp(U), V = new RegExp("^" + I + "$"), W = { ID: new RegExp("^#(" + I + ")"), CLASS: new RegExp("^\\.(" + I + ")"), TAG: new RegExp("^(" + I + "|[*])"), ATTR: new RegExp("^" + N), PSEUDO: new RegExp("^" + U), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"), bool: new RegExp("^(?:" + w + ")$", "i"), needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i") }, j = /^(?:input|select|textarea|button)$/i, X = /^h\d$/i, q = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, Y = /[+~]/, K = new RegExp("\\\\[\\da-fA-F]{1,6}" + L + "?|\\\\([^\\r\\n\\f])", "g"), $ = function (e, t) { var n = "0x" + e.slice(1) - 65536; return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)) }, Z = function () { le() }, J = de((function (e) { return !0 === e.disabled && A(e, "fieldset") }), { dir: "parentNode", next: "legend" }); try { m.apply(s = o.call(O.childNodes), O.childNodes), s[O.childNodes.length].nodeType } catch (e) { m = { apply: function (e, t) { F.apply(e, o.call(t)) }, call: function (e) { F.apply(e, o.call(arguments, 1)) } } } function Q(e, t, n, i) { var r, s, a, o, c, u, p, f = t && t.ownerDocument, _ = t ? t.nodeType : 9; if (n = n || [], "string" != typeof e || !e || 1 !== _ && 9 !== _ && 11 !== _) return n; if (!i && (le(t), t = t || l, h)) { if (11 !== _ && (c = q.exec(e))) if (r = c[1]) { if (9 === _) { if (!(a = t.getElementById(r))) return n; if (a.id === r) return m.call(n, a), n } else if (f && (a = f.getElementById(r)) && Q.contains(t, a) && a.id === r) return m.call(n, a), n } else { if (c[2]) return m.apply(n, t.getElementsByTagName(e)), n; if ((r = c[3]) && t.getElementsByClassName) return m.apply(n, t.getElementsByClassName(r)), n } if (!(T[e + " "] || d && d.test(e))) { if (p = e, f = t, 1 === _ && (H.test(e) || z.test(e))) { for ((f = Y.test(e) && oe(t.parentNode) || t) == t && g.scope || ((o = t.getAttribute("id")) ? o = M.escapeSelector(o) : t.setAttribute("id", o = v)), s = (u = ue(e)).length; s--;)u[s] = (o ? "#" + o : ":scope") + " " + he(u[s]); p = u.join(",") } try { return m.apply(n, f.querySelectorAll(p)), n } catch (t) { T(e, !0) } finally { o === v && t.removeAttribute("id") } } } return _e(e.replace(P, "$1"), t, n, i) } function ee() { var e = []; return function n(i, r) { return e.push(i + " ") > t.cacheLength && delete n[e.shift()], n[i + " "] = r } } function te(e) { return e[v] = !0, e } function ne(e) { var t = l.createElement("fieldset"); try { return !!e(t) } catch (e) { return !1 } finally { t.parentNode && t.parentNode.removeChild(t), t = null } } function ie(e) { return function (t) { return A(t, "input") && t.type === e } } function re(e) { return function (t) { return (A(t, "input") || A(t, "button")) && t.type === e } } function se(e) { return function (t) { return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && J(t) === e : t.disabled === e : "label" in t && t.disabled === e } } function ae(e) { return te((function (t) { return t = +t, te((function (n, i) { for (var r, s = e([], n.length, t), a = s.length; a--;)n[r = s[a]] && (n[r] = !(i[r] = n[r])) })) })) } function oe(e) { return e && void 0 !== e.getElementsByTagName && e } function le(e) { var n, i = e ? e.ownerDocument || e : O; return i != l && 9 === i.nodeType && i.documentElement ? (c = (l = i).documentElement, h = !M.isXMLDoc(l), f = c.matches || c.webkitMatchesSelector || c.msMatchesSelector, O != l && (n = l.defaultView) && n.top !== n && n.addEventListener("unload", Z), g.getById = ne((function (e) { return c.appendChild(e).id = M.expando, !l.getElementsByName || !l.getElementsByName(M.expando).length })), g.disconnectedMatch = ne((function (e) { return f.call(e, "*") })), g.scope = ne((function () { return l.querySelectorAll(":scope") })), g.cssHas = ne((function () { try { return l.querySelector(":has(*,:jqfake)"), !1 } catch (e) { return !0 } })), g.getById ? (t.filter.ID = function (e) { var t = e.replace(K, $); return function (e) { return e.getAttribute("id") === t } }, t.find.ID = function (e, t) { if (void 0 !== t.getElementById && h) { var n = t.getElementById(e); return n ? [n] : [] } }) : (t.filter.ID = function (e) { var t = e.replace(K, $); return function (e) { var n = void 0 !== e.getAttributeNode && e.getAttributeNode("id"); return n && n.value === t } }, t.find.ID = function (e, t) { if (void 0 !== t.getElementById && h) { var n, i, r, s = t.getElementById(e); if (s) { if ((n = s.getAttributeNode("id")) && n.value === e) return [s]; for (r = t.getElementsByName(e), i = 0; s = r[i++];)if ((n = s.getAttributeNode("id")) && n.value === e) return [s] } return [] } }), t.find.TAG = function (e, t) { return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : t.querySelectorAll(e) }, t.find.CLASS = function (e, t) { if (void 0 !== t.getElementsByClassName && h) return t.getElementsByClassName(e) }, d = [], ne((function (e) { var t; c.appendChild(e).innerHTML = "<a id='" + v + "' href='' disabled='disabled'></a><select id='" + v + "-\r\\' disabled='disabled'><option selected=''></option></select>", e.querySelectorAll("[selected]").length || d.push("\\[" + L + "*(?:value|" + w + ")"), e.querySelectorAll("[id~=" + v + "-]").length || d.push("~="), e.querySelectorAll("a#" + v + "+*").length || d.push(".#.+[+~]"), e.querySelectorAll(":checked").length || d.push(":checked"), (t = l.createElement("input")).setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), c.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && d.push(":enabled", ":disabled"), (t = l.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || d.push("\\[" + L + "*name" + L + "*=" + L + "*(?:''|\"\")") })), g.cssHas || d.push(":has"), d = d.length && new RegExp(d.join("|")), S = function (e, t) { if (e === t) return a = !0, 0; var n = !e.compareDocumentPosition - !t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !g.sortDetached && t.compareDocumentPosition(e) === n ? e === l || e.ownerDocument == O && Q.contains(O, e) ? -1 : t === l || t.ownerDocument == O && Q.contains(O, t) ? 1 : r ? u.call(r, e) - u.call(r, t) : 0 : 4 & n ? -1 : 1) }, l) : l } for (e in Q.matches = function (e, t) { return Q(e, null, null, t) }, Q.matchesSelector = function (e, t) { if (le(e), h && !T[t + " "] && (!d || !d.test(t))) try { var n = f.call(e, t); if (n || g.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n } catch (e) { T(t, !0) } return Q(t, l, null, [e]).length > 0 }, Q.contains = function (e, t) { return (e.ownerDocument || e) != l && le(e), M.contains(e, t) }, Q.attr = function (e, n) { (e.ownerDocument || e) != l && le(e); var i = t.attrHandle[n.toLowerCase()], r = i && p.call(t.attrHandle, n.toLowerCase()) ? i(e, n, !h) : void 0; return void 0 !== r ? r : e.getAttribute(n) }, Q.error = function (e) { throw new Error("Syntax error, unrecognized expression: " + e) }, M.uniqueSort = function (e) { var t, n = [], i = 0, s = 0; if (a = !g.sortStable, r = !g.sortStable && o.call(e, 0), C.call(e, S), a) { for (; t = e[s++];)t === e[s] && (i = n.push(s)); for (; i--;)R.call(e, n[i], 1) } return r = null, e }, M.fn.uniqueSort = function () { return this.pushStack(M.uniqueSort(o.apply(this))) }, t = M.expr = { cacheLength: 50, createPseudo: te, match: W, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (e) { return e[1] = e[1].replace(K, $), e[3] = (e[3] || e[4] || e[5] || "").replace(K, $), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4) }, CHILD: function (e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || Q.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && Q.error(e[0]), e }, PSEUDO: function (e) { var t, n = !e[6] && e[2]; return W.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && G.test(n) && (t = ue(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG: function (e) { var t = e.replace(K, $).toLowerCase(); return "*" === e ? function () { return !0 } : function (e) { return A(e, t) } }, CLASS: function (e) { var t = x[e + " "]; return t || (t = new RegExp("(^|" + L + ")" + e + "(" + L + "|$)")) && x(e, (function (e) { return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "") })) }, ATTR: function (e, t, n) { return function (i) { var r = Q.attr(i, e); return null == r ? "!=" === t : !t || (r += "", "=" === t ? r === n : "!=" === t ? r !== n : "^=" === t ? n && 0 === r.indexOf(n) : "*=" === t ? n && r.indexOf(n) > -1 : "$=" === t ? n && r.slice(-n.length) === n : "~=" === t ? (" " + r.replace(B, " ") + " ").indexOf(n) > -1 : "|=" === t && (r === n || r.slice(0, n.length + 1) === n + "-")) } }, CHILD: function (e, t, n, i, r) { var s = "nth" !== e.slice(0, 3), a = "last" !== e.slice(-4), o = "of-type" === t; return 1 === i && 0 === r ? function (e) { return !!e.parentNode } : function (t, n, l) { var c, u, h, d, p, f = s !== a ? "nextSibling" : "previousSibling", m = t.parentNode, g = o && t.nodeName.toLowerCase(), y = !l && !o, x = !1; if (m) { if (s) { for (; f;) { for (h = t; h = h[f];)if (o ? A(h, g) : 1 === h.nodeType) return !1; p = f = "only" === e && !p && "nextSibling" } return !0 } if (p = [a ? m.firstChild : m.lastChild], a && y) { for (x = (d = (c = (u = m[v] || (m[v] = {}))[e] || [])[0] === _ && c[1]) && c[2], h = d && m.childNodes[d]; h = ++d && h && h[f] || (x = d = 0) || p.pop();)if (1 === h.nodeType && ++x && h === t) { u[e] = [_, d, x]; break } } else if (y && (x = d = (c = (u = t[v] || (t[v] = {}))[e] || [])[0] === _ && c[1]), !1 === x) for (; (h = ++d && h && h[f] || (x = d = 0) || p.pop()) && (!(o ? A(h, g) : 1 === h.nodeType) || !++x || (y && ((u = h[v] || (h[v] = {}))[e] = [_, x]), h !== t));); return (x -= r) === i || x % i == 0 && x / i >= 0 } } }, PSEUDO: function (e, n) { var i, r = t.pseudos[e] || t.setFilters[e.toLowerCase()] || Q.error("unsupported pseudo: " + e); return r[v] ? r(n) : r.length > 1 ? (i = [e, e, "", n], t.setFilters.hasOwnProperty(e.toLowerCase()) ? te((function (e, t) { for (var i, s = r(e, n), a = s.length; a--;)e[i = u.call(e, s[a])] = !(t[i] = s[a]) })) : function (e) { return r(e, 0, i) }) : r } }, pseudos: { not: te((function (e) { var t = [], n = [], i = ve(e.replace(P, "$1")); return i[v] ? te((function (e, t, n, r) { for (var s, a = i(e, null, r, []), o = e.length; o--;)(s = a[o]) && (e[o] = !(t[o] = s)) })) : function (e, r, s) { return t[0] = e, i(t, null, s, n), t[0] = null, !n.pop() } })), has: te((function (e) { return function (t) { return Q(e, t).length > 0 } })), contains: te((function (e) { return e = e.replace(K, $), function (t) { return (t.textContent || M.text(t)).indexOf(e) > -1 } })), lang: te((function (e) { return V.test(e || "") || Q.error("unsupported lang: " + e), e = e.replace(K, $).toLowerCase(), function (t) { var n; do { if (n = h ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-") } while ((t = t.parentNode) && 1 === t.nodeType); return !1 } })), target: function (e) { var t = i.location && i.location.hash; return t && t.slice(1) === e.id }, root: function (e) { return e === c }, focus: function (e) { return e === function () { try { return l.activeElement } catch (e) { } }() && l.hasFocus() && !!(e.type || e.href || ~e.tabIndex) }, enabled: se(!1), disabled: se(!0), checked: function (e) { return A(e, "input") && !!e.checked || A(e, "option") && !!e.selected }, selected: function (e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected }, empty: function (e) { for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6) return !1; return !0 }, parent: function (e) { return !t.pseudos.empty(e) }, header: function (e) { return X.test(e.nodeName) }, input: function (e) { return j.test(e.nodeName) }, button: function (e) { return A(e, "input") && "button" === e.type || A(e, "button") }, text: function (e) { var t; return A(e, "input") && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase()) }, first: ae((function () { return [0] })), last: ae((function (e, t) { return [t - 1] })), eq: ae((function (e, t, n) { return [n < 0 ? n + t : n] })), even: ae((function (e, t) { for (var n = 0; n < t; n += 2)e.push(n); return e })), odd: ae((function (e, t) { for (var n = 1; n < t; n += 2)e.push(n); return e })), lt: ae((function (e, t, n) { var i; for (i = n < 0 ? n + t : n > t ? t : n; --i >= 0;)e.push(i); return e })), gt: ae((function (e, t, n) { for (var i = n < 0 ? n + t : n; ++i < t;)e.push(i); return e })) } }, t.pseudos.nth = t.pseudos.eq, { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) t.pseudos[e] = ie(e); for (e in { submit: !0, reset: !0 }) t.pseudos[e] = re(e); function ce() { } function ue(e, n) { var i, r, s, a, o, l, c, u = b[e + " "]; if (u) return n ? 0 : u.slice(0); for (o = e, l = [], c = t.preFilter; o;) { for (a in i && !(r = k.exec(o)) || (r && (o = o.slice(r[0].length) || o), l.push(s = [])), i = !1, (r = z.exec(o)) && (i = r.shift(), s.push({ value: i, type: r[0].replace(P, " ") }), o = o.slice(i.length)), t.filter) !(r = W[a].exec(o)) || c[a] && !(r = c[a](r)) || (i = r.shift(), s.push({ value: i, type: a, matches: r }), o = o.slice(i.length)); if (!i) break } return n ? o.length : o ? Q.error(e) : b(e, l).slice(0) } function he(e) { for (var t = 0, n = e.length, i = ""; t < n; t++)i += e[t].value; return i } function de(e, t, n) { var i = t.dir, r = t.next, s = r || i, a = n && "parentNode" === s, o = y++; return t.first ? function (t, n, r) { for (; t = t[i];)if (1 === t.nodeType || a) return e(t, n, r); return !1 } : function (t, n, l) { var c, u, h = [_, o]; if (l) { for (; t = t[i];)if ((1 === t.nodeType || a) && e(t, n, l)) return !0 } else for (; t = t[i];)if (1 === t.nodeType || a) if (u = t[v] || (t[v] = {}), r && A(t, r)) t = t[i] || t; else { if ((c = u[s]) && c[0] === _ && c[1] === o) return h[2] = c[2]; if (u[s] = h, h[2] = e(t, n, l)) return !0 } return !1 } } function pe(e) { return e.length > 1 ? function (t, n, i) { for (var r = e.length; r--;)if (!e[r](t, n, i)) return !1; return !0 } : e[0] } function fe(e, t, n, i, r) { for (var s, a = [], o = 0, l = e.length, c = null != t; o < l; o++)(s = e[o]) && (n && !n(s, i, r) || (a.push(s), c && t.push(o))); return a } function me(e, t, n, i, r, s) { return i && !i[v] && (i = me(i)), r && !r[v] && (r = me(r, s)), te((function (s, a, o, l) { var c, h, d, p, f = [], g = [], v = a.length, _ = s || function (e, t, n) { for (var i = 0, r = t.length; i < r; i++)Q(e, t[i], n); return n }(t || "*", o.nodeType ? [o] : o, []), y = !e || !s && t ? _ : fe(_, f, e, o, l); if (n ? n(y, p = r || (s ? e : v || i) ? [] : a, o, l) : p = y, i) for (c = fe(p, g), i(c, [], o, l), h = c.length; h--;)(d = c[h]) && (p[g[h]] = !(y[g[h]] = d)); if (s) { if (r || e) { if (r) { for (c = [], h = p.length; h--;)(d = p[h]) && c.push(y[h] = d); r(null, p = [], c, l) } for (h = p.length; h--;)(d = p[h]) && (c = r ? u.call(s, d) : f[h]) > -1 && (s[c] = !(a[c] = d)) } } else p = fe(p === a ? p.splice(v, p.length) : p), r ? r(null, a, p, l) : m.apply(a, p) })) } function ge(e) { for (var i, r, s, a = e.length, o = t.relative[e[0].type], l = o || t.relative[" "], c = o ? 1 : 0, h = de((function (e) { return e === i }), l, !0), d = de((function (e) { return u.call(i, e) > -1 }), l, !0), p = [function (e, t, r) { var s = !o && (r || t != n) || ((i = t).nodeType ? h(e, t, r) : d(e, t, r)); return i = null, s }]; c < a; c++)if (r = t.relative[e[c].type]) p = [de(pe(p), r)]; else { if ((r = t.filter[e[c].type].apply(null, e[c].matches))[v]) { for (s = ++c; s < a && !t.relative[e[s].type]; s++); return me(c > 1 && pe(p), c > 1 && he(e.slice(0, c - 1).concat({ value: " " === e[c - 2].type ? "*" : "" })).replace(P, "$1"), r, c < s && ge(e.slice(c, s)), s < a && ge(e = e.slice(s)), s < a && he(e)) } p.push(r) } return pe(p) } function ve(e, i) { var r, s = [], a = [], o = E[e + " "]; if (!o) { for (i || (i = ue(e)), r = i.length; r--;)(o = ge(i[r]))[v] ? s.push(o) : a.push(o); o = E(e, function (e, i) { var r = i.length > 0, s = e.length > 0, a = function (a, o, c, u, d) { var p, f, g, v = 0, y = "0", x = a && [], b = [], E = n, T = a || s && t.find.TAG("*", d), S = _ += null == E ? 1 : Math.random() || .1, w = T.length; for (d && (n = o == l || o || d); y !== w && null != (p = T[y]); y++) { if (s && p) { for (f = 0, o || p.ownerDocument == l || (le(p), c = !h); g = e[f++];)if (g(p, o || l, c)) { m.call(u, p); break } d && (_ = S) } r && ((p = !g && p) && v--, a && x.push(p)) } if (v += y, r && y !== v) { for (f = 0; g = i[f++];)g(x, b, o, c); if (a) { if (v > 0) for (; y--;)x[y] || b[y] || (b[y] = D.call(u)); b = fe(b) } m.apply(u, b), d && !a && b.length > 0 && v + i.length > 1 && M.uniqueSort(u) } return d && (_ = S, n = E), x }; return r ? te(a) : a }(a, s)), o.selector = e } return o } function _e(e, n, i, r) { var s, a, o, l, c, u = "function" == typeof e && e, d = !r && ue(e = u.selector || e); if (i = i || [], 1 === d.length) { if ((a = d[0] = d[0].slice(0)).length > 2 && "ID" === (o = a[0]).type && 9 === n.nodeType && h && t.relative[a[1].type]) { if (!(n = (t.find.ID(o.matches[0].replace(K, $), n) || [])[0])) return i; u && (n = n.parentNode), e = e.slice(a.shift().value.length) } for (s = W.needsContext.test(e) ? 0 : a.length; s-- && (o = a[s], !t.relative[l = o.type]);)if ((c = t.find[l]) && (r = c(o.matches[0].replace(K, $), Y.test(a[0].type) && oe(n.parentNode) || n))) { if (a.splice(s, 1), !(e = r.length && he(a))) return m.apply(i, r), i; break } } return (u || ve(e, d))(r, n, !h, i, !n || Y.test(e) && oe(n.parentNode) || n), i } ce.prototype = t.filters = t.pseudos, t.setFilters = new ce, g.sortStable = v.split("").sort(S).join("") === v, le(), g.sortDetached = ne((function (e) { return 1 & e.compareDocumentPosition(l.createElement("fieldset")) })), M.find = Q, M.expr[":"] = M.expr.pseudos, M.unique = M.uniqueSort, Q.compile = ve, Q.select = _e, Q.setDocument = le, Q.escape = M.escapeSelector, Q.getText = M.text, Q.isXML = M.isXMLDoc, Q.selectors = M.expr, Q.support = M.support, Q.uniqueSort = M.uniqueSort }(); var U = function (e, t, n) { for (var i = [], r = void 0 !== n; (e = e[t]) && 9 !== e.nodeType;)if (1 === e.nodeType) { if (r && M(e).is(n)) break; i.push(e) } return i }, B = function (e, t) { for (var n = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e); return n }, k = M.expr.match.needsContext, z = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; function H(e, t, n) { return v(t) ? M.grep(e, (function (e, i) { return !!t.call(e, i, e) !== n })) : t.nodeType ? M.grep(e, (function (e) { return e === t !== n })) : "string" != typeof t ? M.grep(e, (function (e) { return u.call(t, e) > -1 !== n })) : M.filter(t, e, n) } M.filter = function (e, t, n) { var i = t[0]; return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === i.nodeType ? M.find.matchesSelector(i, e) ? [i] : [] : M.find.matches(e, M.grep(t, (function (e) { return 1 === e.nodeType }))) }, M.fn.extend({ find: function (e) { var t, n, i = this.length, r = this; if ("string" != typeof e) return this.pushStack(M(e).filter((function () { for (t = 0; t < i; t++)if (M.contains(r[t], this)) return !0 }))); for (n = this.pushStack([]), t = 0; t < i; t++)M.find(e, r[t], n); return i > 1 ? M.uniqueSort(n) : n }, filter: function (e) { return this.pushStack(H(this, e || [], !1)) }, not: function (e) { return this.pushStack(H(this, e || [], !0)) }, is: function (e) { return !!H(this, "string" == typeof e && k.test(e) ? M(e) : e || [], !1).length } }); var G, V = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (M.fn.init = function (e, t, n) { var i, r; if (!e) return this; if (n = n || G, "string" == typeof e) { if (!(i = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : V.exec(e)) || !i[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (i[1]) { if (t = t instanceof M ? t[0] : t, M.merge(this, M.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : y, !0)), z.test(i[1]) && M.isPlainObject(t)) for (i in t) v(this[i]) ? this[i](t[i]) : this.attr(i, t[i]); return this } return (r = y.getElementById(i[2])) && (this[0] = r, this.length = 1), this } return e.nodeType ? (this[0] = e, this.length = 1, this) : v(e) ? void 0 !== n.ready ? n.ready(e) : e(M) : M.makeArray(e, this) }).prototype = M.fn, G = M(y); var W = /^(?:parents|prev(?:Until|All))/, j = { children: !0, contents: !0, next: !0, prev: !0 }; function X(e, t) { for (; (e = e[t]) && 1 !== e.nodeType;); return e } M.fn.extend({ has: function (e) { var t = M(e, this), n = t.length; return this.filter((function () { for (var e = 0; e < n; e++)if (M.contains(this, t[e])) return !0 })) }, closest: function (e, t) { var n, i = 0, r = this.length, s = [], a = "string" != typeof e && M(e); if (!k.test(e)) for (; i < r; i++)for (n = this[i]; n && n !== t; n = n.parentNode)if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && M.find.matchesSelector(n, e))) { s.push(n); break } return this.pushStack(s.length > 1 ? M.uniqueSort(s) : s) }, index: function (e) { return e ? "string" == typeof e ? u.call(M(e), this[0]) : u.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (e, t) { return this.pushStack(M.uniqueSort(M.merge(this.get(), M(e, t)))) }, addBack: function (e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } }), M.each({ parent: function (e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function (e) { return U(e, "parentNode") }, parentsUntil: function (e, t, n) { return U(e, "parentNode", n) }, next: function (e) { return X(e, "nextSibling") }, prev: function (e) { return X(e, "previousSibling") }, nextAll: function (e) { return U(e, "nextSibling") }, prevAll: function (e) { return U(e, "previousSibling") }, nextUntil: function (e, t, n) { return U(e, "nextSibling", n) }, prevUntil: function (e, t, n) { return U(e, "previousSibling", n) }, siblings: function (e) { return B((e.parentNode || {}).firstChild, e) }, children: function (e) { return B(e.firstChild) }, contents: function (e) { return null != e.contentDocument && a(e.contentDocument) ? e.contentDocument : (A(e, "template") && (e = e.content || e), M.merge([], e.childNodes)) } }, (function (e, t) { M.fn[e] = function (n, i) { var r = M.map(this, t, n); return "Until" !== e.slice(-5) && (i = n), i && "string" == typeof i && (r = M.filter(i, r)), this.length > 1 && (j[e] || M.uniqueSort(r), W.test(e) && r.reverse()), this.pushStack(r) } })); var q = /[^\x20\t\r\n\f]+/g; function Y(e) { return e } function K(e) { throw e } function $(e, t, n, i) { var r; try { e && v(r = e.promise) ? r.call(e).done(t).fail(n) : e && v(r = e.then) ? r.call(e, t, n) : t.apply(void 0, [e].slice(i)) } catch (e) { n.apply(void 0, [e]) } } M.Callbacks = function (e) { e = "string" == typeof e ? function (e) { var t = {}; return M.each(e.match(q) || [], (function (e, n) { t[n] = !0 })), t }(e) : M.extend({}, e); var t, n, i, r, s = [], a = [], o = -1, l = function () { for (r = r || e.once, i = t = !0; a.length; o = -1)for (n = a.shift(); ++o < s.length;)!1 === s[o].apply(n[0], n[1]) && e.stopOnFalse && (o = s.length, n = !1); e.memory || (n = !1), t = !1, r && (s = n ? [] : "") }, c = { add: function () { return s && (n && !t && (o = s.length - 1, a.push(n)), function t(n) { M.each(n, (function (n, i) { v(i) ? e.unique && c.has(i) || s.push(i) : i && i.length && "string" !== E(i) && t(i) })) }(arguments), n && !t && l()), this }, remove: function () { return M.each(arguments, (function (e, t) { for (var n; (n = M.inArray(t, s, n)) > -1;)s.splice(n, 1), n <= o && o-- })), this }, has: function (e) { return e ? M.inArray(e, s) > -1 : s.length > 0 }, empty: function () { return s && (s = []), this }, disable: function () { return r = a = [], s = n = "", this }, disabled: function () { return !s }, lock: function () { return r = a = [], n || t || (s = n = ""), this }, locked: function () { return !!r }, fireWith: function (e, n) { return r || (n = [e, (n = n || []).slice ? n.slice() : n], a.push(n), t || l()), this }, fire: function () { return c.fireWith(this, arguments), this }, fired: function () { return !!i } }; return c }, M.extend({ Deferred: function (e) { var t = [["notify", "progress", M.Callbacks("memory"), M.Callbacks("memory"), 2], ["resolve", "done", M.Callbacks("once memory"), M.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", M.Callbacks("once memory"), M.Callbacks("once memory"), 1, "rejected"]], n = "pending", r = { state: function () { return n }, always: function () { return s.done(arguments).fail(arguments), this }, catch: function (e) { return r.then(null, e) }, pipe: function () { var e = arguments; return M.Deferred((function (n) { M.each(t, (function (t, i) { var r = v(e[i[4]]) && e[i[4]]; s[i[1]]((function () { var e = r && r.apply(this, arguments); e && v(e.promise) ? e.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[i[0] + "With"](this, r ? [e] : arguments) })) })), e = null })).promise() }, then: function (e, n, r) { var s = 0; function a(e, t, n, r) { return function () { var o = this, l = arguments, c = function () { var i, c; if (!(e < s)) { if ((i = n.apply(o, l)) === t.promise()) throw new TypeError("Thenable self-resolution"); c = i && ("object" == typeof i || "function" == typeof i) && i.then, v(c) ? r ? c.call(i, a(s, t, Y, r), a(s, t, K, r)) : (s++, c.call(i, a(s, t, Y, r), a(s, t, K, r), a(s, t, Y, t.notifyWith))) : (n !== Y && (o = void 0, l = [i]), (r || t.resolveWith)(o, l)) } }, u = r ? c : function () { try { c() } catch (i) { M.Deferred.exceptionHook && M.Deferred.exceptionHook(i, u.error), e + 1 >= s && (n !== K && (o = void 0, l = [i]), t.rejectWith(o, l)) } }; e ? u() : (M.Deferred.getErrorHook ? u.error = M.Deferred.getErrorHook() : M.Deferred.getStackHook && (u.error = M.Deferred.getStackHook()), i.setTimeout(u)) } } return M.Deferred((function (i) { t[0][3].add(a(0, i, v(r) ? r : Y, i.notifyWith)), t[1][3].add(a(0, i, v(e) ? e : Y)), t[2][3].add(a(0, i, v(n) ? n : K)) })).promise() }, promise: function (e) { return null != e ? M.extend(e, r) : r } }, s = {}; return M.each(t, (function (e, i) { var a = i[2], o = i[5]; r[i[1]] = a.add, o && a.add((function () { n = o }), t[3 - e][2].disable, t[3 - e][3].disable, t[0][2].lock, t[0][3].lock), a.add(i[3].fire), s[i[0]] = function () { return s[i[0] + "With"](this === s ? void 0 : this, arguments), this }, s[i[0] + "With"] = a.fireWith })), r.promise(s), e && e.call(s, s), s }, when: function (e) { var t = arguments.length, n = t, i = Array(n), r = o.call(arguments), s = M.Deferred(), a = function (e) { return function (n) { i[e] = this, r[e] = arguments.length > 1 ? o.call(arguments) : n, --t || s.resolveWith(i, r) } }; if (t <= 1 && ($(e, s.done(a(n)).resolve, s.reject, !t), "pending" === s.state() || v(r[n] && r[n].then))) return s.then(); for (; n--;)$(r[n], a(n), s.reject); return s.promise() } }); var Z = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; M.Deferred.exceptionHook = function (e, t) { i.console && i.console.warn && e && Z.test(e.name) && i.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t) }, M.readyException = function (e) { i.setTimeout((function () { throw e })) }; var J = M.Deferred(); function Q() { y.removeEventListener("DOMContentLoaded", Q), i.removeEventListener("load", Q), M.ready() } M.fn.ready = function (e) { return J.then(e).catch((function (e) { M.readyException(e) })), this }, M.extend({ isReady: !1, readyWait: 1, ready: function (e) { (!0 === e ? --M.readyWait : M.isReady) || (M.isReady = !0, !0 !== e && --M.readyWait > 0 || J.resolveWith(y, [M])) } }), M.ready.then = J.then, "complete" === y.readyState || "loading" !== y.readyState && !y.documentElement.doScroll ? i.setTimeout(M.ready) : (y.addEventListener("DOMContentLoaded", Q), i.addEventListener("load", Q)); var ee = function (e, t, n, i, r, s, a) { var o = 0, l = e.length, c = null == n; if ("object" === E(n)) for (o in r = !0, n) ee(e, t, o, n[o], !0, s, a); else if (void 0 !== i && (r = !0, v(i) || (a = !0), c && (a ? (t.call(e, i), t = null) : (c = t, t = function (e, t, n) { return c.call(M(e), n) })), t)) for (; o < l; o++)t(e[o], n, a ? i : i.call(e[o], o, t(e[o], n))); return r ? e : c ? t.call(e) : l ? t(e[0], n) : s }, te = /^-ms-/, ne = /-([a-z])/g; function ie(e, t) { return t.toUpperCase() } function re(e) { return e.replace(te, "ms-").replace(ne, ie) } var se = function (e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType }; function ae() { this.expando = M.expando + ae.uid++ } ae.uid = 1, ae.prototype = { cache: function (e) { var t = e[this.expando]; return t || (t = {}, se(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t }, set: function (e, t, n) { var i, r = this.cache(e); if ("string" == typeof t) r[re(t)] = n; else for (i in t) r[re(i)] = t[i]; return r }, get: function (e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][re(t)] }, access: function (e, t, n) { return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t) }, remove: function (e, t) { var n, i = e[this.expando]; if (void 0 !== i) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(re) : (t = re(t)) in i ? [t] : t.match(q) || []).length; for (; n--;)delete i[t[n]] } (void 0 === t || M.isEmptyObject(i)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]) } }, hasData: function (e) { var t = e[this.expando]; return void 0 !== t && !M.isEmptyObject(t) } }; var oe = new ae, le = new ae, ce = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, ue = /[A-Z]/g; function he(e, t, n) { var i; if (void 0 === n && 1 === e.nodeType) if (i = "data-" + t.replace(ue, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(i))) { try { n = function (e) { return "true" === e || "false" !== e && ("null" === e ? null : e === +e + "" ? +e : ce.test(e) ? JSON.parse(e) : e) }(n) } catch (e) { } le.set(e, t, n) } else n = void 0; return n } M.extend({ hasData: function (e) { return le.hasData(e) || oe.hasData(e) }, data: function (e, t, n) { return le.access(e, t, n) }, removeData: function (e, t) { le.remove(e, t) }, _data: function (e, t, n) { return oe.access(e, t, n) }, _removeData: function (e, t) { oe.remove(e, t) } }), M.fn.extend({ data: function (e, t) { var n, i, r, s = this[0], a = s && s.attributes; if (void 0 === e) { if (this.length && (r = le.get(s), 1 === s.nodeType && !oe.get(s, "hasDataAttrs"))) { for (n = a.length; n--;)a[n] && 0 === (i = a[n].name).indexOf("data-") && (i = re(i.slice(5)), he(s, i, r[i])); oe.set(s, "hasDataAttrs", !0) } return r } return "object" == typeof e ? this.each((function () { le.set(this, e) })) : ee(this, (function (t) { var n; if (s && void 0 === t) return void 0 !== (n = le.get(s, e)) || void 0 !== (n = he(s, e)) ? n : void 0; this.each((function () { le.set(this, e, t) })) }), null, t, arguments.length > 1, null, !0) }, removeData: function (e) { return this.each((function () { le.remove(this, e) })) } }), M.extend({ queue: function (e, t, n) { var i; if (e) return t = (t || "fx") + "queue", i = oe.get(e, t), n && (!i || Array.isArray(n) ? i = oe.access(e, t, M.makeArray(n)) : i.push(n)), i || [] }, dequeue: function (e, t) { t = t || "fx"; var n = M.queue(e, t), i = n.length, r = n.shift(), s = M._queueHooks(e, t); "inprogress" === r && (r = n.shift(), i--), r && ("fx" === t && n.unshift("inprogress"), delete s.stop, r.call(e, (function () { M.dequeue(e, t) }), s)), !i && s && s.empty.fire() }, _queueHooks: function (e, t) { var n = t + "queueHooks"; return oe.get(e, n) || oe.access(e, n, { empty: M.Callbacks("once memory").add((function () { oe.remove(e, [t + "queue", n]) })) }) } }), M.fn.extend({ queue: function (e, t) { var n = 2; return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? M.queue(this[0], e) : void 0 === t ? this : this.each((function () { var n = M.queue(this, e, t); M._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && M.dequeue(this, e) })) }, dequeue: function (e) { return this.each((function () { M.dequeue(this, e) })) }, clearQueue: function (e) { return this.queue(e || "fx", []) }, promise: function (e, t) { var n, i = 1, r = M.Deferred(), s = this, a = this.length, o = function () { --i || r.resolveWith(s, [s]) }; for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; a--;)(n = oe.get(s[a], e + "queueHooks")) && n.empty && (i++, n.empty.add(o)); return o(), r.promise(t) } }); var de = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, pe = new RegExp("^(?:([+-])=|)(" + de + ")([a-z%]*)$", "i"), fe = ["Top", "Right", "Bottom", "Left"], me = y.documentElement, ge = function (e) { return M.contains(e.ownerDocument, e) }, ve = { composed: !0 }; me.getRootNode && (ge = function (e) { return M.contains(e.ownerDocument, e) || e.getRootNode(ve) === e.ownerDocument }); var _e = function (e, t) { return "none" === (e = t || e).style.display || "" === e.style.display && ge(e) && "none" === M.css(e, "display") }; function ye(e, t, n, i) { var r, s, a = 20, o = i ? function () { return i.cur() } : function () { return M.css(e, t, "") }, l = o(), c = n && n[3] || (M.cssNumber[t] ? "" : "px"), u = e.nodeType && (M.cssNumber[t] || "px" !== c && +l) && pe.exec(M.css(e, t)); if (u && u[3] !== c) { for (l /= 2, c = c || u[3], u = +l || 1; a--;)M.style(e, t, u + c), (1 - s) * (1 - (s = o() / l || .5)) <= 0 && (a = 0), u /= s; u *= 2, M.style(e, t, u + c), n = n || [] } return n && (u = +u || +l || 0, r = n[1] ? u + (n[1] + 1) * n[2] : +n[2], i && (i.unit = c, i.start = u, i.end = r)), r } var xe = {}; function be(e) { var t, n = e.ownerDocument, i = e.nodeName, r = xe[i]; return r || (t = n.body.appendChild(n.createElement(i)), r = M.css(t, "display"), t.parentNode.removeChild(t), "none" === r && (r = "block"), xe[i] = r, r) } function Ee(e, t) { for (var n, i, r = [], s = 0, a = e.length; s < a; s++)(i = e[s]).style && (n = i.style.display, t ? ("none" === n && (r[s] = oe.get(i, "display") || null, r[s] || (i.style.display = "")), "" === i.style.display && _e(i) && (r[s] = be(i))) : "none" !== n && (r[s] = "none", oe.set(i, "display", n))); for (s = 0; s < a; s++)null != r[s] && (e[s].style.display = r[s]); return e } M.fn.extend({ show: function () { return Ee(this, !0) }, hide: function () { return Ee(this) }, toggle: function (e) { return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each((function () { _e(this) ? M(this).show() : M(this).hide() })) } }); var Te, Se, Me = /^(?:checkbox|radio)$/i, we = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, Ae = /^$|^module$|\/(?:java|ecma)script/i; Te = y.createDocumentFragment().appendChild(y.createElement("div")), (Se = y.createElement("input")).setAttribute("type", "radio"), Se.setAttribute("checked", "checked"), Se.setAttribute("name", "t"), Te.appendChild(Se), g.checkClone = Te.cloneNode(!0).cloneNode(!0).lastChild.checked, Te.innerHTML = "<textarea>x</textarea>", g.noCloneChecked = !!Te.cloneNode(!0).lastChild.defaultValue, Te.innerHTML = "<option></option>", g.option = !!Te.lastChild; var De = { thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; function Ce(e, t) { var n; return n = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? M.merge([e], n) : n } function Re(e, t) { for (var n = 0, i = e.length; n < i; n++)oe.set(e[n], "globalEval", !t || oe.get(t[n], "globalEval")) } De.tbody = De.tfoot = De.colgroup = De.caption = De.thead, De.th = De.td, g.option || (De.optgroup = De.option = [1, "<select multiple='multiple'>", "</select>"]); var Le = /<|&#?\w+;/; function Pe(e, t, n, i, r) { for (var s, a, o, l, c, u, h = t.createDocumentFragment(), d = [], p = 0, f = e.length; p < f; p++)if ((s = e[p]) || 0 === s) if ("object" === E(s)) M.merge(d, s.nodeType ? [s] : s); else if (Le.test(s)) { for (a = a || h.appendChild(t.createElement("div")), o = (we.exec(s) || ["", ""])[1].toLowerCase(), l = De[o] || De._default, a.innerHTML = l[1] + M.htmlPrefilter(s) + l[2], u = l[0]; u--;)a = a.lastChild; M.merge(d, a.childNodes), (a = h.firstChild).textContent = "" } else d.push(t.createTextNode(s)); for (h.textContent = "", p = 0; s = d[p++];)if (i && M.inArray(s, i) > -1) r && r.push(s); else if (c = ge(s), a = Ce(h.appendChild(s), "script"), c && Re(a), n) for (u = 0; s = a[u++];)Ae.test(s.type || "") && n.push(s); return h } var Ie = /^([^.]*)(?:\.(.+)|)/; function Ne() { return !0 } function Oe() { return !1 } function Fe(e, t, n, i, r, s) { var a, o; if ("object" == typeof t) { for (o in "string" != typeof n && (i = i || n, n = void 0), t) Fe(e, o, n, i, t[o], s); return e } if (null == i && null == r ? (r = n, i = n = void 0) : null == r && ("string" == typeof n ? (r = i, i = void 0) : (r = i, i = n, n = void 0)), !1 === r) r = Oe; else if (!r) return e; return 1 === s && (a = r, r = function (e) { return M().off(e), a.apply(this, arguments) }, r.guid = a.guid || (a.guid = M.guid++)), e.each((function () { M.event.add(this, t, r, i, n) })) } function Ue(e, t, n) { n ? (oe.set(e, t, !1), M.event.add(e, t, { namespace: !1, handler: function (e) { var n, i = oe.get(this, t); if (1 & e.isTrigger && this[t]) { if (i) (M.event.special[t] || {}).delegateType && e.stopPropagation(); else if (i = o.call(arguments), oe.set(this, t, i), this[t](), n = oe.get(this, t), oe.set(this, t, !1), i !== n) return e.stopImmediatePropagation(), e.preventDefault(), n } else i && (oe.set(this, t, M.event.trigger(i[0], i.slice(1), this)), e.stopPropagation(), e.isImmediatePropagationStopped = Ne) } })) : void 0 === oe.get(e, t) && M.event.add(e, t, Ne) } M.event = { global: {}, add: function (e, t, n, i, r) { var s, a, o, l, c, u, h, d, p, f, m, g = oe.get(e); if (se(e)) for (n.handler && (n = (s = n).handler, r = s.selector), r && M.find.matchesSelector(me, r), n.guid || (n.guid = M.guid++), (l = g.events) || (l = g.events = Object.create(null)), (a = g.handle) || (a = g.handle = function (t) { return void 0 !== M && M.event.triggered !== t.type ? M.event.dispatch.apply(e, arguments) : void 0 }), c = (t = (t || "").match(q) || [""]).length; c--;)p = m = (o = Ie.exec(t[c]) || [])[1], f = (o[2] || "").split(".").sort(), p && (h = M.event.special[p] || {}, p = (r ? h.delegateType : h.bindType) || p, h = M.event.special[p] || {}, u = M.extend({ type: p, origType: m, data: i, handler: n, guid: n.guid, selector: r, needsContext: r && M.expr.match.needsContext.test(r), namespace: f.join(".") }, s), (d = l[p]) || ((d = l[p] = []).delegateCount = 0, h.setup && !1 !== h.setup.call(e, i, f, a) || e.addEventListener && e.addEventListener(p, a)), h.add && (h.add.call(e, u), u.handler.guid || (u.handler.guid = n.guid)), r ? d.splice(d.delegateCount++, 0, u) : d.push(u), M.event.global[p] = !0) }, remove: function (e, t, n, i, r) { var s, a, o, l, c, u, h, d, p, f, m, g = oe.hasData(e) && oe.get(e); if (g && (l = g.events)) { for (c = (t = (t || "").match(q) || [""]).length; c--;)if (p = m = (o = Ie.exec(t[c]) || [])[1], f = (o[2] || "").split(".").sort(), p) { for (h = M.event.special[p] || {}, d = l[p = (i ? h.delegateType : h.bindType) || p] || [], o = o[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = s = d.length; s--;)u = d[s], !r && m !== u.origType || n && n.guid !== u.guid || o && !o.test(u.namespace) || i && i !== u.selector && ("**" !== i || !u.selector) || (d.splice(s, 1), u.selector && d.delegateCount--, h.remove && h.remove.call(e, u)); a && !d.length && (h.teardown && !1 !== h.teardown.call(e, f, g.handle) || M.removeEvent(e, p, g.handle), delete l[p]) } else for (p in l) M.event.remove(e, p + t[c], n, i, !0); M.isEmptyObject(l) && oe.remove(e, "handle events") } }, dispatch: function (e) { var t, n, i, r, s, a, o = new Array(arguments.length), l = M.event.fix(e), c = (oe.get(this, "events") || Object.create(null))[l.type] || [], u = M.event.special[l.type] || {}; for (o[0] = l, t = 1; t < arguments.length; t++)o[t] = arguments[t]; if (l.delegateTarget = this, !u.preDispatch || !1 !== u.preDispatch.call(this, l)) { for (a = M.event.handlers.call(this, l, c), t = 0; (r = a[t++]) && !l.isPropagationStopped();)for (l.currentTarget = r.elem, n = 0; (s = r.handlers[n++]) && !l.isImmediatePropagationStopped();)l.rnamespace && !1 !== s.namespace && !l.rnamespace.test(s.namespace) || (l.handleObj = s, l.data = s.data, void 0 !== (i = ((M.event.special[s.origType] || {}).handle || s.handler).apply(r.elem, o)) && !1 === (l.result = i) && (l.preventDefault(), l.stopPropagation())); return u.postDispatch && u.postDispatch.call(this, l), l.result } }, handlers: function (e, t) { var n, i, r, s, a, o = [], l = t.delegateCount, c = e.target; if (l && c.nodeType && !("click" === e.type && e.button >= 1)) for (; c !== this; c = c.parentNode || this)if (1 === c.nodeType && ("click" !== e.type || !0 !== c.disabled)) { for (s = [], a = {}, n = 0; n < l; n++)void 0 === a[r = (i = t[n]).selector + " "] && (a[r] = i.needsContext ? M(r, this).index(c) > -1 : M.find(r, this, null, [c]).length), a[r] && s.push(i); s.length && o.push({ elem: c, handlers: s }) } return c = this, l < t.length && o.push({ elem: c, handlers: t.slice(l) }), o }, addProp: function (e, t) { Object.defineProperty(M.Event.prototype, e, { enumerable: !0, configurable: !0, get: v(t) ? function () { if (this.originalEvent) return t(this.originalEvent) } : function () { if (this.originalEvent) return this.originalEvent[e] }, set: function (t) { Object.defineProperty(this, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) } }) }, fix: function (e) { return e[M.expando] ? e : new M.Event(e) }, special: { load: { noBubble: !0 }, click: { setup: function (e) { var t = this || e; return Me.test(t.type) && t.click && A(t, "input") && Ue(t, "click", !0), !1 }, trigger: function (e) { var t = this || e; return Me.test(t.type) && t.click && A(t, "input") && Ue(t, "click"), !0 }, _default: function (e) { var t = e.target; return Me.test(t.type) && t.click && A(t, "input") && oe.get(t, "click") || A(t, "a") } }, beforeunload: { postDispatch: function (e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } } }, M.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n) }, M.Event = function (e, t) { if (!(this instanceof M.Event)) return new M.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Ne : Oe, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && M.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[M.expando] = !0 }, M.Event.prototype = { constructor: M.Event, isDefaultPrevented: Oe, isPropagationStopped: Oe, isImmediatePropagationStopped: Oe, isSimulated: !1, preventDefault: function () { var e = this.originalEvent; this.isDefaultPrevented = Ne, e && !this.isSimulated && e.preventDefault() }, stopPropagation: function () { var e = this.originalEvent; this.isPropagationStopped = Ne, e && !this.isSimulated && e.stopPropagation() }, stopImmediatePropagation: function () { var e = this.originalEvent; this.isImmediatePropagationStopped = Ne, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation() } }, M.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, char: !0, code: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: !0 }, M.event.addProp), M.each({ focus: "focusin", blur: "focusout" }, (function (e, t) { function n(e) { if (y.documentMode) { var n = oe.get(this, "handle"), i = M.event.fix(e); i.type = "focusin" === e.type ? "focus" : "blur", i.isSimulated = !0, n(e), i.target === i.currentTarget && n(i) } else M.event.simulate(t, e.target, M.event.fix(e)) } M.event.special[e] = { setup: function () { var i; if (Ue(this, e, !0), !y.documentMode) return !1; (i = oe.get(this, t)) || this.addEventListener(t, n), oe.set(this, t, (i || 0) + 1) }, trigger: function () { return Ue(this, e), !0 }, teardown: function () { var e; if (!y.documentMode) return !1; (e = oe.get(this, t) - 1) ? oe.set(this, t, e) : (this.removeEventListener(t, n), oe.remove(this, t)) }, _default: function (t) { return oe.get(t.target, e) }, delegateType: t }, M.event.special[t] = { setup: function () { var i = this.ownerDocument || this.document || this, r = y.documentMode ? this : i, s = oe.get(r, t); s || (y.documentMode ? this.addEventListener(t, n) : i.addEventListener(e, n, !0)), oe.set(r, t, (s || 0) + 1) }, teardown: function () { var i = this.ownerDocument || this.document || this, r = y.documentMode ? this : i, s = oe.get(r, t) - 1; s ? oe.set(r, t, s) : (y.documentMode ? this.removeEventListener(t, n) : i.removeEventListener(e, n, !0), oe.remove(r, t)) } } })), M.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, (function (e, t) { M.event.special[e] = { delegateType: t, bindType: t, handle: function (e) { var n, i = e.relatedTarget, r = e.handleObj; return i && (i === this || M.contains(this, i)) || (e.type = r.origType, n = r.handler.apply(this, arguments), e.type = t), n } } })), M.fn.extend({ on: function (e, t, n, i) { return Fe(this, e, t, n, i) }, one: function (e, t, n, i) { return Fe(this, e, t, n, i, 1) }, off: function (e, t, n) { var i, r; if (e && e.preventDefault && e.handleObj) return i = e.handleObj, M(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this; if ("object" == typeof e) { for (r in e) this.off(r, t, e[r]); return this } return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Oe), this.each((function () { M.event.remove(this, e, n, t) })) } }); var Be = /<script|<style|<link/i, ke = /checked\s*(?:[^=]|=\s*.checked.)/i, ze = /^\s*<!\[CDATA\[|\]\]>\s*$/g; function He(e, t) { return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && M(e).children("tbody")[0] || e } function Ge(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e } function Ve(e) { return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e } function We(e, t) { var n, i, r, s, a, o; if (1 === t.nodeType) { if (oe.hasData(e) && (o = oe.get(e).events)) for (r in oe.remove(t, "handle events"), o) for (n = 0, i = o[r].length; n < i; n++)M.event.add(t, r, o[r][n]); le.hasData(e) && (s = le.access(e), a = M.extend({}, s), le.set(t, a)) } } function je(e, t) { var n = t.nodeName.toLowerCase(); "input" === n && Me.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue) } function Xe(e, t, n, i) { t = l(t); var r, s, a, o, c, u, h = 0, d = e.length, p = d - 1, f = t[0], m = v(f); if (m || d > 1 && "string" == typeof f && !g.checkClone && ke.test(f)) return e.each((function (r) { var s = e.eq(r); m && (t[0] = f.call(this, r, s.html())), Xe(s, t, n, i) })); if (d && (s = (r = Pe(t, e[0].ownerDocument, !1, e, i)).firstChild, 1 === r.childNodes.length && (r = s), s || i)) { for (o = (a = M.map(Ce(r, "script"), Ge)).length; h < d; h++)c = r, h !== p && (c = M.clone(c, !0, !0), o && M.merge(a, Ce(c, "script"))), n.call(e[h], c, h); if (o) for (u = a[a.length - 1].ownerDocument, M.map(a, Ve), h = 0; h < o; h++)c = a[h], Ae.test(c.type || "") && !oe.access(c, "globalEval") && M.contains(u, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? M._evalUrl && !c.noModule && M._evalUrl(c.src, { nonce: c.nonce || c.getAttribute("nonce") }, u) : b(c.textContent.replace(ze, ""), c, u)) } return e } function qe(e, t, n) { for (var i, r = t ? M.filter(t, e) : e, s = 0; null != (i = r[s]); s++)n || 1 !== i.nodeType || M.cleanData(Ce(i)), i.parentNode && (n && ge(i) && Re(Ce(i, "script")), i.parentNode.removeChild(i)); return e } M.extend({ htmlPrefilter: function (e) { return e }, clone: function (e, t, n) { var i, r, s, a, o = e.cloneNode(!0), l = ge(e); if (!(g.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || M.isXMLDoc(e))) for (a = Ce(o), i = 0, r = (s = Ce(e)).length; i < r; i++)je(s[i], a[i]); if (t) if (n) for (s = s || Ce(e), a = a || Ce(o), i = 0, r = s.length; i < r; i++)We(s[i], a[i]); else We(e, o); return (a = Ce(o, "script")).length > 0 && Re(a, !l && Ce(e, "script")), o }, cleanData: function (e) { for (var t, n, i, r = M.event.special, s = 0; void 0 !== (n = e[s]); s++)if (se(n)) { if (t = n[oe.expando]) { if (t.events) for (i in t.events) r[i] ? M.event.remove(n, i) : M.removeEvent(n, i, t.handle); n[oe.expando] = void 0 } n[le.expando] && (n[le.expando] = void 0) } } }), M.fn.extend({ detach: function (e) { return qe(this, e, !0) }, remove: function (e) { return qe(this, e) }, text: function (e) { return ee(this, (function (e) { return void 0 === e ? M.text(this) : this.empty().each((function () { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) })) }), null, e, arguments.length) }, append: function () { return Xe(this, arguments, (function (e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || He(this, e).appendChild(e) })) }, prepend: function () { return Xe(this, arguments, (function (e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = He(this, e); t.insertBefore(e, t.firstChild) } })) }, before: function () { return Xe(this, arguments, (function (e) { this.parentNode && this.parentNode.insertBefore(e, this) })) }, after: function () { return Xe(this, arguments, (function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) })) }, empty: function () { for (var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (M.cleanData(Ce(e, !1)), e.textContent = ""); return this }, clone: function (e, t) { return e = null != e && e, t = null == t ? e : t, this.map((function () { return M.clone(this, e, t) })) }, html: function (e) { return ee(this, (function (e) { var t = this[0] || {}, n = 0, i = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e && !Be.test(e) && !De[(we.exec(e) || ["", ""])[1].toLowerCase()]) { e = M.htmlPrefilter(e); try { for (; n < i; n++)1 === (t = this[n] || {}).nodeType && (M.cleanData(Ce(t, !1)), t.innerHTML = e); t = 0 } catch (e) { } } t && this.empty().append(e) }), null, e, arguments.length) }, replaceWith: function () { var e = []; return Xe(this, arguments, (function (t) { var n = this.parentNode; M.inArray(this, e) < 0 && (M.cleanData(Ce(this)), n && n.replaceChild(t, this)) }), e) } }), M.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, (function (e, t) { M.fn[e] = function (e) { for (var n, i = [], r = M(e), s = r.length - 1, a = 0; a <= s; a++)n = a === s ? this : this.clone(!0), M(r[a])[t](n), c.apply(i, n.get()); return this.pushStack(i) } })); var Ye = new RegExp("^(" + de + ")(?!px)[a-z%]+$", "i"), Ke = /^--/, $e = function (e) { var t = e.ownerDocument.defaultView; return t && t.opener || (t = i), t.getComputedStyle(e) }, Ze = function (e, t, n) { var i, r, s = {}; for (r in t) s[r] = e.style[r], e.style[r] = t[r]; for (r in i = n.call(e), t) e.style[r] = s[r]; return i }, Je = new RegExp(fe.join("|"), "i"); function Qe(e, t, n) { var i, r, s, a, o = Ke.test(t), l = e.style; return (n = n || $e(e)) && (a = n.getPropertyValue(t) || n[t], o && a && (a = a.replace(P, "$1") || void 0), "" !== a || ge(e) || (a = M.style(e, t)), !g.pixelBoxStyles() && Ye.test(a) && Je.test(t) && (i = l.width, r = l.minWidth, s = l.maxWidth, l.minWidth = l.maxWidth = l.width = a, a = n.width, l.width = i, l.minWidth = r, l.maxWidth = s)), void 0 !== a ? a + "" : a } function et(e, t) { return { get: function () { if (!e()) return (this.get = t).apply(this, arguments); delete this.get } } } !function () { function e() { if (u) { c.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", me.appendChild(c).appendChild(u); var e = i.getComputedStyle(u); n = "1%" !== e.top, l = 12 === t(e.marginLeft), u.style.right = "60%", a = 36 === t(e.right), r = 36 === t(e.width), u.style.position = "absolute", s = 12 === t(u.offsetWidth / 3), me.removeChild(c), u = null } } function t(e) { return Math.round(parseFloat(e)) } var n, r, s, a, o, l, c = y.createElement("div"), u = y.createElement("div"); u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", g.clearCloneStyle = "content-box" === u.style.backgroundClip, M.extend(g, { boxSizingReliable: function () { return e(), r }, pixelBoxStyles: function () { return e(), a }, pixelPosition: function () { return e(), n }, reliableMarginLeft: function () { return e(), l }, scrollboxSize: function () { return e(), s }, reliableTrDimensions: function () { var e, t, n, r; return null == o && (e = y.createElement("table"), t = y.createElement("tr"), n = y.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", me.appendChild(e).appendChild(t).appendChild(n), r = i.getComputedStyle(t), o = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, me.removeChild(e)), o } })) }(); var tt = ["Webkit", "Moz", "ms"], nt = y.createElement("div").style, it = {}; function rt(e) { var t = M.cssProps[e] || it[e]; return t || (e in nt ? e : it[e] = function (e) { for (var t = e[0].toUpperCase() + e.slice(1), n = tt.length; n--;)if ((e = tt[n] + t) in nt) return e }(e) || e) } var st = /^(none|table(?!-c[ea]).+)/, at = { position: "absolute", visibility: "hidden", display: "block" }, ot = { letterSpacing: "0", fontWeight: "400" }; function lt(e, t, n) { var i = pe.exec(t); return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : t } function ct(e, t, n, i, r, s) { var a = "width" === t ? 1 : 0, o = 0, l = 0, c = 0; if (n === (i ? "border" : "content")) return 0; for (; a < 4; a += 2)"margin" === n && (c += M.css(e, n + fe[a], !0, r)), i ? ("content" === n && (l -= M.css(e, "padding" + fe[a], !0, r)), "margin" !== n && (l -= M.css(e, "border" + fe[a] + "Width", !0, r))) : (l += M.css(e, "padding" + fe[a], !0, r), "padding" !== n ? l += M.css(e, "border" + fe[a] + "Width", !0, r) : o += M.css(e, "border" + fe[a] + "Width", !0, r)); return !i && s >= 0 && (l += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - s - l - o - .5)) || 0), l + c } function ut(e, t, n) { var i = $e(e), r = (!g.boxSizingReliable() || n) && "border-box" === M.css(e, "boxSizing", !1, i), s = r, a = Qe(e, t, i), o = "offset" + t[0].toUpperCase() + t.slice(1); if (Ye.test(a)) { if (!n) return a; a = "auto" } return (!g.boxSizingReliable() && r || !g.reliableTrDimensions() && A(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === M.css(e, "display", !1, i)) && e.getClientRects().length && (r = "border-box" === M.css(e, "boxSizing", !1, i), (s = o in e) && (a = e[o])), (a = parseFloat(a) || 0) + ct(e, t, n || (r ? "border" : "content"), s, i, a) + "px" } function ht(e, t, n, i, r) { return new ht.prototype.init(e, t, n, i, r) } M.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var n = Qe(e, "opacity"); return "" === n ? "1" : n } } } }, cssNumber: { animationIterationCount: !0, aspectRatio: !0, borderImageSlice: !0, columnCount: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, gridArea: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnStart: !0, gridRow: !0, gridRowEnd: !0, gridRowStart: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, scale: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeMiterlimit: !0, strokeOpacity: !0 }, cssProps: {}, style: function (e, t, n, i) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var r, s, a, o = re(t), l = Ke.test(t), c = e.style; if (l || (t = rt(o)), a = M.cssHooks[t] || M.cssHooks[o], void 0 === n) return a && "get" in a && void 0 !== (r = a.get(e, !1, i)) ? r : c[t]; "string" === (s = typeof n) && (r = pe.exec(n)) && r[1] && (n = ye(e, t, r), s = "number"), null != n && n == n && ("number" !== s || l || (n += r && r[3] || (M.cssNumber[o] ? "" : "px")), g.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (c[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, i)) || (l ? c.setProperty(t, n) : c[t] = n)) } }, css: function (e, t, n, i) { var r, s, a, o = re(t); return Ke.test(t) || (t = rt(o)), (a = M.cssHooks[t] || M.cssHooks[o]) && "get" in a && (r = a.get(e, !0, n)), void 0 === r && (r = Qe(e, t, i)), "normal" === r && t in ot && (r = ot[t]), "" === n || n ? (s = parseFloat(r), !0 === n || isFinite(s) ? s || 0 : r) : r } }), M.each(["height", "width"], (function (e, t) { M.cssHooks[t] = { get: function (e, n, i) { if (n) return !st.test(M.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? ut(e, t, i) : Ze(e, at, (function () { return ut(e, t, i) })) }, set: function (e, n, i) { var r, s = $e(e), a = !g.scrollboxSize() && "absolute" === s.position, o = (a || i) && "border-box" === M.css(e, "boxSizing", !1, s), l = i ? ct(e, t, i, o, s) : 0; return o && a && (l -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(s[t]) - ct(e, t, "border", !1, s) - .5)), l && (r = pe.exec(n)) && "px" !== (r[3] || "px") && (e.style[t] = n, n = M.css(e, t)), lt(0, n, l) } } })), M.cssHooks.marginLeft = et(g.reliableMarginLeft, (function (e, t) { if (t) return (parseFloat(Qe(e, "marginLeft")) || e.getBoundingClientRect().left - Ze(e, { marginLeft: 0 }, (function () { return e.getBoundingClientRect().left }))) + "px" })), M.each({ margin: "", padding: "", border: "Width" }, (function (e, t) { M.cssHooks[e + t] = { expand: function (n) { for (var i = 0, r = {}, s = "string" == typeof n ? n.split(" ") : [n]; i < 4; i++)r[e + fe[i] + t] = s[i] || s[i - 2] || s[0]; return r } }, "margin" !== e && (M.cssHooks[e + t].set = lt) })), M.fn.extend({ css: function (e, t) { return ee(this, (function (e, t, n) { var i, r, s = {}, a = 0; if (Array.isArray(t)) { for (i = $e(e), r = t.length; a < r; a++)s[t[a]] = M.css(e, t[a], !1, i); return s } return void 0 !== n ? M.style(e, t, n) : M.css(e, t) }), e, t, arguments.length > 1) } }), M.Tween = ht, ht.prototype = { constructor: ht, init: function (e, t, n, i, r, s) { this.elem = e, this.prop = n, this.easing = r || M.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = i, this.unit = s || (M.cssNumber[n] ? "" : "px") }, cur: function () { var e = ht.propHooks[this.prop]; return e && e.get ? e.get(this) : ht.propHooks._default.get(this) }, run: function (e) { var t, n = ht.propHooks[this.prop]; return this.options.duration ? this.pos = t = M.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : ht.propHooks._default.set(this), this } }, ht.prototype.init.prototype = ht.prototype, ht.propHooks = { _default: { get: function (e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = M.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0 }, set: function (e) { M.fx.step[e.prop] ? M.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !M.cssHooks[e.prop] && null == e.elem.style[rt(e.prop)] ? e.elem[e.prop] = e.now : M.style(e.elem, e.prop, e.now + e.unit) } } }, ht.propHooks.scrollTop = ht.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, M.easing = { linear: function (e) { return e }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2 }, _default: "swing" }, M.fx = ht.prototype.init, M.fx.step = {}; var dt, pt, ft = /^(?:toggle|show|hide)$/, mt = /queueHooks$/; function gt() { pt && (!1 === y.hidden && i.requestAnimationFrame ? i.requestAnimationFrame(gt) : i.setTimeout(gt, M.fx.interval), M.fx.tick()) } function vt() { return i.setTimeout((function () { dt = void 0 })), dt = Date.now() } function _t(e, t) { var n, i = 0, r = { height: e }; for (t = t ? 1 : 0; i < 4; i += 2 - t)r["margin" + (n = fe[i])] = r["padding" + n] = e; return t && (r.opacity = r.width = e), r } function yt(e, t, n) { for (var i, r = (xt.tweeners[t] || []).concat(xt.tweeners["*"]), s = 0, a = r.length; s < a; s++)if (i = r[s].call(n, t, e)) return i } function xt(e, t, n) { var i, r, s = 0, a = xt.prefilters.length, o = M.Deferred().always((function () { delete l.elem })), l = function () { if (r) return !1; for (var t = dt || vt(), n = Math.max(0, c.startTime + c.duration - t), i = 1 - (n / c.duration || 0), s = 0, a = c.tweens.length; s < a; s++)c.tweens[s].run(i); return o.notifyWith(e, [c, i, n]), i < 1 && a ? n : (a || o.notifyWith(e, [c, 1, 0]), o.resolveWith(e, [c]), !1) }, c = o.promise({ elem: e, props: M.extend({}, t), opts: M.extend(!0, { specialEasing: {}, easing: M.easing._default }, n), originalProperties: t, originalOptions: n, startTime: dt || vt(), duration: n.duration, tweens: [], createTween: function (t, n) { var i = M.Tween(e, c.opts, t, n, c.opts.specialEasing[t] || c.opts.easing); return c.tweens.push(i), i }, stop: function (t) { var n = 0, i = t ? c.tweens.length : 0; if (r) return this; for (r = !0; n < i; n++)c.tweens[n].run(1); return t ? (o.notifyWith(e, [c, 1, 0]), o.resolveWith(e, [c, t])) : o.rejectWith(e, [c, t]), this } }), u = c.props; for (!function (e, t) { var n, i, r, s, a; for (n in e) if (r = t[i = re(n)], s = e[n], Array.isArray(s) && (r = s[1], s = e[n] = s[0]), n !== i && (e[i] = s, delete e[n]), (a = M.cssHooks[i]) && "expand" in a) for (n in s = a.expand(s), delete e[i], s) n in e || (e[n] = s[n], t[n] = r); else t[i] = r }(u, c.opts.specialEasing); s < a; s++)if (i = xt.prefilters[s].call(c, e, u, c.opts)) return v(i.stop) && (M._queueHooks(c.elem, c.opts.queue).stop = i.stop.bind(i)), i; return M.map(u, yt, c), v(c.opts.start) && c.opts.start.call(e, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), M.fx.timer(M.extend(l, { elem: e, anim: c, queue: c.opts.queue })), c } M.Animation = M.extend(xt, { tweeners: { "*": [function (e, t) { var n = this.createTween(e, t); return ye(n.elem, e, pe.exec(t), n), n }] }, tweener: function (e, t) { v(e) ? (t = e, e = ["*"]) : e = e.match(q); for (var n, i = 0, r = e.length; i < r; i++)n = e[i], xt.tweeners[n] = xt.tweeners[n] || [], xt.tweeners[n].unshift(t) }, prefilters: [function (e, t, n) { var i, r, s, a, o, l, c, u, h = "width" in t || "height" in t, d = this, p = {}, f = e.style, m = e.nodeType && _e(e), g = oe.get(e, "fxshow"); for (i in n.queue || (null == (a = M._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, o = a.empty.fire, a.empty.fire = function () { a.unqueued || o() }), a.unqueued++, d.always((function () { d.always((function () { a.unqueued--, M.queue(e, "fx").length || a.empty.fire() })) }))), t) if (r = t[i], ft.test(r)) { if (delete t[i], s = s || "toggle" === r, r === (m ? "hide" : "show")) { if ("show" !== r || !g || void 0 === g[i]) continue; m = !0 } p[i] = g && g[i] || M.style(e, i) } if ((l = !M.isEmptyObject(t)) || !M.isEmptyObject(p)) for (i in h && 1 === e.nodeType && (n.overflow = [f.overflow, f.overflowX, f.overflowY], null == (c = g && g.display) && (c = oe.get(e, "display")), "none" === (u = M.css(e, "display")) && (c ? u = c : (Ee([e], !0), c = e.style.display || c, u = M.css(e, "display"), Ee([e]))), ("inline" === u || "inline-block" === u && null != c) && "none" === M.css(e, "float") && (l || (d.done((function () { f.display = c })), null == c && (u = f.display, c = "none" === u ? "" : u)), f.display = "inline-block")), n.overflow && (f.overflow = "hidden", d.always((function () { f.overflow = n.overflow[0], f.overflowX = n.overflow[1], f.overflowY = n.overflow[2] }))), l = !1, p) l || (g ? "hidden" in g && (m = g.hidden) : g = oe.access(e, "fxshow", { display: c }), s && (g.hidden = !m), m && Ee([e], !0), d.done((function () { for (i in m || Ee([e]), oe.remove(e, "fxshow"), p) M.style(e, i, p[i]) }))), l = yt(m ? g[i] : 0, i, d), i in g || (g[i] = l.start, m && (l.end = l.start, l.start = 0)) }], prefilter: function (e, t) { t ? xt.prefilters.unshift(e) : xt.prefilters.push(e) } }), M.speed = function (e, t, n) { var i = e && "object" == typeof e ? M.extend({}, e) : { complete: n || !n && t || v(e) && e, duration: e, easing: n && t || t && !v(t) && t }; return M.fx.off ? i.duration = 0 : "number" != typeof i.duration && (i.duration in M.fx.speeds ? i.duration = M.fx.speeds[i.duration] : i.duration = M.fx.speeds._default), null != i.queue && !0 !== i.queue || (i.queue = "fx"), i.old = i.complete, i.complete = function () { v(i.old) && i.old.call(this), i.queue && M.dequeue(this, i.queue) }, i }, M.fn.extend({ fadeTo: function (e, t, n, i) { return this.filter(_e).css("opacity", 0).show().end().animate({ opacity: t }, e, n, i) }, animate: function (e, t, n, i) { var r = M.isEmptyObject(e), s = M.speed(t, n, i), a = function () { var t = xt(this, M.extend({}, e), s); (r || oe.get(this, "finish")) && t.stop(!0) }; return a.finish = a, r || !1 === s.queue ? this.each(a) : this.queue(s.queue, a) }, stop: function (e, t, n) { var i = function (e) { var t = e.stop; delete e.stop, t(n) }; return "string" != typeof e && (n = t, t = e, e = void 0), t && this.queue(e || "fx", []), this.each((function () { var t = !0, r = null != e && e + "queueHooks", s = M.timers, a = oe.get(this); if (r) a[r] && a[r].stop && i(a[r]); else for (r in a) a[r] && a[r].stop && mt.test(r) && i(a[r]); for (r = s.length; r--;)s[r].elem !== this || null != e && s[r].queue !== e || (s[r].anim.stop(n), t = !1, s.splice(r, 1)); !t && n || M.dequeue(this, e) })) }, finish: function (e) { return !1 !== e && (e = e || "fx"), this.each((function () { var t, n = oe.get(this), i = n[e + "queue"], r = n[e + "queueHooks"], s = M.timers, a = i ? i.length : 0; for (n.finish = !0, M.queue(this, e, []), r && r.stop && r.stop.call(this, !0), t = s.length; t--;)s[t].elem === this && s[t].queue === e && (s[t].anim.stop(!0), s.splice(t, 1)); for (t = 0; t < a; t++)i[t] && i[t].finish && i[t].finish.call(this); delete n.finish })) } }), M.each(["toggle", "show", "hide"], (function (e, t) { var n = M.fn[t]; M.fn[t] = function (e, i, r) { return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(_t(t, !0), e, i, r) } })), M.each({ slideDown: _t("show"), slideUp: _t("hide"), slideToggle: _t("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, (function (e, t) { M.fn[e] = function (e, n, i) { return this.animate(t, e, n, i) } })), M.timers = [], M.fx.tick = function () { var e, t = 0, n = M.timers; for (dt = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1); n.length || M.fx.stop(), dt = void 0 }, M.fx.timer = function (e) { M.timers.push(e), M.fx.start() }, M.fx.interval = 13, M.fx.start = function () { pt || (pt = !0, gt()) }, M.fx.stop = function () { pt = null }, M.fx.speeds = { slow: 600, fast: 200, _default: 400 }, M.fn.delay = function (e, t) { return e = M.fx && M.fx.speeds[e] || e, t = t || "fx", this.queue(t, (function (t, n) { var r = i.setTimeout(t, e); n.stop = function () { i.clearTimeout(r) } })) }, function () { var e = y.createElement("input"), t = y.createElement("select").appendChild(y.createElement("option")); e.type = "checkbox", g.checkOn = "" !== e.value, g.optSelected = t.selected, (e = y.createElement("input")).value = "t", e.type = "radio", g.radioValue = "t" === e.value }(); var bt, Et = M.expr.attrHandle; M.fn.extend({ attr: function (e, t) { return ee(this, M.attr, e, t, arguments.length > 1) }, removeAttr: function (e) { return this.each((function () { M.removeAttr(this, e) })) } }), M.extend({ attr: function (e, t, n) { var i, r, s = e.nodeType; if (3 !== s && 8 !== s && 2 !== s) return void 0 === e.getAttribute ? M.prop(e, t, n) : (1 === s && M.isXMLDoc(e) || (r = M.attrHooks[t.toLowerCase()] || (M.expr.match.bool.test(t) ? bt : void 0)), void 0 !== n ? null === n ? void M.removeAttr(e, t) : r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : (e.setAttribute(t, n + ""), n) : r && "get" in r && null !== (i = r.get(e, t)) ? i : null == (i = M.find.attr(e, t)) ? void 0 : i) }, attrHooks: { type: { set: function (e, t) { if (!g.radioValue && "radio" === t && A(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t } } } }, removeAttr: function (e, t) { var n, i = 0, r = t && t.match(q); if (r && 1 === e.nodeType) for (; n = r[i++];)e.removeAttribute(n) } }), bt = { set: function (e, t, n) { return !1 === t ? M.removeAttr(e, n) : e.setAttribute(n, n), n } }, M.each(M.expr.match.bool.source.match(/\w+/g), (function (e, t) { var n = Et[t] || M.find.attr; Et[t] = function (e, t, i) { var r, s, a = t.toLowerCase(); return i || (s = Et[a], Et[a] = r, r = null != n(e, t, i) ? a : null, Et[a] = s), r } })); var Tt = /^(?:input|select|textarea|button)$/i, St = /^(?:a|area)$/i; function Mt(e) { return (e.match(q) || []).join(" ") } function wt(e) { return e.getAttribute && e.getAttribute("class") || "" } function At(e) { return Array.isArray(e) ? e : "string" == typeof e && e.match(q) || [] } M.fn.extend({ prop: function (e, t) { return ee(this, M.prop, e, t, arguments.length > 1) }, removeProp: function (e) { return this.each((function () { delete this[M.propFix[e] || e] })) } }), M.extend({ prop: function (e, t, n) { var i, r, s = e.nodeType; if (3 !== s && 8 !== s && 2 !== s) return 1 === s && M.isXMLDoc(e) || (t = M.propFix[t] || t, r = M.propHooks[t]), void 0 !== n ? r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : e[t] = n : r && "get" in r && null !== (i = r.get(e, t)) ? i : e[t] }, propHooks: { tabIndex: { get: function (e) { var t = M.find.attr(e, "tabindex"); return t ? parseInt(t, 10) : Tt.test(e.nodeName) || St.test(e.nodeName) && e.href ? 0 : -1 } } }, propFix: { for: "htmlFor", class: "className" } }), g.optSelected || (M.propHooks.selected = { get: function (e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null }, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex) } }), M.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function () { M.propFix[this.toLowerCase()] = this })), M.fn.extend({ addClass: function (e) { var t, n, i, r, s, a; return v(e) ? this.each((function (t) { M(this).addClass(e.call(this, t, wt(this))) })) : (t = At(e)).length ? this.each((function () { if (i = wt(this), n = 1 === this.nodeType && " " + Mt(i) + " ") { for (s = 0; s < t.length; s++)r = t[s], n.indexOf(" " + r + " ") < 0 && (n += r + " "); a = Mt(n), i !== a && this.setAttribute("class", a) } })) : this }, removeClass: function (e) { var t, n, i, r, s, a; return v(e) ? this.each((function (t) { M(this).removeClass(e.call(this, t, wt(this))) })) : arguments.length ? (t = At(e)).length ? this.each((function () { if (i = wt(this), n = 1 === this.nodeType && " " + Mt(i) + " ") { for (s = 0; s < t.length; s++)for (r = t[s]; n.indexOf(" " + r + " ") > -1;)n = n.replace(" " + r + " ", " "); a = Mt(n), i !== a && this.setAttribute("class", a) } })) : this : this.attr("class", "") }, toggleClass: function (e, t) { var n, i, r, s, a = typeof e, o = "string" === a || Array.isArray(e); return v(e) ? this.each((function (n) { M(this).toggleClass(e.call(this, n, wt(this), t), t) })) : "boolean" == typeof t && o ? t ? this.addClass(e) : this.removeClass(e) : (n = At(e), this.each((function () { if (o) for (s = M(this), r = 0; r < n.length; r++)i = n[r], s.hasClass(i) ? s.removeClass(i) : s.addClass(i); else void 0 !== e && "boolean" !== a || ((i = wt(this)) && oe.set(this, "__className__", i), this.setAttribute && this.setAttribute("class", i || !1 === e ? "" : oe.get(this, "__className__") || "")) }))) }, hasClass: function (e) { var t, n, i = 0; for (t = " " + e + " "; n = this[i++];)if (1 === n.nodeType && (" " + Mt(wt(n)) + " ").indexOf(t) > -1) return !0; return !1 } }); var Dt = /\r/g; M.fn.extend({ val: function (e) { var t, n, i, r = this[0]; return arguments.length ? (i = v(e), this.each((function (n) { var r; 1 === this.nodeType && (null == (r = i ? e.call(this, n, M(this).val()) : e) ? r = "" : "number" == typeof r ? r += "" : Array.isArray(r) && (r = M.map(r, (function (e) { return null == e ? "" : e + "" }))), (t = M.valHooks[this.type] || M.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, r, "value") || (this.value = r)) }))) : r ? (t = M.valHooks[r.type] || M.valHooks[r.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(r, "value")) ? n : "string" == typeof (n = r.value) ? n.replace(Dt, "") : null == n ? "" : n : void 0 } }), M.extend({ valHooks: { option: { get: function (e) { var t = M.find.attr(e, "value"); return null != t ? t : Mt(M.text(e)) } }, select: { get: function (e) { var t, n, i, r = e.options, s = e.selectedIndex, a = "select-one" === e.type, o = a ? null : [], l = a ? s + 1 : r.length; for (i = s < 0 ? l : a ? s : 0; i < l; i++)if (((n = r[i]).selected || i === s) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) { if (t = M(n).val(), a) return t; o.push(t) } return o }, set: function (e, t) { for (var n, i, r = e.options, s = M.makeArray(t), a = r.length; a--;)((i = r[a]).selected = M.inArray(M.valHooks.option.get(i), s) > -1) && (n = !0); return n || (e.selectedIndex = -1), s } } } }), M.each(["radio", "checkbox"], (function () { M.valHooks[this] = { set: function (e, t) { if (Array.isArray(t)) return e.checked = M.inArray(M(e).val(), t) > -1 } }, g.checkOn || (M.valHooks[this].get = function (e) { return null === e.getAttribute("value") ? "on" : e.value }) })); var Ct = i.location, Rt = { guid: Date.now() }, Lt = /\?/; M.parseXML = function (e) { var t, n; if (!e || "string" != typeof e) return null; try { t = (new i.DOMParser).parseFromString(e, "text/xml") } catch (e) { } return n = t && t.getElementsByTagName("parsererror")[0], t && !n || M.error("Invalid XML: " + (n ? M.map(n.childNodes, (function (e) { return e.textContent })).join("\n") : e)), t }; var Pt = /^(?:focusinfocus|focusoutblur)$/, It = function (e) { e.stopPropagation() }; M.extend(M.event, { trigger: function (e, t, n, r) { var s, a, o, l, c, u, h, d, f = [n || y], m = p.call(e, "type") ? e.type : e, g = p.call(e, "namespace") ? e.namespace.split(".") : []; if (a = d = o = n = n || y, 3 !== n.nodeType && 8 !== n.nodeType && !Pt.test(m + M.event.triggered) && (m.indexOf(".") > -1 && (g = m.split("."), m = g.shift(), g.sort()), c = m.indexOf(":") < 0 && "on" + m, (e = e[M.expando] ? e : new M.Event(m, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = g.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + g.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : M.makeArray(t, [e]), h = M.event.special[m] || {}, r || !h.trigger || !1 !== h.trigger.apply(n, t))) { if (!r && !h.noBubble && !_(n)) { for (l = h.delegateType || m, Pt.test(l + m) || (a = a.parentNode); a; a = a.parentNode)f.push(a), o = a; o === (n.ownerDocument || y) && f.push(o.defaultView || o.parentWindow || i) } for (s = 0; (a = f[s++]) && !e.isPropagationStopped();)d = a, e.type = s > 1 ? l : h.bindType || m, (u = (oe.get(a, "events") || Object.create(null))[e.type] && oe.get(a, "handle")) && u.apply(a, t), (u = c && a[c]) && u.apply && se(a) && (e.result = u.apply(a, t), !1 === e.result && e.preventDefault()); return e.type = m, r || e.isDefaultPrevented() || h._default && !1 !== h._default.apply(f.pop(), t) || !se(n) || c && v(n[m]) && !_(n) && ((o = n[c]) && (n[c] = null), M.event.triggered = m, e.isPropagationStopped() && d.addEventListener(m, It), n[m](), e.isPropagationStopped() && d.removeEventListener(m, It), M.event.triggered = void 0, o && (n[c] = o)), e.result } }, simulate: function (e, t, n) { var i = M.extend(new M.Event, n, { type: e, isSimulated: !0 }); M.event.trigger(i, null, t) } }), M.fn.extend({ trigger: function (e, t) { return this.each((function () { M.event.trigger(e, t, this) })) }, triggerHandler: function (e, t) { var n = this[0]; if (n) return M.event.trigger(e, t, n, !0) } }); var Nt = /\[\]$/, Ot = /\r?\n/g, Ft = /^(?:submit|button|image|reset|file)$/i, Ut = /^(?:input|select|textarea|keygen)/i; function Bt(e, t, n, i) { var r; if (Array.isArray(t)) M.each(t, (function (t, r) { n || Nt.test(e) ? i(e, r) : Bt(e + "[" + ("object" == typeof r && null != r ? t : "") + "]", r, n, i) })); else if (n || "object" !== E(t)) i(e, t); else for (r in t) Bt(e + "[" + r + "]", t[r], n, i) } M.param = function (e, t) { var n, i = [], r = function (e, t) { var n = v(t) ? t() : t; i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n) }; if (null == e) return ""; if (Array.isArray(e) || e.jquery && !M.isPlainObject(e)) M.each(e, (function () { r(this.name, this.value) })); else for (n in e) Bt(n, e[n], t, r); return i.join("&") }, M.fn.extend({ serialize: function () { return M.param(this.serializeArray()) }, serializeArray: function () { return this.map((function () { var e = M.prop(this, "elements"); return e ? M.makeArray(e) : this })).filter((function () { var e = this.type; return this.name && !M(this).is(":disabled") && Ut.test(this.nodeName) && !Ft.test(e) && (this.checked || !Me.test(e)) })).map((function (e, t) { var n = M(this).val(); return null == n ? null : Array.isArray(n) ? M.map(n, (function (e) { return { name: t.name, value: e.replace(Ot, "\r\n") } })) : { name: t.name, value: n.replace(Ot, "\r\n") } })).get() } }); var kt = /%20/g, zt = /#.*$/, Ht = /([?&])_=[^&]*/, Gt = /^(.*?):[ \t]*([^\r\n]*)$/gm, Vt = /^(?:GET|HEAD)$/, Wt = /^\/\//, jt = {}, Xt = {}, qt = "*/".concat("*"), Yt = y.createElement("a"); function Kt(e) { return function (t, n) { "string" != typeof t && (n = t, t = "*"); var i, r = 0, s = t.toLowerCase().match(q) || []; if (v(n)) for (; i = s[r++];)"+" === i[0] ? (i = i.slice(1) || "*", (e[i] = e[i] || []).unshift(n)) : (e[i] = e[i] || []).push(n) } } function $t(e, t, n, i) { var r = {}, s = e === Xt; function a(o) { var l; return r[o] = !0, M.each(e[o] || [], (function (e, o) { var c = o(t, n, i); return "string" != typeof c || s || r[c] ? s ? !(l = c) : void 0 : (t.dataTypes.unshift(c), a(c), !1) })), l } return a(t.dataTypes[0]) || !r["*"] && a("*") } function Zt(e, t) { var n, i, r = M.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((r[n] ? e : i || (i = {}))[n] = t[n]); return i && M.extend(!0, e, i), e } Yt.href = Ct.href, M.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: Ct.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Ct.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": qt, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": M.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? Zt(Zt(e, M.ajaxSettings), t) : Zt(M.ajaxSettings, e) }, ajaxPrefilter: Kt(jt), ajaxTransport: Kt(Xt), ajax: function (e, t) { "object" == typeof e && (t = e, e = void 0), t = t || {}; var n, r, s, a, o, l, c, u, h, d, p = M.ajaxSetup({}, t), f = p.context || p, m = p.context && (f.nodeType || f.jquery) ? M(f) : M.event, g = M.Deferred(), v = M.Callbacks("once memory"), _ = p.statusCode || {}, x = {}, b = {}, E = "canceled", T = { readyState: 0, getResponseHeader: function (e) { var t; if (c) { if (!a) for (a = {}; t = Gt.exec(s);)a[t[1].toLowerCase() + " "] = (a[t[1].toLowerCase() + " "] || []).concat(t[2]); t = a[e.toLowerCase() + " "] } return null == t ? null : t.join(", ") }, getAllResponseHeaders: function () { return c ? s : null }, setRequestHeader: function (e, t) { return null == c && (e = b[e.toLowerCase()] = b[e.toLowerCase()] || e, x[e] = t), this }, overrideMimeType: function (e) { return null == c && (p.mimeType = e), this }, statusCode: function (e) { var t; if (e) if (c) T.always(e[T.status]); else for (t in e) _[t] = [_[t], e[t]]; return this }, abort: function (e) { var t = e || E; return n && n.abort(t), S(0, t), this } }; if (g.promise(T), p.url = ((e || p.url || Ct.href) + "").replace(Wt, Ct.protocol + "//"), p.type = t.method || t.type || p.method || p.type, p.dataTypes = (p.dataType || "*").toLowerCase().match(q) || [""], null == p.crossDomain) { l = y.createElement("a"); try { l.href = p.url, l.href = l.href, p.crossDomain = Yt.protocol + "//" + Yt.host != l.protocol + "//" + l.host } catch (e) { p.crossDomain = !0 } } if (p.data && p.processData && "string" != typeof p.data && (p.data = M.param(p.data, p.traditional)), $t(jt, p, t, T), c) return T; for (h in (u = M.event && p.global) && 0 == M.active++ && M.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Vt.test(p.type), r = p.url.replace(zt, ""), p.hasContent ? p.data && p.processData && 0 === (p.contentType || "").indexOf("application/x-www-form-urlencoded") && (p.data = p.data.replace(kt, "+")) : (d = p.url.slice(r.length), p.data && (p.processData || "string" == typeof p.data) && (r += (Lt.test(r) ? "&" : "?") + p.data, delete p.data), !1 === p.cache && (r = r.replace(Ht, "$1"), d = (Lt.test(r) ? "&" : "?") + "_=" + Rt.guid++ + d), p.url = r + d), p.ifModified && (M.lastModified[r] && T.setRequestHeader("If-Modified-Since", M.lastModified[r]), M.etag[r] && T.setRequestHeader("If-None-Match", M.etag[r])), (p.data && p.hasContent && !1 !== p.contentType || t.contentType) && T.setRequestHeader("Content-Type", p.contentType), T.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + qt + "; q=0.01" : "") : p.accepts["*"]), p.headers) T.setRequestHeader(h, p.headers[h]); if (p.beforeSend && (!1 === p.beforeSend.call(f, T, p) || c)) return T.abort(); if (E = "abort", v.add(p.complete), T.done(p.success), T.fail(p.error), n = $t(Xt, p, t, T)) { if (T.readyState = 1, u && m.trigger("ajaxSend", [T, p]), c) return T; p.async && p.timeout > 0 && (o = i.setTimeout((function () { T.abort("timeout") }), p.timeout)); try { c = !1, n.send(x, S) } catch (e) { if (c) throw e; S(-1, e) } } else S(-1, "No Transport"); function S(e, t, a, l) { var h, d, y, x, b, E = t; c || (c = !0, o && i.clearTimeout(o), n = void 0, s = l || "", T.readyState = e > 0 ? 4 : 0, h = e >= 200 && e < 300 || 304 === e, a && (x = function (e, t, n) { for (var i, r, s, a, o = e.contents, l = e.dataTypes; "*" === l[0];)l.shift(), void 0 === i && (i = e.mimeType || t.getResponseHeader("Content-Type")); if (i) for (r in o) if (o[r] && o[r].test(i)) { l.unshift(r); break } if (l[0] in n) s = l[0]; else { for (r in n) { if (!l[0] || e.converters[r + " " + l[0]]) { s = r; break } a || (a = r) } s = s || a } if (s) return s !== l[0] && l.unshift(s), n[s] }(p, T, a)), !h && M.inArray("script", p.dataTypes) > -1 && M.inArray("json", p.dataTypes) < 0 && (p.converters["text script"] = function () { }), x = function (e, t, n, i) { var r, s, a, o, l, c = {}, u = e.dataTypes.slice(); if (u[1]) for (a in e.converters) c[a.toLowerCase()] = e.converters[a]; for (s = u.shift(); s;)if (e.responseFields[s] && (n[e.responseFields[s]] = t), !l && i && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = s, s = u.shift()) if ("*" === s) s = l; else if ("*" !== l && l !== s) { if (!(a = c[l + " " + s] || c["* " + s])) for (r in c) if ((o = r.split(" "))[1] === s && (a = c[l + " " + o[0]] || c["* " + o[0]])) { !0 === a ? a = c[r] : !0 !== c[r] && (s = o[0], u.unshift(o[1])); break } if (!0 !== a) if (a && e.throws) t = a(t); else try { t = a(t) } catch (e) { return { state: "parsererror", error: a ? e : "No conversion from " + l + " to " + s } } } return { state: "success", data: t } }(p, x, T, h), h ? (p.ifModified && ((b = T.getResponseHeader("Last-Modified")) && (M.lastModified[r] = b), (b = T.getResponseHeader("etag")) && (M.etag[r] = b)), 204 === e || "HEAD" === p.type ? E = "nocontent" : 304 === e ? E = "notmodified" : (E = x.state, d = x.data, h = !(y = x.error))) : (y = E, !e && E || (E = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || E) + "", h ? g.resolveWith(f, [d, E, T]) : g.rejectWith(f, [T, E, y]), T.statusCode(_), _ = void 0, u && m.trigger(h ? "ajaxSuccess" : "ajaxError", [T, p, h ? d : y]), v.fireWith(f, [T, E]), u && (m.trigger("ajaxComplete", [T, p]), --M.active || M.event.trigger("ajaxStop"))) } return T }, getJSON: function (e, t, n) { return M.get(e, t, n, "json") }, getScript: function (e, t) { return M.get(e, void 0, t, "script") } }), M.each(["get", "post"], (function (e, t) { M[t] = function (e, n, i, r) { return v(n) && (r = r || i, i = n, n = void 0), M.ajax(M.extend({ url: e, type: t, dataType: r, data: n, success: i }, M.isPlainObject(e) && e)) } })), M.ajaxPrefilter((function (e) { var t; for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "") })), M._evalUrl = function (e, t, n) { return M.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, converters: { "text script": function () { } }, dataFilter: function (e) { M.globalEval(e, t, n) } }) }, M.fn.extend({ wrapAll: function (e) { var t; return this[0] && (v(e) && (e = e.call(this[0])), t = M(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map((function () { for (var e = this; e.firstElementChild;)e = e.firstElementChild; return e })).append(this)), this }, wrapInner: function (e) { return v(e) ? this.each((function (t) { M(this).wrapInner(e.call(this, t)) })) : this.each((function () { var t = M(this), n = t.contents(); n.length ? n.wrapAll(e) : t.append(e) })) }, wrap: function (e) { var t = v(e); return this.each((function (n) { M(this).wrapAll(t ? e.call(this, n) : e) })) }, unwrap: function (e) { return this.parent(e).not("body").each((function () { M(this).replaceWith(this.childNodes) })), this } }), M.expr.pseudos.hidden = function (e) { return !M.expr.pseudos.visible(e) }, M.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, M.ajaxSettings.xhr = function () { try { return new i.XMLHttpRequest } catch (e) { } }; var Jt = { 0: 200, 1223: 204 }, Qt = M.ajaxSettings.xhr(); g.cors = !!Qt && "withCredentials" in Qt, g.ajax = Qt = !!Qt, M.ajaxTransport((function (e) { var t, n; if (g.cors || Qt && !e.crossDomain) return { send: function (r, s) { var a, o = e.xhr(); if (o.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields) for (a in e.xhrFields) o[a] = e.xhrFields[a]; for (a in e.mimeType && o.overrideMimeType && o.overrideMimeType(e.mimeType), e.crossDomain || r["X-Requested-With"] || (r["X-Requested-With"] = "XMLHttpRequest"), r) o.setRequestHeader(a, r[a]); t = function (e) { return function () { t && (t = n = o.onload = o.onerror = o.onabort = o.ontimeout = o.onreadystatechange = null, "abort" === e ? o.abort() : "error" === e ? "number" != typeof o.status ? s(0, "error") : s(o.status, o.statusText) : s(Jt[o.status] || o.status, o.statusText, "text" !== (o.responseType || "text") || "string" != typeof o.responseText ? { binary: o.response } : { text: o.responseText }, o.getAllResponseHeaders())) } }, o.onload = t(), n = o.onerror = o.ontimeout = t("error"), void 0 !== o.onabort ? o.onabort = n : o.onreadystatechange = function () { 4 === o.readyState && i.setTimeout((function () { t && n() })) }, t = t("abort"); try { o.send(e.hasContent && e.data || null) } catch (e) { if (t) throw e } }, abort: function () { t && t() } } })), M.ajaxPrefilter((function (e) { e.crossDomain && (e.contents.script = !1) })), M.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (e) { return M.globalEval(e), e } } }), M.ajaxPrefilter("script", (function (e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET") })), M.ajaxTransport("script", (function (e) { var t, n; if (e.crossDomain || e.scriptAttrs) return { send: function (i, r) { t = M("<script>").attr(e.scriptAttrs || {}).prop({ charset: e.scriptCharset, src: e.url }).on("load error", n = function (e) { t.remove(), n = null, e && r("error" === e.type ? 404 : 200, e.type) }), y.head.appendChild(t[0]) }, abort: function () { n && n() } } })); var en, tn = [], nn = /(=)\?(?=&|$)|\?\?/; M.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var e = tn.pop() || M.expando + "_" + Rt.guid++; return this[e] = !0, e } }), M.ajaxPrefilter("json jsonp", (function (e, t, n) { var r, s, a, o = !1 !== e.jsonp && (nn.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && nn.test(e.data) && "data"); if (o || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = v(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, o ? e[o] = e[o].replace(nn, "$1" + r) : !1 !== e.jsonp && (e.url += (Lt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () { return a || M.error(r + " was not called"), a[0] }, e.dataTypes[0] = "json", s = i[r], i[r] = function () { a = arguments }, n.always((function () { void 0 === s ? M(i).removeProp(r) : i[r] = s, e[r] && (e.jsonpCallback = t.jsonpCallback, tn.push(r)), a && v(s) && s(a[0]), a = s = void 0 })), "script" })), g.createHTMLDocument = ((en = y.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === en.childNodes.length), M.parseHTML = function (e, t, n) { return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (g.createHTMLDocument ? ((i = (t = y.implementation.createHTMLDocument("")).createElement("base")).href = y.location.href, t.head.appendChild(i)) : t = y), s = !n && [], (r = z.exec(e)) ? [t.createElement(r[1])] : (r = Pe([e], t, s), s && s.length && M(s).remove(), M.merge([], r.childNodes))); var i, r, s }, M.fn.load = function (e, t, n) { var i, r, s, a = this, o = e.indexOf(" "); return o > -1 && (i = Mt(e.slice(o)), e = e.slice(0, o)), v(t) ? (n = t, t = void 0) : t && "object" == typeof t && (r = "POST"), a.length > 0 && M.ajax({ url: e, type: r || "GET", dataType: "html", data: t }).done((function (e) { s = arguments, a.html(i ? M("<div>").append(M.parseHTML(e)).find(i) : e) })).always(n && function (e, t) { a.each((function () { n.apply(this, s || [e.responseText, t, e]) })) }), this }, M.expr.pseudos.animated = function (e) { return M.grep(M.timers, (function (t) { return e === t.elem })).length }, M.offset = { setOffset: function (e, t, n) { var i, r, s, a, o, l, c = M.css(e, "position"), u = M(e), h = {}; "static" === c && (e.style.position = "relative"), o = u.offset(), s = M.css(e, "top"), l = M.css(e, "left"), ("absolute" === c || "fixed" === c) && (s + l).indexOf("auto") > -1 ? (a = (i = u.position()).top, r = i.left) : (a = parseFloat(s) || 0, r = parseFloat(l) || 0), v(t) && (t = t.call(e, n, M.extend({}, o))), null != t.top && (h.top = t.top - o.top + a), null != t.left && (h.left = t.left - o.left + r), "using" in t ? t.using.call(e, h) : u.css(h) } }, M.fn.extend({ offset: function (e) { if (arguments.length) return void 0 === e ? this : this.each((function (t) { M.offset.setOffset(this, e, t) })); var t, n, i = this[0]; return i ? i.getClientRects().length ? (t = i.getBoundingClientRect(), n = i.ownerDocument.defaultView, { top: t.top + n.pageYOffset, left: t.left + n.pageXOffset }) : { top: 0, left: 0 } : void 0 }, position: function () { if (this[0]) { var e, t, n, i = this[0], r = { top: 0, left: 0 }; if ("fixed" === M.css(i, "position")) t = i.getBoundingClientRect(); else { for (t = this.offset(), n = i.ownerDocument, e = i.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && "static" === M.css(e, "position");)e = e.parentNode; e && e !== i && 1 === e.nodeType && ((r = M(e).offset()).top += M.css(e, "borderTopWidth", !0), r.left += M.css(e, "borderLeftWidth", !0)) } return { top: t.top - r.top - M.css(i, "marginTop", !0), left: t.left - r.left - M.css(i, "marginLeft", !0) } } }, offsetParent: function () { return this.map((function () { for (var e = this.offsetParent; e && "static" === M.css(e, "position");)e = e.offsetParent; return e || me })) } }), M.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, (function (e, t) { var n = "pageYOffset" === t; M.fn[e] = function (i) { return ee(this, (function (e, i, r) { var s; if (_(e) ? s = e : 9 === e.nodeType && (s = e.defaultView), void 0 === r) return s ? s[t] : e[i]; s ? s.scrollTo(n ? s.pageXOffset : r, n ? r : s.pageYOffset) : e[i] = r }), e, i, arguments.length) } })), M.each(["top", "left"], (function (e, t) { M.cssHooks[t] = et(g.pixelPosition, (function (e, n) { if (n) return n = Qe(e, t), Ye.test(n) ? M(e).position()[t] + "px" : n })) })), M.each({ Height: "height", Width: "width" }, (function (e, t) { M.each({ padding: "inner" + e, content: t, "": "outer" + e }, (function (n, i) { M.fn[i] = function (r, s) { var a = arguments.length && (n || "boolean" != typeof r), o = n || (!0 === r || !0 === s ? "margin" : "border"); return ee(this, (function (t, n, r) { var s; return _(t) ? 0 === i.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (s = t.documentElement, Math.max(t.body["scroll" + e], s["scroll" + e], t.body["offset" + e], s["offset" + e], s["client" + e])) : void 0 === r ? M.css(t, n, o) : M.style(t, n, r, o) }), t, a ? r : void 0, a) } })) })), M.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], (function (e, t) { M.fn[t] = function (e) { return this.on(t, e) } })), M.fn.extend({ bind: function (e, t, n) { return this.on(e, null, t, n) }, unbind: function (e, t) { return this.off(e, null, t) }, delegate: function (e, t, n, i) { return this.on(t, e, n, i) }, undelegate: function (e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) }, hover: function (e, t) { return this.mouseenter(e).mouseleave(t || e) } }), M.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function (e, t) { M.fn[t] = function (e, n) { return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t) } })); var rn = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g; M.proxy = function (e, t) { var n, i, r; if ("string" == typeof t && (n = e[t], t = e, e = n), v(e)) return i = o.call(arguments, 2), r = function () { return e.apply(t || this, i.concat(o.call(arguments))) }, r.guid = e.guid = e.guid || M.guid++, r }, M.holdReady = function (e) { e ? M.readyWait++ : M.ready(!0) }, M.isArray = Array.isArray, M.parseJSON = JSON.parse, M.nodeName = A, M.isFunction = v, M.isWindow = _, M.camelCase = re, M.type = E, M.now = Date.now, M.isNumeric = function (e) { var t = M.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)) }, M.trim = function (e) { return null == e ? "" : (e + "").replace(rn, "$1") }, void 0 === (n = function () { return M }.apply(t, [])) || (e.exports = n); var sn = i.jQuery, an = i.$; return M.noConflict = function (e) { return i.$ === M && (i.$ = an), e && i.jQuery === M && (i.jQuery = sn), M }, void 0 === r && (i.jQuery = i.$ = M), M })) } }, t = {}; function n(i) { var r = t[i]; if (void 0 !== r) return r.exports; var s = t[i] = { exports: {} }; return e[i].call(s.exports, s, s.exports, n), s.exports } n.d = (e, t) => { for (var i in t) n.o(t, i) && !n.o(e, i) && Object.defineProperty(e, i, { enumerable: !0, get: t[i] }) }, n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, (() => { "use strict"; var e = {}; function t(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function i(e = {}, n = {}) { Object.keys(n).forEach((r => { void 0 === e[r] ? e[r] = n[r] : t(n[r]) && t(e[r]) && Object.keys(n[r]).length > 0 && i(e[r], n[r]) })) } n.r(e), n.d(e, { AJAX_TYPE_FILTER: () => Gx, AJAX_TYPE_LOAD_MORE: () => Vx, AJAX_TYPE_PAGINATE: () => Wx, FOCUSABLE_ELEMENTS: () => Hx, clamp: () => Bx, debounce: () => Cx, delegateEventListener: () => wx, deleteCookie: () => Fx, dispachEvent: () => Mx, dump: () => Sx, exist: () => Dx, getCookie: () => Nx, getLang: () => bx, hoverEnabled: () => Ex, isDefined: () => Ax, lazyLoader: () => Ux, lockScroll: () => Px, motionEnabled: () => Tx, overlays: () => zx, randomIntBetween: () => kx, setCookie: () => Ox, unlockScroll: () => Ix, updateURL: () => Rx }); const r = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function s() { const e = "undefined" != typeof document ? document : {}; return i(e, r), e } const a = { document: r, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } }; function o() { const e = "undefined" != typeof window ? window : {}; return i(e, a), e } function l(e, t = 0) { return setTimeout(e, t) } function c() { return Date.now() } function u(e, t = "x") { const n = o(); let i, r, s; const a = function (e) { const t = o(); let n; return t.getComputedStyle && (n = t.getComputedStyle(e, null)), !n && e.currentStyle && (n = e.currentStyle), n || (n = e.style), n }(e); return n.WebKitCSSMatrix ? (r = a.transform || a.webkitTransform, r.split(",").length > 6 && (r = r.split(", ").map((e => e.replace(",", "."))).join(", ")), s = new n.WebKitCSSMatrix("none" === r ? "" : r)) : (s = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = s.toString().split(",")), "x" === t && (r = n.WebKitCSSMatrix ? s.m41 : 16 === i.length ? parseFloat(i[12]) : parseFloat(i[4])), "y" === t && (r = n.WebKitCSSMatrix ? s.m42 : 16 === i.length ? parseFloat(i[13]) : parseFloat(i[5])), r || 0 } function h(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function d(...e) { const t = Object(e[0]), n = ["__proto__", "constructor", "prototype"]; for (let r = 1; r < e.length; r += 1) { const s = e[r]; if (null != s && (i = s, !("undefined" != typeof window && void 0 !== window.HTMLElement ? i instanceof HTMLElement : i && (1 === i.nodeType || 11 === i.nodeType)))) { const e = Object.keys(Object(s)).filter((e => n.indexOf(e) < 0)); for (let n = 0, i = e.length; n < i; n += 1) { const i = e[n], r = Object.getOwnPropertyDescriptor(s, i); void 0 !== r && r.enumerable && (h(t[i]) && h(s[i]) ? s[i].__swiper__ ? t[i] = s[i] : d(t[i], s[i]) : !h(t[i]) && h(s[i]) ? (t[i] = {}, s[i].__swiper__ ? t[i] = s[i] : d(t[i], s[i])) : t[i] = s[i]) } } } var i; return t } function p(e, t, n) { e.style.setProperty(t, n) } function f({ swiper: e, targetPosition: t, side: n }) { const i = o(), r = -e.translate; let s, a = null; const l = e.params.speed; e.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(e.cssModeFrameID); const c = t > r ? "next" : "prev", u = (e, t) => "next" === c && e >= t || "prev" === c && e <= t, h = () => { s = (new Date).getTime(), null === a && (a = s); const o = Math.max(Math.min((s - a) / l, 1), 0), c = .5 - Math.cos(o * Math.PI) / 2; let d = r + c * (t - r); if (u(d, t) && (d = t), e.wrapperEl.scrollTo({ [n]: d }), u(d, t)) return e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout((() => { e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({ [n]: d }) })), void i.cancelAnimationFrame(e.cssModeFrameID); e.cssModeFrameID = i.requestAnimationFrame(h) }; h() } function m(e, t = "") { return [...e.children].filter((e => e.matches(t))) } function g(e, t = []) { const n = document.createElement(e); return n.classList.add(...Array.isArray(t) ? t : [t]), n } function v(e, t) { return o().getComputedStyle(e, null).getPropertyValue(t) } function _(e) { let t, n = e; if (n) { for (t = 0; null !== (n = n.previousSibling);)1 === n.nodeType && (t += 1); return t } } function y(e, t, n) { const i = o(); return n ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(i.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(i.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth } let x, b, E; function T() { return x || (x = function () { const e = o(), t = s(); return { smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch) } }()), x } function S(e = {}) { return b || (b = function ({ userAgent: e } = {}) { const t = T(), n = o(), i = n.navigator.platform, r = e || n.navigator.userAgent, s = { ios: !1, android: !1 }, a = n.screen.width, l = n.screen.height, c = r.match(/(Android);?[\s\/]+([\d.]+)?/); let u = r.match(/(iPad).*OS\s([\d_]+)/); const h = r.match(/(iPod)(.*OS\s([\d_]+))?/), d = !u && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/), p = "Win32" === i; let f = "MacIntel" === i; return !u && f && t.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${a}x${l}`) >= 0 && (u = r.match(/(Version)\/([\d.]+)/), u || (u = [0, 1, "13_0_0"]), f = !1), c && !p && (s.os = "android", s.android = !0), (u || d || h) && (s.os = "ios", s.ios = !0), s }(e)), b } function M() { return E || (E = function () { const e = o(); let t = !1; function n() { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0 } if (n()) { const n = String(e.navigator.userAgent); if (n.includes("Version/")) { const [e, i] = n.split("Version/")[1].split(" ")[0].split(".").map((e => Number(e))); t = e < 16 || 16 === e && i < 2 } } return { isSafari: t || n(), needPerspectiveFix: t, isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } }()), E } const w = { on(e, t, n) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" != typeof t) return i; const r = n ? "unshift" : "push"; return e.split(" ").forEach((e => { i.eventsListeners[e] || (i.eventsListeners[e] = []), i.eventsListeners[e][r](t) })), i }, once(e, t, n) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" != typeof t) return i; function r(...n) { i.off(e, r), r.__emitterProxy && delete r.__emitterProxy, t.apply(i, n) } return r.__emitterProxy = t, i.on(e, r, n) }, onAny(e, t) { const n = this; if (!n.eventsListeners || n.destroyed) return n; if ("function" != typeof e) return n; const i = t ? "unshift" : "push"; return n.eventsAnyListeners.indexOf(e) < 0 && n.eventsAnyListeners[i](e), n }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const n = t.eventsAnyListeners.indexOf(e); return n >= 0 && t.eventsAnyListeners.splice(n, 1), t }, off(e, t) { const n = this; return !n.eventsListeners || n.destroyed ? n : n.eventsListeners ? (e.split(" ").forEach((e => { void 0 === t ? n.eventsListeners[e] = [] : n.eventsListeners[e] && n.eventsListeners[e].forEach(((i, r) => { (i === t || i.__emitterProxy && i.__emitterProxy === t) && n.eventsListeners[e].splice(r, 1) })) })), n) : n }, emit(...e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsListeners) return t; let n, i, r; "string" == typeof e[0] || Array.isArray(e[0]) ? (n = e[0], i = e.slice(1, e.length), r = t) : (n = e[0].events, i = e[0].data, r = e[0].context || t), i.unshift(r); return (Array.isArray(n) ? n : n.split(" ")).forEach((e => { t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach((t => { t.apply(r, [e, ...i]) })), t.eventsListeners && t.eventsListeners[e] && t.eventsListeners[e].forEach((e => { e.apply(r, i) })) })), t } }; const A = (e, t) => { if (!e || e.destroyed || !e.params) return; const n = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`); if (n) { const t = n.querySelector(`.${e.params.lazyPreloaderClass}`); t && t.remove() } }, D = (e, t) => { if (!e.slides[t]) return; const n = e.slides[t].querySelector('[loading="lazy"]'); n && n.removeAttribute("loading") }, C = e => { if (!e || e.destroyed || !e.params) return; let t = e.params.lazyPreloadPrevNext; const n = e.slides.length; if (!n || !t || t < 0) return; t = Math.min(t, n); const i = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView), r = e.activeIndex, s = r + i - 1; if (e.params.rewind) for (let i = r - t; i <= s + t; i += 1) { const t = (i % n + n) % n; t !== r && t > s && D(e, t) } else for (let i = Math.max(s - t, 0); i <= Math.min(s + t, n - 1); i += 1)i !== r && i > s && D(e, i) }; const R = { updateSize: function () { const e = this; let t, n; const i = e.el; t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : i.clientWidth, n = void 0 !== e.params.height && null !== e.params.height ? e.params.height : i.clientHeight, 0 === t && e.isHorizontal() || 0 === n && e.isVertical() || (t = t - parseInt(v(i, "padding-left") || 0, 10) - parseInt(v(i, "padding-right") || 0, 10), n = n - parseInt(v(i, "padding-top") || 0, 10) - parseInt(v(i, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(n) && (n = 0), Object.assign(e, { width: t, height: n, size: e.isHorizontal() ? t : n })) }, updateSlides: function () { const e = this; function t(t) { return e.isHorizontal() ? t : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[t] } function n(e, n) { return parseFloat(e.getPropertyValue(t(n)) || 0) } const i = e.params, { wrapperEl: r, slidesEl: s, size: a, rtlTranslate: o, wrongRTL: l } = e, c = e.virtual && i.virtual.enabled, u = c ? e.virtual.slides.length : e.slides.length, h = m(s, `.${e.params.slideClass}, swiper-slide`), d = c ? e.virtual.slides.length : h.length; let f = []; const g = [], _ = []; let x = i.slidesOffsetBefore; "function" == typeof x && (x = i.slidesOffsetBefore.call(e)); let b = i.slidesOffsetAfter; "function" == typeof b && (b = i.slidesOffsetAfter.call(e)); const E = e.snapGrid.length, T = e.slidesGrid.length; let S = i.spaceBetween, M = -x, w = 0, A = 0; if (void 0 === a) return; "string" == typeof S && S.indexOf("%") >= 0 ? S = parseFloat(S.replace("%", "")) / 100 * a : "string" == typeof S && (S = parseFloat(S)), e.virtualSize = -S, h.forEach((e => { o ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = "" })), i.centeredSlides && i.cssMode && (p(r, "--swiper-centered-offset-before", ""), p(r, "--swiper-centered-offset-after", "")); const D = i.grid && i.grid.rows > 1 && e.grid; let C; D && e.grid.initSlides(d); const R = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter((e => void 0 !== i.breakpoints[e].slidesPerView)).length > 0; for (let r = 0; r < d; r += 1) { let s; if (C = 0, h[r] && (s = h[r]), D && e.grid.updateSlide(r, s, d, t), !h[r] || "none" !== v(s, "display")) { if ("auto" === i.slidesPerView) { R && (h[r].style[t("width")] = ""); const a = getComputedStyle(s), o = s.style.transform, l = s.style.webkitTransform; if (o && (s.style.transform = "none"), l && (s.style.webkitTransform = "none"), i.roundLengths) C = e.isHorizontal() ? y(s, "width", !0) : y(s, "height", !0); else { const e = n(a, "width"), t = n(a, "padding-left"), i = n(a, "padding-right"), r = n(a, "margin-left"), o = n(a, "margin-right"), l = a.getPropertyValue("box-sizing"); if (l && "border-box" === l) C = e + r + o; else { const { clientWidth: n, offsetWidth: a } = s; C = e + t + i + r + o + (a - n) } } o && (s.style.transform = o), l && (s.style.webkitTransform = l), i.roundLengths && (C = Math.floor(C)) } else C = (a - (i.slidesPerView - 1) * S) / i.slidesPerView, i.roundLengths && (C = Math.floor(C)), h[r] && (h[r].style[t("width")] = `${C}px`); h[r] && (h[r].swiperSlideSize = C), _.push(C), i.centeredSlides ? (M = M + C / 2 + w / 2 + S, 0 === w && 0 !== r && (M = M - a / 2 - S), 0 === r && (M = M - a / 2 - S), Math.abs(M) < .001 && (M = 0), i.roundLengths && (M = Math.floor(M)), A % i.slidesPerGroup == 0 && f.push(M), g.push(M)) : (i.roundLengths && (M = Math.floor(M)), (A - Math.min(e.params.slidesPerGroupSkip, A)) % e.params.slidesPerGroup == 0 && f.push(M), g.push(M), M = M + C + S), e.virtualSize += C + S, w = C, A += 1 } } if (e.virtualSize = Math.max(e.virtualSize, a) + b, o && l && ("slide" === i.effect || "coverflow" === i.effect) && (r.style.width = `${e.virtualSize + S}px`), i.setWrapperSize && (r.style[t("width")] = `${e.virtualSize + S}px`), D && e.grid.updateWrapperSize(C, f, t), !i.centeredSlides) { const t = []; for (let n = 0; n < f.length; n += 1) { let r = f[n]; i.roundLengths && (r = Math.floor(r)), f[n] <= e.virtualSize - a && t.push(r) } f = t, Math.floor(e.virtualSize - a) - Math.floor(f[f.length - 1]) > 1 && f.push(e.virtualSize - a) } if (c && i.loop) { const t = _[0] + S; if (i.slidesPerGroup > 1) { const n = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / i.slidesPerGroup), r = t * i.slidesPerGroup; for (let e = 0; e < n; e += 1)f.push(f[f.length - 1] + r) } for (let n = 0; n < e.virtual.slidesBefore + e.virtual.slidesAfter; n += 1)1 === i.slidesPerGroup && f.push(f[f.length - 1] + t), g.push(g[g.length - 1] + t), e.virtualSize += t } if (0 === f.length && (f = [0]), 0 !== S) { const n = e.isHorizontal() && o ? "marginLeft" : t("marginRight"); h.filter(((e, t) => !(i.cssMode && !i.loop) || t !== h.length - 1)).forEach((e => { e.style[n] = `${S}px` })) } if (i.centeredSlides && i.centeredSlidesBounds) { let e = 0; _.forEach((t => { e += t + (S || 0) })), e -= S; const t = e - a; f = f.map((e => e < 0 ? -x : e > t ? t + b : e)) } if (i.centerInsufficientSlides) { let e = 0; if (_.forEach((t => { e += t + (S || 0) })), e -= S, e < a) { const t = (a - e) / 2; f.forEach(((e, n) => { f[n] = e - t })), g.forEach(((e, n) => { g[n] = e + t })) } } if (Object.assign(e, { slides: h, snapGrid: f, slidesGrid: g, slidesSizesGrid: _ }), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) { p(r, "--swiper-centered-offset-before", -f[0] + "px"), p(r, "--swiper-centered-offset-after", e.size / 2 - _[_.length - 1] / 2 + "px"); const t = -e.snapGrid[0], n = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + n)) } if (d !== u && e.emit("slidesLengthChange"), f.length !== E && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), g.length !== T && e.emit("slidesGridLengthChange"), i.watchSlidesProgress && e.updateSlidesOffset(), !(c || i.cssMode || "slide" !== i.effect && "fade" !== i.effect)) { const t = `${i.containerModifierClass}backface-hidden`, n = e.el.classList.contains(t); d <= i.maxBackfaceHiddenSlides ? n || e.el.classList.add(t) : n && e.el.classList.remove(t) } }, updateAutoHeight: function (e) { const t = this, n = [], i = t.virtual && t.params.virtual.enabled; let r, s = 0; "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const a = e => i ? t.slides[t.getSlideIndexByData(e)] : t.slides[e]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || []).forEach((e => { n.push(e) })); else for (r = 0; r < Math.ceil(t.params.slidesPerView); r += 1) { const e = t.activeIndex + r; if (e > t.slides.length && !i) break; n.push(a(e)) } else n.push(a(t.activeIndex)); for (r = 0; r < n.length; r += 1)if (void 0 !== n[r]) { const e = n[r].offsetHeight; s = e > s ? e : s } (s || 0 === s) && (t.wrapperEl.style.height = `${s}px`) }, updateSlidesOffset: function () { const e = this, t = e.slides, n = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0; for (let i = 0; i < t.length; i += 1)t[i].swiperSlideOffset = (e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop) - n - e.cssOverflowAdjustment() }, updateSlidesProgress: function (e = this && this.translate || 0) { const t = this, n = t.params, { slides: i, rtlTranslate: r, snapGrid: s } = t; if (0 === i.length) return; void 0 === i[0].swiperSlideOffset && t.updateSlidesOffset(); let a = -e; r && (a = e), i.forEach((e => { e.classList.remove(n.slideVisibleClass) })), t.visibleSlidesIndexes = [], t.visibleSlides = []; let o = n.spaceBetween; "string" == typeof o && o.indexOf("%") >= 0 ? o = parseFloat(o.replace("%", "")) / 100 * t.size : "string" == typeof o && (o = parseFloat(o)); for (let e = 0; e < i.length; e += 1) { const l = i[e]; let c = l.swiperSlideOffset; n.cssMode && n.centeredSlides && (c -= i[0].swiperSlideOffset); const u = (a + (n.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + o), h = (a - s[0] + (n.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + o), d = -(a - c), p = d + t.slidesSizesGrid[e]; (d >= 0 && d < t.size - 1 || p > 1 && p <= t.size || d <= 0 && p >= t.size) && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e), i[e].classList.add(n.slideVisibleClass)), l.progress = r ? -u : u, l.originalProgress = r ? -h : h } }, updateProgress: function (e) { const t = this; if (void 0 === e) { const n = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * n || 0 } const n = t.params, i = t.maxTranslate() - t.minTranslate(); let { progress: r, isBeginning: s, isEnd: a, progressLoop: o } = t; const l = s, c = a; if (0 === i) r = 0, s = !0, a = !0; else { r = (e - t.minTranslate()) / i; const n = Math.abs(e - t.minTranslate()) < 1, o = Math.abs(e - t.maxTranslate()) < 1; s = n || r <= 0, a = o || r >= 1, n && (r = 0), o && (r = 1) } if (n.loop) { const n = t.getSlideIndexByData(0), i = t.getSlideIndexByData(t.slides.length - 1), r = t.slidesGrid[n], s = t.slidesGrid[i], a = t.slidesGrid[t.slidesGrid.length - 1], l = Math.abs(e); o = l >= r ? (l - r) / a : (l + a - s) / a, o > 1 && (o -= 1) } Object.assign(t, { progress: r, progressLoop: o, isBeginning: s, isEnd: a }), (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && t.updateSlidesProgress(e), s && !l && t.emit("reachBeginning toEdge"), a && !c && t.emit("reachEnd toEdge"), (l && !s || c && !a) && t.emit("fromEdge"), t.emit("progress", r) }, updateSlidesClasses: function () { const e = this, { slides: t, params: n, slidesEl: i, activeIndex: r } = e, s = e.virtual && n.virtual.enabled, a = e => m(i, `.${n.slideClass}${e}, swiper-slide${e}`)[0]; let o; if (t.forEach((e => { e.classList.remove(n.slideActiveClass, n.slideNextClass, n.slidePrevClass) })), s) if (n.loop) { let t = r - e.virtual.slidesBefore; t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), o = a(`[data-swiper-slide-index="${t}"]`) } else o = a(`[data-swiper-slide-index="${r}"]`); else o = t[r]; if (o) { o.classList.add(n.slideActiveClass); let e = function (e, t) { const n = []; for (; e.nextElementSibling;) { const i = e.nextElementSibling; t ? i.matches(t) && n.push(i) : n.push(i), e = i } return n }(o, `.${n.slideClass}, swiper-slide`)[0]; n.loop && !e && (e = t[0]), e && e.classList.add(n.slideNextClass); let i = function (e, t) { const n = []; for (; e.previousElementSibling;) { const i = e.previousElementSibling; t ? i.matches(t) && n.push(i) : n.push(i), e = i } return n }(o, `.${n.slideClass}, swiper-slide`)[0]; n.loop && 0 === !i && (i = t[t.length - 1]), i && i.classList.add(n.slidePrevClass) } e.emitSlidesClasses() }, updateActiveIndex: function (e) { const t = this, n = t.rtlTranslate ? t.translate : -t.translate, { snapGrid: i, params: r, activeIndex: s, realIndex: a, snapIndex: o } = t; let l, c = e; const u = e => { let n = e - t.virtual.slidesBefore; return n < 0 && (n = t.virtual.slides.length + n), n >= t.virtual.slides.length && (n -= t.virtual.slides.length), n }; if (void 0 === c && (c = function (e) { const { slidesGrid: t, params: n } = e, i = e.rtlTranslate ? e.translate : -e.translate; let r; for (let e = 0; e < t.length; e += 1)void 0 !== t[e + 1] ? i >= t[e] && i < t[e + 1] - (t[e + 1] - t[e]) / 2 ? r = e : i >= t[e] && i < t[e + 1] && (r = e + 1) : i >= t[e] && (r = e); return n.normalizeSlideIndex && (r < 0 || void 0 === r) && (r = 0), r }(t)), i.indexOf(n) >= 0) l = i.indexOf(n); else { const e = Math.min(r.slidesPerGroupSkip, c); l = e + Math.floor((c - e) / r.slidesPerGroup) } if (l >= i.length && (l = i.length - 1), c === s) return l !== o && (t.snapIndex = l, t.emit("snapIndexChange")), void (t.params.loop && t.virtual && t.params.virtual.enabled && (t.realIndex = u(c))); let h; h = t.virtual && r.virtual.enabled && r.loop ? u(c) : t.slides[c] ? parseInt(t.slides[c].getAttribute("data-swiper-slide-index") || c, 10) : c, Object.assign(t, { previousSnapIndex: o, snapIndex: l, previousRealIndex: a, realIndex: h, previousIndex: s, activeIndex: c }), t.initialized && C(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), a !== h && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange") }, updateClickedSlide: function (e) { const t = this, n = t.params, i = e.closest(`.${n.slideClass}, swiper-slide`); let r, s = !1; if (i) for (let e = 0; e < t.slides.length; e += 1)if (t.slides[e] === i) { s = !0, r = e; break } if (!i || !s) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = i, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(i.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = r, n.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }; const L = { getTranslate: function (e = (this.isHorizontal() ? "x" : "y")) { const { params: t, rtlTranslate: n, translate: i, wrapperEl: r } = this; if (t.virtualTranslate) return n ? -i : i; if (t.cssMode) return i; let s = u(r, e); return s += this.cssOverflowAdjustment(), n && (s = -s), s || 0 }, setTranslate: function (e, t) { const n = this, { rtlTranslate: i, params: r, wrapperEl: s, progress: a } = n; let o, l = 0, c = 0; n.isHorizontal() ? l = i ? -e : e : c = e, r.roundLengths && (l = Math.floor(l), c = Math.floor(c)), n.previousTranslate = n.translate, n.translate = n.isHorizontal() ? l : c, r.cssMode ? s[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -l : -c : r.virtualTranslate || (n.isHorizontal() ? l -= n.cssOverflowAdjustment() : c -= n.cssOverflowAdjustment(), s.style.transform = `translate3d(${l}px, ${c}px, 0px)`); const u = n.maxTranslate() - n.minTranslate(); o = 0 === u ? 0 : (e - n.minTranslate()) / u, o !== a && n.updateProgress(e), n.emit("setTranslate", n.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e = 0, t = this.params.speed, n = !0, i = !0, r) { const s = this, { params: a, wrapperEl: o } = s; if (s.animating && a.preventInteractionOnTransition) return !1; const l = s.minTranslate(), c = s.maxTranslate(); let u; if (u = i && e > l ? l : i && e < c ? c : e, s.updateProgress(u), a.cssMode) { const e = s.isHorizontal(); if (0 === t) o[e ? "scrollLeft" : "scrollTop"] = -u; else { if (!s.support.smoothScroll) return f({ swiper: s, targetPosition: -u, side: e ? "left" : "top" }), !0; o.scrollTo({ [e ? "left" : "top"]: -u, behavior: "smooth" }) } return !0 } return 0 === t ? (s.setTransition(0), s.setTranslate(u), n && (s.emit("beforeTransitionStart", t, r), s.emit("transitionEnd"))) : (s.setTransition(t), s.setTranslate(u), n && (s.emit("beforeTransitionStart", t, r), s.emit("transitionStart")), s.animating || (s.animating = !0, s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function (e) { s && !s.destroyed && e.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.onTranslateToWrapperTransitionEnd = null, delete s.onTranslateToWrapperTransitionEnd, n && s.emit("transitionEnd")) }), s.wrapperEl.addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd))), !0 } }; function P({ swiper: e, runCallbacks: t, direction: n, step: i }) { const { activeIndex: r, previousIndex: s } = e; let a = n; if (a || (a = r > s ? "next" : r < s ? "prev" : "reset"), e.emit(`transition${i}`), t && r !== s) { if ("reset" === a) return void e.emit(`slideResetTransition${i}`); e.emit(`slideChangeTransition${i}`), "next" === a ? e.emit(`slideNextTransition${i}`) : e.emit(`slidePrevTransition${i}`) } } const I = { slideTo: function (e = 0, t = this.params.speed, n = !0, i, r) { "string" == typeof e && (e = parseInt(e, 10)); const s = this; let a = e; a < 0 && (a = 0); const { params: o, snapGrid: l, slidesGrid: c, previousIndex: u, activeIndex: h, rtlTranslate: d, wrapperEl: p, enabled: m } = s; if (s.animating && o.preventInteractionOnTransition || !m && !i && !r) return !1; const g = Math.min(s.params.slidesPerGroupSkip, a); let v = g + Math.floor((a - g) / s.params.slidesPerGroup); v >= l.length && (v = l.length - 1); const _ = -l[v]; if (o.normalizeSlideIndex) for (let e = 0; e < c.length; e += 1) { const t = -Math.floor(100 * _), n = Math.floor(100 * c[e]), i = Math.floor(100 * c[e + 1]); void 0 !== c[e + 1] ? t >= n && t < i - (i - n) / 2 ? a = e : t >= n && t < i && (a = e + 1) : t >= n && (a = e) } if (s.initialized && a !== h) { if (!s.allowSlideNext && _ < s.translate && _ < s.minTranslate()) return !1; if (!s.allowSlidePrev && _ > s.translate && _ > s.maxTranslate() && (h || 0) !== a) return !1 } let y; if (a !== (u || 0) && n && s.emit("beforeSlideChangeStart"), s.updateProgress(_), y = a > h ? "next" : a < h ? "prev" : "reset", d && -_ === s.translate || !d && _ === s.translate) return s.updateActiveIndex(a), o.autoHeight && s.updateAutoHeight(), s.updateSlidesClasses(), "slide" !== o.effect && s.setTranslate(_), "reset" !== y && (s.transitionStart(n, y), s.transitionEnd(n, y)), !1; if (o.cssMode) { const e = s.isHorizontal(), n = d ? _ : -_; if (0 === t) { const t = s.virtual && s.params.virtual.enabled; t && (s.wrapperEl.style.scrollSnapType = "none", s._immediateVirtual = !0), t && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0 ? (s._cssModeVirtualInitialSet = !0, requestAnimationFrame((() => { p[e ? "scrollLeft" : "scrollTop"] = n }))) : p[e ? "scrollLeft" : "scrollTop"] = n, t && requestAnimationFrame((() => { s.wrapperEl.style.scrollSnapType = "", s._immediateVirtual = !1 })) } else { if (!s.support.smoothScroll) return f({ swiper: s, targetPosition: n, side: e ? "left" : "top" }), !0; p.scrollTo({ [e ? "left" : "top"]: n, behavior: "smooth" }) } return !0 } return s.setTransition(t), s.setTranslate(_), s.updateActiveIndex(a), s.updateSlidesClasses(), s.emit("beforeTransitionStart", t, i), s.transitionStart(n, y), 0 === t ? s.transitionEnd(n, y) : s.animating || (s.animating = !0, s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function (e) { s && !s.destroyed && e.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.onSlideToWrapperTransitionEnd = null, delete s.onSlideToWrapperTransitionEnd, s.transitionEnd(n, y)) }), s.wrapperEl.addEventListener("transitionend", s.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e = 0, t = this.params.speed, n = !0, i) { if ("string" == typeof e) { e = parseInt(e, 10) } const r = this; let s = e; return r.params.loop && (r.virtual && r.params.virtual.enabled ? s += r.virtual.slidesBefore : s = r.getSlideIndexByData(s)), r.slideTo(s, t, n, i) }, slideNext: function (e = this.params.speed, t = !0, n) { const i = this, { enabled: r, params: s, animating: a } = i; if (!r) return i; let o = s.slidesPerGroup; "auto" === s.slidesPerView && 1 === s.slidesPerGroup && s.slidesPerGroupAuto && (o = Math.max(i.slidesPerViewDynamic("current", !0), 1)); const l = i.activeIndex < s.slidesPerGroupSkip ? 1 : o, c = i.virtual && s.virtual.enabled; if (s.loop) { if (a && !c && s.loopPreventsSliding) return !1; i.loopFix({ direction: "next" }), i._clientLeft = i.wrapperEl.clientLeft } return s.rewind && i.isEnd ? i.slideTo(0, e, t, n) : i.slideTo(i.activeIndex + l, e, t, n) }, slidePrev: function (e = this.params.speed, t = !0, n) { const i = this, { params: r, snapGrid: s, slidesGrid: a, rtlTranslate: o, enabled: l, animating: c } = i; if (!l) return i; const u = i.virtual && r.virtual.enabled; if (r.loop) { if (c && !u && r.loopPreventsSliding) return !1; i.loopFix({ direction: "prev" }), i._clientLeft = i.wrapperEl.clientLeft } function h(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const d = h(o ? i.translate : -i.translate), p = s.map((e => h(e))); let f = s[p.indexOf(d) - 1]; if (void 0 === f && r.cssMode) { let e; s.forEach(((t, n) => { d >= t && (e = n) })), void 0 !== e && (f = s[e > 0 ? e - 1 : e]) } let m = 0; if (void 0 !== f && (m = a.indexOf(f), m < 0 && (m = i.activeIndex - 1), "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (m = m - i.slidesPerViewDynamic("previous", !0) + 1, m = Math.max(m, 0))), r.rewind && i.isBeginning) { const r = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1; return i.slideTo(r, e, t, n) } return i.slideTo(m, e, t, n) }, slideReset: function (e = this.params.speed, t = !0, n) { return this.slideTo(this.activeIndex, e, t, n) }, slideToClosest: function (e = this.params.speed, t = !0, n, i = .5) { const r = this; let s = r.activeIndex; const a = Math.min(r.params.slidesPerGroupSkip, s), o = a + Math.floor((s - a) / r.params.slidesPerGroup), l = r.rtlTranslate ? r.translate : -r.translate; if (l >= r.snapGrid[o]) { const e = r.snapGrid[o]; l - e > (r.snapGrid[o + 1] - e) * i && (s += r.params.slidesPerGroup) } else { const e = r.snapGrid[o - 1]; l - e <= (r.snapGrid[o] - e) * i && (s -= r.params.slidesPerGroup) } return s = Math.max(s, 0), s = Math.min(s, r.slidesGrid.length - 1), r.slideTo(s, e, t, n) }, slideToClickedSlide: function () { const e = this, { params: t, slidesEl: n } = e, i = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let r, s = e.clickedIndex; const a = e.isElement ? "swiper-slide" : `.${t.slideClass}`; if (t.loop) { if (e.animating) return; r = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? s < e.loopedSlides - i / 2 || s > e.slides.length - e.loopedSlides + i / 2 ? (e.loopFix(), s = e.getSlideIndex(m(n, `${a}[data-swiper-slide-index="${r}"]`)[0]), l((() => { e.slideTo(s) }))) : e.slideTo(s) : s > e.slides.length - i ? (e.loopFix(), s = e.getSlideIndex(m(n, `${a}[data-swiper-slide-index="${r}"]`)[0]), l((() => { e.slideTo(s) }))) : e.slideTo(s) } else e.slideTo(s) } }; const N = { loopCreate: function (e) { const t = this, { params: n, slidesEl: i } = t; if (!n.loop || t.virtual && t.params.virtual.enabled) return; m(i, `.${n.slideClass}, swiper-slide`).forEach(((e, t) => { e.setAttribute("data-swiper-slide-index", t) })), t.loopFix({ slideRealIndex: e, direction: n.centeredSlides ? void 0 : "next" }) }, loopFix: function ({ slideRealIndex: e, slideTo: t = !0, direction: n, setTranslate: i, activeSlideIndex: r, byController: s, byMousewheel: a } = {}) { const o = this; if (!o.params.loop) return; o.emit("beforeLoopFix"); const { slides: l, allowSlidePrev: c, allowSlideNext: u, slidesEl: h, params: d } = o; if (o.allowSlidePrev = !0, o.allowSlideNext = !0, o.virtual && d.virtual.enabled) return t && (d.centeredSlides || 0 !== o.snapIndex ? d.centeredSlides && o.snapIndex < d.slidesPerView ? o.slideTo(o.virtual.slides.length + o.snapIndex, 0, !1, !0) : o.snapIndex === o.snapGrid.length - 1 && o.slideTo(o.virtual.slidesBefore, 0, !1, !0) : o.slideTo(o.virtual.slides.length, 0, !1, !0)), o.allowSlidePrev = c, o.allowSlideNext = u, void o.emit("loopFix"); const p = "auto" === d.slidesPerView ? o.slidesPerViewDynamic() : Math.ceil(parseFloat(d.slidesPerView, 10)); let f = d.loopedSlides || p; f % d.slidesPerGroup != 0 && (f += d.slidesPerGroup - f % d.slidesPerGroup), o.loopedSlides = f; const m = [], g = []; let v = o.activeIndex; void 0 === r ? r = o.getSlideIndex(o.slides.filter((e => e.classList.contains(d.slideActiveClass)))[0]) : v = r; const _ = "next" === n || !n, y = "prev" === n || !n; let x = 0, b = 0; if (r < f) { x = Math.max(f - r, d.slidesPerGroup); for (let e = 0; e < f - r; e += 1) { const t = e - Math.floor(e / l.length) * l.length; m.push(l.length - t - 1) } } else if (r > o.slides.length - 2 * f) { b = Math.max(r - (o.slides.length - 2 * f), d.slidesPerGroup); for (let e = 0; e < b; e += 1) { const t = e - Math.floor(e / l.length) * l.length; g.push(t) } } if (y && m.forEach((e => { o.slides[e].swiperLoopMoveDOM = !0, h.prepend(o.slides[e]), o.slides[e].swiperLoopMoveDOM = !1 })), _ && g.forEach((e => { o.slides[e].swiperLoopMoveDOM = !0, h.append(o.slides[e]), o.slides[e].swiperLoopMoveDOM = !1 })), o.recalcSlides(), "auto" === d.slidesPerView && o.updateSlides(), d.watchSlidesProgress && o.updateSlidesOffset(), t) if (m.length > 0 && y) if (void 0 === e) { const e = o.slidesGrid[v], t = o.slidesGrid[v + x] - e; a ? o.setTranslate(o.translate - t) : (o.slideTo(v + x, 0, !1, !0), i && (o.touches[o.isHorizontal() ? "startX" : "startY"] += t)) } else i && o.slideToLoop(e, 0, !1, !0); else if (g.length > 0 && _) if (void 0 === e) { const e = o.slidesGrid[v], t = o.slidesGrid[v - b] - e; a ? o.setTranslate(o.translate - t) : (o.slideTo(v - b, 0, !1, !0), i && (o.touches[o.isHorizontal() ? "startX" : "startY"] += t)) } else o.slideToLoop(e, 0, !1, !0); if (o.allowSlidePrev = c, o.allowSlideNext = u, o.controller && o.controller.control && !s) { const t = { slideRealIndex: e, slideTo: !1, direction: n, setTranslate: i, activeSlideIndex: r, byController: !0 }; Array.isArray(o.controller.control) ? o.controller.control.forEach((e => { !e.destroyed && e.params.loop && e.loopFix(t) })) : o.controller.control instanceof o.constructor && o.controller.control.params.loop && o.controller.control.loopFix(t) } o.emit("loopFix") }, loopDestroy: function () { const e = this, { params: t, slidesEl: n } = e; if (!t.loop || e.virtual && e.params.virtual.enabled) return; e.recalcSlides(); const i = []; e.slides.forEach((e => { const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex; i[t] = e })), e.slides.forEach((e => { e.removeAttribute("data-swiper-slide-index") })), i.forEach((e => { n.append(e) })), e.recalcSlides(), e.slideTo(e.realIndex, 0) } }; function O(e) { const t = this, n = s(), i = o(), r = t.touchEventsData; r.evCache.push(e); const { params: a, touches: l, enabled: u } = t; if (!u) return; if (!a.simulateTouch && "mouse" === e.pointerType) return; if (t.animating && a.preventInteractionOnTransition) return; !t.animating && a.cssMode && a.loop && t.loopFix(); let h = e; h.originalEvent && (h = h.originalEvent); let d = h.target; if ("wrapper" === a.touchEventsTarget && !t.wrapperEl.contains(d)) return; if ("which" in h && 3 === h.which) return; if ("button" in h && h.button > 0) return; if (r.isTouched && r.isMoved) return; const p = !!a.noSwipingClass && "" !== a.noSwipingClass, f = e.composedPath ? e.composedPath() : e.path; p && h.target && h.target.shadowRoot && f && (d = f[0]); const m = a.noSwipingSelector ? a.noSwipingSelector : `.${a.noSwipingClass}`, g = !(!h.target || !h.target.shadowRoot); if (a.noSwiping && (g ? function (e, t = this) { return function t(n) { if (!n || n === s() || n === o()) return null; n.assignedSlot && (n = n.assignedSlot); const i = n.closest(e); return i || n.getRootNode ? i || t(n.getRootNode().host) : null }(t) }(m, d) : d.closest(m))) return void (t.allowClick = !0); if (a.swipeHandler && !d.closest(a.swipeHandler)) return; l.currentX = h.pageX, l.currentY = h.pageY; const v = l.currentX, _ = l.currentY, y = a.edgeSwipeDetection || a.iOSEdgeSwipeDetection, x = a.edgeSwipeThreshold || a.iOSEdgeSwipeThreshold; if (y && (v <= x || v >= i.innerWidth - x)) { if ("prevent" !== y) return; e.preventDefault() } Object.assign(r, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), l.startX = v, l.startY = _, r.touchStartTime = c(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, a.threshold > 0 && (r.allowThresholdMove = !1); let b = !0; d.matches(r.focusableElements) && (b = !1, "SELECT" === d.nodeName && (r.isTouched = !1)), n.activeElement && n.activeElement.matches(r.focusableElements) && n.activeElement !== d && n.activeElement.blur(); const E = b && t.allowTouchMove && a.touchStartPreventDefault; !a.touchStartForcePreventDefault && !E || d.isContentEditable || h.preventDefault(), t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !a.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", h) } function F(e) { const t = s(), n = this, i = n.touchEventsData, { params: r, touches: a, rtlTranslate: o, enabled: l } = n; if (!l) return; if (!r.simulateTouch && "mouse" === e.pointerType) return; let u = e; if (u.originalEvent && (u = u.originalEvent), !i.isTouched) return void (i.startMoving && i.isScrolling && n.emit("touchMoveOpposite", u)); const h = i.evCache.findIndex((e => e.pointerId === u.pointerId)); h >= 0 && (i.evCache[h] = u); const d = i.evCache.length > 1 ? i.evCache[0] : u, p = d.pageX, f = d.pageY; if (u.preventedByNestedSwiper) return a.startX = p, void (a.startY = f); if (!n.allowTouchMove) return u.target.matches(i.focusableElements) || (n.allowClick = !1), void (i.isTouched && (Object.assign(a, { startX: p, startY: f, prevX: n.touches.currentX, prevY: n.touches.currentY, currentX: p, currentY: f }), i.touchStartTime = c())); if (r.touchReleaseOnEdges && !r.loop) if (n.isVertical()) { if (f < a.startY && n.translate <= n.maxTranslate() || f > a.startY && n.translate >= n.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1) } else if (p < a.startX && n.translate <= n.maxTranslate() || p > a.startX && n.translate >= n.minTranslate()) return; if (t.activeElement && u.target === t.activeElement && u.target.matches(i.focusableElements)) return i.isMoved = !0, void (n.allowClick = !1); if (i.allowTouchCallbacks && n.emit("touchMove", u), u.targetTouches && u.targetTouches.length > 1) return; a.currentX = p, a.currentY = f; const m = a.currentX - a.startX, g = a.currentY - a.startY; if (n.params.threshold && Math.sqrt(m ** 2 + g ** 2) < n.params.threshold) return; if (void 0 === i.isScrolling) { let e; n.isHorizontal() && a.currentY === a.startY || n.isVertical() && a.currentX === a.startX ? i.isScrolling = !1 : m * m + g * g >= 25 && (e = 180 * Math.atan2(Math.abs(g), Math.abs(m)) / Math.PI, i.isScrolling = n.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle) } if (i.isScrolling && n.emit("touchMoveOpposite", u), void 0 === i.startMoving && (a.currentX === a.startX && a.currentY === a.startY || (i.startMoving = !0)), i.isScrolling || n.zoom && n.params.zoom && n.params.zoom.enabled && i.evCache.length > 1) return void (i.isTouched = !1); if (!i.startMoving) return; n.allowClick = !1, !r.cssMode && u.cancelable && u.preventDefault(), r.touchMoveStopPropagation && !r.nested && u.stopPropagation(); let v = n.isHorizontal() ? m : g, _ = n.isHorizontal() ? a.currentX - a.previousX : a.currentY - a.previousY; r.oneWayMovement && (v = Math.abs(v) * (o ? 1 : -1), _ = Math.abs(_) * (o ? 1 : -1)), a.diff = v, v *= r.touchRatio, o && (v = -v, _ = -_); const y = n.touchesDirection; n.swipeDirection = v > 0 ? "prev" : "next", n.touchesDirection = _ > 0 ? "prev" : "next"; const x = n.params.loop && !r.cssMode; if (!i.isMoved) { if (x && n.loopFix({ direction: n.swipeDirection }), i.startTranslate = n.getTranslate(), n.setTransition(0), n.animating) { const e = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); n.wrapperEl.dispatchEvent(e) } i.allowMomentumBounce = !1, !r.grabCursor || !0 !== n.allowSlideNext && !0 !== n.allowSlidePrev || n.setGrabCursor(!0), n.emit("sliderFirstMove", u) } let b; i.isMoved && y !== n.touchesDirection && x && Math.abs(v) >= 1 && (n.loopFix({ direction: n.swipeDirection, setTranslate: !0 }), b = !0), n.emit("sliderMove", u), i.isMoved = !0, i.currentTranslate = v + i.startTranslate; let E = !0, T = r.resistanceRatio; if (r.touchReleaseOnEdges && (T = 0), v > 0 ? (x && !b && i.currentTranslate > (r.centeredSlides ? n.minTranslate() - n.size / 2 : n.minTranslate()) && n.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), i.currentTranslate > n.minTranslate() && (E = !1, r.resistance && (i.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + i.startTranslate + v) ** T))) : v < 0 && (x && !b && i.currentTranslate < (r.centeredSlides ? n.maxTranslate() + n.size / 2 : n.maxTranslate()) && n.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: n.slides.length - ("auto" === r.slidesPerView ? n.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10))) }), i.currentTranslate < n.maxTranslate() && (E = !1, r.resistance && (i.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - i.startTranslate - v) ** T))), E && (u.preventedByNestedSwiper = !0), !n.allowSlideNext && "next" === n.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !n.allowSlidePrev && "prev" === n.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), n.allowSlidePrev || n.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) { if (!(Math.abs(v) > r.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate); if (!i.allowThresholdMove) return i.allowThresholdMove = !0, a.startX = a.currentX, a.startY = a.currentY, i.currentTranslate = i.startTranslate, void (a.diff = n.isHorizontal() ? a.currentX - a.startX : a.currentY - a.startY) } r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && n.freeMode || r.watchSlidesProgress) && (n.updateActiveIndex(), n.updateSlidesClasses()), n.params.freeMode && r.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(), n.updateProgress(i.currentTranslate), n.setTranslate(i.currentTranslate)) } function U(e) { const t = this, n = t.touchEventsData, i = n.evCache.findIndex((t => t.pointerId === e.pointerId)); if (i >= 0 && n.evCache.splice(i, 1), ["pointercancel", "pointerout", "pointerleave"].includes(e.type)) { if (!("pointercancel" === e.type && (t.browser.isSafari || t.browser.isWebView))) return } const { params: r, touches: s, rtlTranslate: a, slidesGrid: o, enabled: u } = t; if (!u) return; if (!r.simulateTouch && "mouse" === e.pointerType) return; let h = e; if (h.originalEvent && (h = h.originalEvent), n.allowTouchCallbacks && t.emit("touchEnd", h), n.allowTouchCallbacks = !1, !n.isTouched) return n.isMoved && r.grabCursor && t.setGrabCursor(!1), n.isMoved = !1, void (n.startMoving = !1); r.grabCursor && n.isMoved && n.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const d = c(), p = d - n.touchStartTime; if (t.allowClick) { const e = h.path || h.composedPath && h.composedPath(); t.updateClickedSlide(e && e[0] || h.target), t.emit("tap click", h), p < 300 && d - n.lastClickTime < 300 && t.emit("doubleTap doubleClick", h) } if (n.lastClickTime = c(), l((() => { t.destroyed || (t.allowClick = !0) })), !n.isTouched || !n.isMoved || !t.swipeDirection || 0 === s.diff || n.currentTranslate === n.startTranslate) return n.isTouched = !1, n.isMoved = !1, void (n.startMoving = !1); let f; if (n.isTouched = !1, n.isMoved = !1, n.startMoving = !1, f = r.followFinger ? a ? t.translate : -t.translate : -n.currentTranslate, r.cssMode) return; if (t.params.freeMode && r.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: f }); let m = 0, g = t.slidesSizesGrid[0]; for (let e = 0; e < o.length; e += e < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup) { const t = e < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; void 0 !== o[e + t] ? f >= o[e] && f < o[e + t] && (m = e, g = o[e + t] - o[e]) : f >= o[e] && (m = e, g = o[o.length - 1] - o[o.length - 2]) } let v = null, _ = null; r.rewind && (t.isBeginning ? _ = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (v = 0)); const y = (f - o[m]) / g, x = m < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; if (p > r.longSwipesMs) { if (!r.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (y >= r.longSwipesRatio ? t.slideTo(r.rewind && t.isEnd ? v : m + x) : t.slideTo(m)), "prev" === t.swipeDirection && (y > 1 - r.longSwipesRatio ? t.slideTo(m + x) : null !== _ && y < 0 && Math.abs(y) > r.longSwipesRatio ? t.slideTo(_) : t.slideTo(m)) } else { if (!r.shortSwipes) return void t.slideTo(t.activeIndex); t.navigation && (h.target === t.navigation.nextEl || h.target === t.navigation.prevEl) ? h.target === t.navigation.nextEl ? t.slideTo(m + x) : t.slideTo(m) : ("next" === t.swipeDirection && t.slideTo(null !== v ? v : m + x), "prev" === t.swipeDirection && t.slideTo(null !== _ ? _ : m)) } } function B() { const e = this, { params: t, el: n } = e; if (n && 0 === n.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: i, allowSlidePrev: r, snapGrid: s } = e, a = e.virtual && e.params.virtual.enabled; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(); const o = a && t.loop; !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || o ? e.params.loop && !a ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout((() => { e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume() }), 500)), e.allowSlidePrev = r, e.allowSlideNext = i, e.params.watchOverflow && s !== e.snapGrid && e.checkOverflow() } function k(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function z() { const e = this, { wrapperEl: t, rtlTranslate: n, enabled: i } = e; if (!i) return; let r; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const s = e.maxTranslate() - e.minTranslate(); r = 0 === s ? 0 : (e.translate - e.minTranslate()) / s, r !== e.progress && e.updateProgress(n ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } function H(e) { A(this, e.target), this.update() } let G = !1; function V() { } const W = (e, t) => { const n = s(), { params: i, el: r, wrapperEl: a, device: o } = e, l = !!i.nested, c = "on" === t ? "addEventListener" : "removeEventListener", u = t; r[c]("pointerdown", e.onTouchStart, { passive: !1 }), n[c]("pointermove", e.onTouchMove, { passive: !1, capture: l }), n[c]("pointerup", e.onTouchEnd, { passive: !0 }), n[c]("pointercancel", e.onTouchEnd, { passive: !0 }), n[c]("pointerout", e.onTouchEnd, { passive: !0 }), n[c]("pointerleave", e.onTouchEnd, { passive: !0 }), (i.preventClicks || i.preventClicksPropagation) && r[c]("click", e.onClick, !0), i.cssMode && a[c]("scroll", e.onScroll), i.updateOnWindowResize ? e[u](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", B, !0) : e[u]("observerUpdate", B, !0), r[c]("load", e.onLoad, { capture: !0 }) }; const j = (e, t) => e.grid && t.grid && t.grid.rows > 1; const X = { init: !0, direction: "horizontal", oneWayMovement: !1, touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopedSlides: null, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function q(e, t) { return function (n = {}) { const i = Object.keys(n)[0], r = n[i]; "object" == typeof r && null !== r ? (["navigation", "pagination", "scrollbar"].indexOf(i) >= 0 && !0 === e[i] && (e[i] = { auto: !0 }), i in e && "enabled" in r ? (!0 === e[i] && (e[i] = { enabled: !0 }), "object" != typeof e[i] || "enabled" in e[i] || (e[i].enabled = !0), e[i] || (e[i] = { enabled: !1 }), d(t, n)) : d(t, n)) : d(t, n) } } const Y = { eventsEmitter: w, update: R, translate: L, transition: { setTransition: function (e, t) { const n = this; n.params.cssMode || (n.wrapperEl.style.transitionDuration = `${e}ms`), n.emit("setTransition", e, t) }, transitionStart: function (e = !0, t) { const n = this, { params: i } = n; i.cssMode || (i.autoHeight && n.updateAutoHeight(), P({ swiper: n, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function (e = !0, t) { const n = this, { params: i } = n; n.animating = !1, i.cssMode || (n.setTransition(0), P({ swiper: n, runCallbacks: e, direction: t, step: "End" })) } }, slide: I, loop: N, grabCursor: { setGrabCursor: function (e) { const t = this; if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const n = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; t.isElement && (t.__preventObserver__ = !0), n.style.cursor = "move", n.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame((() => { t.__preventObserver__ = !1 })) }, unsetGrabCursor: function () { const e = this; e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame((() => { e.__preventObserver__ = !1 }))) } }, events: { attachEvents: function () { const e = this, t = s(), { params: n } = e; e.onTouchStart = O.bind(e), e.onTouchMove = F.bind(e), e.onTouchEnd = U.bind(e), n.cssMode && (e.onScroll = z.bind(e)), e.onClick = k.bind(e), e.onLoad = H.bind(e), G || (t.addEventListener("touchstart", V), G = !0), W(e, "on") }, detachEvents: function () { W(this, "off") } }, breakpoints: { setBreakpoint: function () { const e = this, { realIndex: t, initialized: n, params: i, el: r } = e, s = i.breakpoints; if (!s || s && 0 === Object.keys(s).length) return; const a = e.getBreakpoint(s, e.params.breakpointsBase, e.el); if (!a || e.currentBreakpoint === a) return; const o = (a in s ? s[a] : void 0) || e.originalParams, l = j(e, i), c = j(e, o), u = i.enabled; l && !c ? (r.classList.remove(`${i.containerModifierClass}grid`, `${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !l && c && (r.classList.add(`${i.containerModifierClass}grid`), (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === i.grid.fill) && r.classList.add(`${i.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => { const n = i[t] && i[t].enabled, r = o[t] && o[t].enabled; n && !r && e[t].disable(), !n && r && e[t].enable() })); const h = o.direction && o.direction !== i.direction, p = i.loop && (o.slidesPerView !== i.slidesPerView || h); h && n && e.changeDirection(), d(e.params, o); const f = e.params.enabled; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), u && !f ? e.disable() : !u && f && e.enable(), e.currentBreakpoint = a, e.emit("_beforeBreakpoint", o), p && n && (e.loopDestroy(), e.loopCreate(t), e.updateSlides()), e.emit("breakpoint", o) }, getBreakpoint: function (e, t = "window", n) { if (!e || "container" === t && !n) return; let i = !1; const r = o(), s = "window" === t ? r.innerHeight : n.clientHeight, a = Object.keys(e).map((e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: s * t, point: e } } return { value: e, point: e } })); a.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let e = 0; e < a.length; e += 1) { const { point: s, value: o } = a[e]; "window" === t ? r.matchMedia(`(min-width: ${o}px)`).matches && (i = s) : o <= n.clientWidth && (i = s) } return i || "max" } }, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: t, params: n } = e, { slidesOffsetBefore: i } = n; if (i) { const t = e.slides.length - 1, n = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * i; e.isLocked = e.size > n } else e.isLocked = 1 === e.snapGrid.length; !0 === n.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === n.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: { addClasses: function () { const e = this, { classNames: t, params: n, rtl: i, el: r, device: s } = e, a = function (e, t) { const n = []; return e.forEach((e => { "object" == typeof e ? Object.keys(e).forEach((i => { e[i] && n.push(t + i) })) : "string" == typeof e && n.push(t + e) })), n }(["initialized", n.direction, { "free-mode": e.params.freeMode && n.freeMode.enabled }, { autoheight: n.autoHeight }, { rtl: i }, { grid: n.grid && n.grid.rows > 1 }, { "grid-column": n.grid && n.grid.rows > 1 && "column" === n.grid.fill }, { android: s.android }, { ios: s.ios }, { "css-mode": n.cssMode }, { centered: n.cssMode && n.centeredSlides }, { "watch-progress": n.watchSlidesProgress }], n.containerModifierClass); t.push(...a), r.classList.add(...t), e.emitContainerClasses() }, removeClasses: function () { const { el: e, classNames: t } = this; e.classList.remove(...t), this.emitContainerClasses() } } }, K = {}; class $ { constructor(...e) { let t, n; 1 === e.length && e[0].constructor && "Object" === Object.prototype.toString.call(e[0]).slice(8, -1) ? n = e[0] : [t, n] = e, n || (n = {}), n = d({}, n), t && !n.el && (n.el = t); const i = s(); if (n.el && "string" == typeof n.el && i.querySelectorAll(n.el).length > 1) { const e = []; return i.querySelectorAll(n.el).forEach((t => { const i = d({}, n, { el: t }); e.push(new $(i)) })), e } const r = this; r.__swiper__ = !0, r.support = T(), r.device = S({ userAgent: n.userAgent }), r.browser = M(), r.eventsListeners = {}, r.eventsAnyListeners = [], r.modules = [...r.__modules__], n.modules && Array.isArray(n.modules) && r.modules.push(...n.modules); const a = {}; r.modules.forEach((e => { e({ params: n, swiper: r, extendParams: q(n, a), on: r.on.bind(r), once: r.once.bind(r), off: r.off.bind(r), emit: r.emit.bind(r) }) })); const o = d({}, X, a); return r.params = d({}, o, K, n), r.originalParams = d({}, r.params), r.passedParams = d({}, n), r.params && r.params.on && Object.keys(r.params.on).forEach((e => { r.on(e, r.params.on[e]) })), r.params && r.params.onAny && r.onAny(r.params.onAny), Object.assign(r, { enabled: r.params.enabled, el: t, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === r.params.direction, isVertical: () => "vertical" === r.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: r.params.allowSlideNext, allowSlidePrev: r.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: r.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, evCache: [] }, allowClick: !0, allowTouchMove: r.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), r.emit("_swiper"), r.params.init && r.init(), r } getSlideIndex(e) { const { slidesEl: t, params: n } = this, i = _(m(t, `.${n.slideClass}, swiper-slide`)[0]); return _(e) - i } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0]) } recalcSlides() { const { slidesEl: e, params: t } = this; this.slides = m(e, `.${t.slideClass}, swiper-slide`) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const n = this; e = Math.min(Math.max(e, 0), 1); const i = n.minTranslate(), r = (n.maxTranslate() - i) * e + i; n.translateTo(r, void 0 === t ? 0 : t), n.updateActiveIndex(), n.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass))); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.forEach((n => { const i = e.getSlideClasses(n); t.push({ slideEl: n, classNames: i }), e.emit("_slideClass", n, i) })), e.emit("_slideClasses", t) } slidesPerViewDynamic(e = "current", t = !1) { const { params: n, slides: i, slidesGrid: r, slidesSizesGrid: s, size: a, activeIndex: o } = this; let l = 1; if (n.centeredSlides) { let e, t = i[o].swiperSlideSize; for (let n = o + 1; n < i.length; n += 1)i[n] && !e && (t += i[n].swiperSlideSize, l += 1, t > a && (e = !0)); for (let n = o - 1; n >= 0; n -= 1)i[n] && !e && (t += i[n].swiperSlideSize, l += 1, t > a && (e = !0)) } else if ("current" === e) for (let e = o + 1; e < i.length; e += 1) { (t ? r[e] + s[e] - r[o] < a : r[e] - r[o] < a) && (l += 1) } else for (let e = o - 1; e >= 0; e -= 1) { r[o] - r[e] < a && (l += 1) } return l } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: n } = e; function i() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, n = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(n), e.updateActiveIndex(), e.updateSlidesClasses() } let r; if (n.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach((t => { t.complete && A(e, t) })), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled) i(), e.params.autoHeight && e.updateAutoHeight(); else { if (("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides) { const t = e.virtual && e.params.virtual.enabled ? e.virtual.slides : e.slides; r = e.slideTo(t.length - 1, 0, !1, !0) } else r = e.slideTo(e.activeIndex, 0, !1, !0); r || i() } n.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t = !0) { const n = this, i = n.params.direction; return e || (e = "horizontal" === i ? "vertical" : "horizontal"), e === i || "horizontal" !== e && "vertical" !== e || (n.el.classList.remove(`${n.params.containerModifierClass}${i}`), n.el.classList.add(`${n.params.containerModifierClass}${e}`), n.emitContainerClasses(), n.params.direction = e, n.slides.forEach((t => { "vertical" === e ? t.style.width = "" : t.style.height = "" })), n.emit("changeDirection"), t && n.update()), n } changeLanguageDirection(e) { const t = this; t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; let n = e || t.params.el; if ("string" == typeof n && (n = document.querySelector(n)), !n) return !1; n.swiper = t, n.shadowEl && (t.isElement = !0); const i = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let r = (() => { if (n && n.shadowRoot && n.shadowRoot.querySelector) { return n.shadowRoot.querySelector(i()) } return m(n, i())[0] })(); return !r && t.params.createElements && (r = g("div", t.params.wrapperClass), n.append(r), m(n, `.${t.params.slideClass}`).forEach((e => { r.append(e) }))), Object.assign(t, { el: n, wrapperEl: r, slidesEl: t.isElement ? n : r, mounted: !0, rtl: "rtl" === n.dir.toLowerCase() || "rtl" === v(n, "direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === n.dir.toLowerCase() || "rtl" === v(n, "direction")), wrongRTL: "-webkit-box" === v(r, "display") }), !0 } init(e) { const t = this; if (t.initialized) return t; return !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(), [...t.el.querySelectorAll('[loading="lazy"]')].forEach((e => { e.complete ? A(t, e) : e.addEventListener("load", (e => { A(t, e.target) })) })), C(t), t.initialized = !0, C(t), t.emit("init"), t.emit("afterInit")), t } destroy(e = !0, t = !0) { const n = this, { params: i, el: r, wrapperEl: s, slides: a } = n; return void 0 === n.params || n.destroyed || (n.emit("beforeDestroy"), n.initialized = !1, n.detachEvents(), i.loop && n.loopDestroy(), t && (n.removeClasses(), r.removeAttribute("style"), s.removeAttribute("style"), a && a.length && a.forEach((e => { e.classList.remove(i.slideVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index") }))), n.emit("destroy"), Object.keys(n.eventsListeners).forEach((e => { n.off(e) })), !1 !== e && (n.el.swiper = null, function (e) { const t = e; Object.keys(t).forEach((e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } })) }(n)), n.destroyed = !0), null } static extendDefaults(e) { d(K, e) } static get extendedDefaults() { return K } static get defaults() { return X } static installModule(e) { $.prototype.__modules__ || ($.prototype.__modules__ = []); const t = $.prototype.__modules__; "function" == typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach((e => $.installModule(e))), $) : ($.installModule(e), $) } } Object.keys(Y).forEach((e => { Object.keys(Y[e]).forEach((t => { $.prototype[t] = Y[e][t] })) })), $.use([function ({ swiper: e, on: t, emit: n }) { const i = o(); let r = null, s = null; const a = () => { e && !e.destroyed && e.initialized && (n("beforeResize"), n("resize")) }, l = () => { e && !e.destroyed && e.initialized && n("orientationchange") }; t("init", (() => { e.params.resizeObserver && void 0 !== i.ResizeObserver ? e && !e.destroyed && e.initialized && (r = new ResizeObserver((t => { s = i.requestAnimationFrame((() => { const { width: n, height: i } = e; let r = n, s = i; t.forEach((({ contentBoxSize: t, contentRect: n, target: i }) => { i && i !== e.el || (r = n ? n.width : (t[0] || t).inlineSize, s = n ? n.height : (t[0] || t).blockSize) })), r === n && s === i || a() })) })), r.observe(e.el)) : (i.addEventListener("resize", a), i.addEventListener("orientationchange", l)) })), t("destroy", (() => { s && i.cancelAnimationFrame(s), r && r.unobserve && e.el && (r.unobserve(e.el), r = null), i.removeEventListener("resize", a), i.removeEventListener("orientationchange", l) })) }, function ({ swiper: e, extendParams: t, on: n, emit: i }) { const r = [], s = o(), a = (t, n = {}) => { const a = new (s.MutationObserver || s.WebkitMutationObserver)((t => { if (e.__preventObserver__) return; if (1 === t.length) return void i("observerUpdate", t[0]); const n = function () { i("observerUpdate", t[0]) }; s.requestAnimationFrame ? s.requestAnimationFrame(n) : s.setTimeout(n, 0) })); a.observe(t, { attributes: void 0 === n.attributes || n.attributes, childList: void 0 === n.childList || n.childList, characterData: void 0 === n.characterData || n.characterData }), r.push(a) }; t({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), n("init", (() => { if (e.params.observer) { if (e.params.observeParents) { const t = function (e, t) { const n = []; let i = e.parentElement; for (; i;)t ? i.matches(t) && n.push(i) : n.push(i), i = i.parentElement; return n }(e.el); for (let e = 0; e < t.length; e += 1)a(t[e]) } a(e.el, { childList: e.params.observeSlideChildren }), a(e.wrapperEl, { attributes: !1 }) } })), n("destroy", (() => { r.forEach((e => { e.disconnect() })), r.splice(0, r.length) })) }]); const Z = $; function J(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function Q(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t } var ee, te, ne, ie, re, se, ae, oe, le, ce, ue, he, de, pe, fe, me = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, ge = { duration: .5, overwrite: !1, delay: 0 }, ve = 1e8, _e = 1e-8, ye = 2 * Math.PI, xe = ye / 4, be = 0, Ee = Math.sqrt, Te = Math.cos, Se = Math.sin, Me = function (e) { return "string" == typeof e }, we = function (e) { return "function" == typeof e }, Ae = function (e) { return "number" == typeof e }, De = function (e) { return void 0 === e }, Ce = function (e) { return "object" == typeof e }, Re = function (e) { return !1 !== e }, Le = function () { return "undefined" != typeof window }, Pe = function (e) { return we(e) || Me(e) }, Ie = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () { }, Ne = Array.isArray, Oe = /(?:-?\.?\d|\.)+/gi, Fe = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Ue = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Be = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, ke = /[+-]=-?[.\d]+/, ze = /[^,'"\[\]\s]+/gi, He = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Ge = {}, Ve = {}, We = function (e) { return (Ve = yt(e, Ge)) && xi }, je = function (e, t) { return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()") }, Xe = function (e, t) { return !t && console.warn(e) }, qe = function (e, t) { return e && (Ge[e] = t) && Ve && (Ve[e] = t) || Ge }, Ye = function () { return 0 }, Ke = { suppressEvents: !0, isStart: !0, kill: !1 }, $e = { suppressEvents: !0, kill: !1 }, Ze = { suppressEvents: !0 }, Je = {}, Qe = [], et = {}, tt = {}, nt = {}, it = 30, rt = [], st = "", at = function (e) { var t, n, i = e[0]; if (Ce(i) || we(i) || (e = [e]), !(t = (i._gsap || {}).harness)) { for (n = rt.length; n-- && !rt[n].targetTest(i);); t = rt[n] } for (n = e.length; n--;)e[n] && (e[n]._gsap || (e[n]._gsap = new On(e[n], t))) || e.splice(n, 1); return e }, ot = function (e) { return e._gsap || at(Zt(e))[0]._gsap }, lt = function (e, t, n) { return (n = e[t]) && we(n) ? e[t]() : De(n) && e.getAttribute && e.getAttribute(t) || n }, ct = function (e, t) { return (e = e.split(",")).forEach(t) || e }, ut = function (e) { return Math.round(1e5 * e) / 1e5 || 0 }, ht = function (e) { return Math.round(1e7 * e) / 1e7 || 0 }, dt = function (e, t) { var n = t.charAt(0), i = parseFloat(t.substr(2)); return e = parseFloat(e), "+" === n ? e + i : "-" === n ? e - i : "*" === n ? e * i : e / i }, pt = function (e, t) { for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n;); return i < n }, ft = function () { var e, t, n = Qe.length, i = Qe.slice(0); for (et = {}, Qe.length = 0, e = 0; e < n; e++)(t = i[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0) }, mt = function (e, t, n, i) { Qe.length && !te && ft(), e.render(t, n, i || te && t < 0 && (e._initted || e._startAt)), Qe.length && !te && ft() }, gt = function (e) { var t = parseFloat(e); return (t || 0 === t) && (e + "").match(ze).length < 2 ? t : Me(e) ? e.trim() : e }, vt = function (e) { return e }, _t = function (e, t) { for (var n in t) n in e || (e[n] = t[n]); return e }, yt = function (e, t) { for (var n in t) e[n] = t[n]; return e }, xt = function e(t, n) { for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (t[i] = Ce(n[i]) ? e(t[i] || (t[i] = {}), n[i]) : n[i]); return t }, bt = function (e, t) { var n, i = {}; for (n in e) n in t || (i[n] = e[n]); return i }, Et = function (e) { var t, n = e.parent || ie, i = e.keyframes ? (t = Ne(e.keyframes), function (e, n) { for (var i in n) i in e || "duration" === i && t || "ease" === i || (e[i] = n[i]) }) : _t; if (Re(e.inherit)) for (; n;)i(e, n.vars.defaults), n = n.parent || n._dp; return e }, Tt = function (e, t, n, i, r) { void 0 === n && (n = "_first"), void 0 === i && (i = "_last"); var s, a = e[i]; if (r) for (s = t[r]; a && a[r] > s;)a = a._prev; return a ? (t._next = a._next, a._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = a, t.parent = t._dp = e, t }, St = function (e, t, n, i) { void 0 === n && (n = "_first"), void 0 === i && (i = "_last"); var r = t._prev, s = t._next; r ? r._next = s : e[n] === t && (e[n] = s), s ? s._prev = r : e[i] === t && (e[i] = r), t._next = t._prev = t.parent = null }, Mt = function (e, t) { e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove(e), e._act = 0 }, wt = function (e, t) { if (e && (!t || t._end > e._dur || t._start < 0)) for (var n = e; n;)n._dirty = 1, n = n.parent; return e }, At = function (e, t, n, i) { return e._startAt && (te ? e._startAt.revert($e) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i)) }, Dt = function e(t) { return !t || t._ts && e(t.parent) }, Ct = function (e) { return e._repeat ? Rt(e._tTime, e = e.duration() + e._rDelay) * e : 0 }, Rt = function (e, t) { var n = Math.floor(e /= t); return e && n === e ? n - 1 : n }, Lt = function (e, t) { return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur) }, Pt = function (e) { return e._end = ht(e._start + (e._tDur / Math.abs(e._ts || e._rts || _e) || 0)) }, It = function (e, t) { var n = e._dp; return n && n.smoothChildTiming && e._ts && (e._start = ht(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Pt(e), n._dirty || wt(n, e)), e }, Nt = function (e, t) { var n; if ((t._time || t._initted && !t._dur) && (n = Lt(e.rawTime(), t), (!t._dur || Xt(0, t.totalDuration(), n) - t._tTime > _e) && t.render(n, !0)), wt(e, t)._dp && e._initted && e._time >= e._dur && e._ts) { if (e._dur < e.duration()) for (n = e; n._dp;)n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp; e._zTime = -1e-8 } }, Ot = function (e, t, n, i) { return t.parent && Mt(t), t._start = ht((Ae(n) ? n : n || e !== ie ? Vt(e, n, t) : e._time) + t._delay), t._end = ht(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), Tt(e, t, "_first", "_last", e._sort ? "_start" : 0), kt(t) || (e._recent = t), i || Nt(e, t), e._ts < 0 && It(e, e._tTime), e }, Ft = function (e, t) { return (Ge.ScrollTrigger || je("scrollTrigger", t)) && Ge.ScrollTrigger.create(t, e) }, Ut = function (e, t, n, i, r) { return Vn(e, t, r), e._initted ? !n && e._pt && !te && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && le !== En.frame ? (Qe.push(e), e._lazy = [r, i], 1) : void 0 : 1 }, Bt = function e(t) { var n = t.parent; return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n)) }, kt = function (e) { var t = e.data; return "isFromStart" === t || "isStart" === t }, zt = function (e, t, n, i) { var r = e._repeat, s = ht(t) || 0, a = e._tTime / e._tDur; return a && !i && (e._time *= s / e._dur), e._dur = s, e._tDur = r ? r < 0 ? 1e10 : ht(s * (r + 1) + e._rDelay * r) : s, a > 0 && !i && It(e, e._tTime = e._tDur * a), e.parent && Pt(e), n || wt(e.parent, e), e }, Ht = function (e) { return e instanceof Un ? wt(e) : zt(e, e._dur) }, Gt = { _start: 0, endTime: Ye, totalDuration: Ye }, Vt = function e(t, n, i) { var r, s, a, o = t.labels, l = t._recent || Gt, c = t.duration() >= ve ? l.endTime(!1) : t._dur; return Me(n) && (isNaN(n) || n in o) ? (s = n.charAt(0), a = "%" === n.substr(-1), r = n.indexOf("="), "<" === s || ">" === s ? (r >= 0 && (n = n.replace(/=/, "")), ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (a ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in o || (o[n] = c), o[n]) : (s = parseFloat(n.charAt(r - 1) + n.substr(r + 1)), a && i && (s = s / 100 * (Ne(i) ? i[0] : i).totalDuration()), r > 1 ? e(t, n.substr(0, r - 1), i) + s : c + s)) : null == n ? c : +n }, Wt = function (e, t, n) { var i, r, s = Ae(t[1]), a = (s ? 2 : 1) + (e < 2 ? 0 : 1), o = t[a]; if (s && (o.duration = t[1]), o.parent = n, e) { for (i = o, r = n; r && !("immediateRender" in i);)i = r.vars.defaults || {}, r = Re(r.vars.inherit) && r.parent; o.immediateRender = Re(i.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[a - 1] } return new Yn(t[0], o, t[a + 1]) }, jt = function (e, t) { return e || 0 === e ? t(e) : t }, Xt = function (e, t, n) { return n < e ? e : n > t ? t : n }, qt = function (e, t) { return Me(e) && (t = He.exec(e)) ? t[1] : "" }, Yt = [].slice, Kt = function (e, t) { return e && Ce(e) && "length" in e && (!t && !e.length || e.length - 1 in e && Ce(e[0])) && !e.nodeType && e !== re }, $t = function (e, t, n) { return void 0 === n && (n = []), e.forEach((function (e) { var i; return Me(e) && !t || Kt(e, 1) ? (i = n).push.apply(i, Zt(e)) : n.push(e) })) || n }, Zt = function (e, t, n) { return ne && !t && ne.selector ? ne.selector(e) : !Me(e) || n || !se && Tn() ? Ne(e) ? $t(e, n) : Kt(e) ? Yt.call(e, 0) : e ? [e] : [] : Yt.call((t || ae).querySelectorAll(e), 0) }, Jt = function (e) { return e = Zt(e)[0] || Xe("Invalid scope") || {}, function (t) { var n = e.current || e.nativeElement || e; return Zt(t, n.querySelectorAll ? n : n === e ? Xe("Invalid scope") || ae.createElement("div") : e) } }, Qt = function (e) { return e.sort((function () { return .5 - Math.random() })) }, en = function (e) { if (we(e)) return e; var t = Ce(e) ? e : { each: e }, n = Rn(t.ease), i = t.from || 0, r = parseFloat(t.base) || 0, s = {}, a = i > 0 && i < 1, o = isNaN(i) || a, l = t.axis, c = i, u = i; return Me(i) ? c = u = { center: .5, edges: .5, end: 1 }[i] || 0 : !a && o && (c = i[0], u = i[1]), function (e, a, h) { var d, p, f, m, g, v, _, y, x, b = (h || t).length, E = s[b]; if (!E) { if (!(x = "auto" === t.grid ? 0 : (t.grid || [1, ve])[1])) { for (_ = -ve; _ < (_ = h[x++].getBoundingClientRect().left) && x < b;); x-- } for (E = s[b] = [], d = o ? Math.min(x, b) * c - .5 : i % x, p = x === ve ? 0 : o ? b * u / x - .5 : i / x | 0, _ = 0, y = ve, v = 0; v < b; v++)f = v % x - d, m = p - (v / x | 0), E[v] = g = l ? Math.abs("y" === l ? m : f) : Ee(f * f + m * m), g > _ && (_ = g), g < y && (y = g); "random" === i && Qt(E), E.max = _ - y, E.min = y, E.v = b = (parseFloat(t.amount) || parseFloat(t.each) * (x > b ? b - 1 : l ? "y" === l ? b / x : x : Math.max(x, b / x)) || 0) * ("edges" === i ? -1 : 1), E.b = b < 0 ? r - b : r, E.u = qt(t.amount || t.each) || 0, n = n && b < 0 ? Dn(n) : n } return b = (E[e] - E.min) / E.max || 0, ht(E.b + (n ? n(b) : b) * E.v) + E.u } }, tn = function (e) { var t = Math.pow(10, ((e + "").split(".")[1] || "").length); return function (n) { var i = ht(Math.round(parseFloat(n) / e) * e * t); return (i - i % 1) / t + (Ae(n) ? 0 : qt(n)) } }, nn = function (e, t) { var n, i, r = Ne(e); return !r && Ce(e) && (n = r = e.radius || ve, e.values ? (e = Zt(e.values), (i = !Ae(e[0])) && (n *= n)) : e = tn(e.increment)), jt(t, r ? we(e) ? function (t) { return i = e(t), Math.abs(i - t) <= n ? i : t } : function (t) { for (var r, s, a = parseFloat(i ? t.x : t), o = parseFloat(i ? t.y : 0), l = ve, c = 0, u = e.length; u--;)(r = i ? (r = e[u].x - a) * r + (s = e[u].y - o) * s : Math.abs(e[u] - a)) < l && (l = r, c = u); return c = !n || l <= n ? e[c] : t, i || c === t || Ae(t) ? c : c + qt(t) } : tn(e)) }, rn = function (e, t, n, i) { return jt(Ne(e) ? !t : !0 === n ? !!(n = 0) : !i, (function () { return Ne(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + .99 * n)) / n) * n * i) / i })) }, sn = function (e, t, n) { return jt(n, (function (n) { return e[~~t(n)] })) }, an = function (e) { for (var t, n, i, r, s = 0, a = ""; ~(t = e.indexOf("random(", s));)i = e.indexOf(")", t), r = "[" === e.charAt(t + 7), n = e.substr(t + 7, i - t - 7).match(r ? ze : Oe), a += e.substr(s, t - s) + rn(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), s = i + 1; return a + e.substr(s, e.length - s) }, on = function (e, t, n, i, r) { var s = t - e, a = i - n; return jt(r, (function (t) { return n + ((t - e) / s * a || 0) })) }, ln = function (e, t, n) { var i, r, s, a = e.labels, o = ve; for (i in a) (r = a[i] - t) < 0 == !!n && r && o > (r = Math.abs(r)) && (s = i, o = r); return s }, cn = function (e, t, n) { var i, r, s, a = e.vars, o = a[t], l = ne, c = e._ctx; if (o) return i = a[t + "Params"], r = a.callbackScope || e, n && Qe.length && ft(), c && (ne = c), s = i ? o.apply(r, i) : o.call(r), ne = l, s }, un = function (e) { return Mt(e), e.scrollTrigger && e.scrollTrigger.kill(!!te), e.progress() < 1 && cn(e, "onInterrupt"), e }, hn = [], dn = function (e) { if (Le()) { var t = (e = !e.name && e.default || e).name, n = we(e), i = t && !n && e.init ? function () { this._props = [] } : e, r = { init: Ye, render: ii, add: Hn, kill: si, modifier: ri, rawVars: 0 }, s = { targetTest: 0, get: 0, getSetter: Qn, aliases: {}, register: 0 }; if (Tn(), e !== i) { if (tt[t]) return; _t(i, _t(bt(e, r), s)), yt(i.prototype, yt(r, bt(e, s))), tt[i.prop = t] = i, e.targetTest && (rt.push(i), Je[t] = 1), t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin" } qe(t, i), e.register && e.register(xi, i, li) } else hn.push(e) }, pn = 255, fn = { aqua: [0, pn, pn], lime: [0, pn, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, pn], navy: [0, 0, 128], white: [pn, pn, pn], olive: [128, 128, 0], yellow: [pn, pn, 0], orange: [pn, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [pn, 0, 0], pink: [pn, 192, 203], cyan: [0, pn, pn], transparent: [pn, pn, pn, 0] }, mn = function (e, t, n) { return (6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * pn + .5 | 0 }, gn = function (e, t, n) { var i, r, s, a, o, l, c, u, h, d, p = e ? Ae(e) ? [e >> 16, e >> 8 & pn, e & pn] : 0 : fn.black; if (!p) { if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), fn[e]) p = fn[e]; else if ("#" === e.charAt(0)) { if (e.length < 6 && (i = e.charAt(1), r = e.charAt(2), s = e.charAt(3), e = "#" + i + i + r + r + s + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(p = parseInt(e.substr(1, 6), 16)) >> 16, p >> 8 & pn, p & pn, parseInt(e.substr(7), 16) / 255]; p = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & pn, e & pn] } else if ("hsl" === e.substr(0, 3)) if (p = d = e.match(Oe), t) { if (~e.indexOf("=")) return p = e.match(Fe), n && p.length < 4 && (p[3] = 1), p } else a = +p[0] % 360 / 360, o = +p[1] / 100, i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), p.length > 3 && (p[3] *= 1), p[0] = mn(a + 1 / 3, i, r), p[1] = mn(a, i, r), p[2] = mn(a - 1 / 3, i, r); else p = e.match(Oe) || fn.transparent; p = p.map(Number) } return t && !d && (i = p[0] / pn, r = p[1] / pn, s = p[2] / pn, l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2, c === u ? a = o = 0 : (h = c - u, o = l > .5 ? h / (2 - c - u) : h / (c + u), a = c === i ? (r - s) / h + (r < s ? 6 : 0) : c === r ? (s - i) / h + 2 : (i - r) / h + 4, a *= 60), p[0] = ~~(a + .5), p[1] = ~~(100 * o + .5), p[2] = ~~(100 * l + .5)), n && p.length < 4 && (p[3] = 1), p }, vn = function (e) { var t = [], n = [], i = -1; return e.split(yn).forEach((function (e) { var r = e.match(Ue) || []; t.push.apply(t, r), n.push(i += r.length + 1) })), t.c = n, t }, _n = function (e, t, n) { var i, r, s, a, o = "", l = (e + o).match(yn), c = t ? "hsla(" : "rgba(", u = 0; if (!l) return e; if (l = l.map((function (e) { return (e = gn(e, t, 1)) && c + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")" })), n && (s = vn(e), (i = n.c).join(o) !== s.c.join(o))) for (a = (r = e.replace(yn, "1").split(Ue)).length - 1; u < a; u++)o += r[u] + (~i.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift()); if (!r) for (a = (r = e.split(yn)).length - 1; u < a; u++)o += r[u] + l[u]; return o + r[a] }, yn = function () { var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b"; for (e in fn) t += "|" + e + "\\b"; return new RegExp(t + ")", "gi") }(), xn = /hsl[a]?\(/, bn = function (e) { var t, n = e.join(" "); if (yn.lastIndex = 0, yn.test(n)) return t = xn.test(n), e[1] = _n(e[1], t), e[0] = _n(e[0], t, vn(e[1])), !0 }, En = function () { var e, t, n, i, r, s, a = Date.now, o = 500, l = 33, c = a(), u = c, h = 1e3 / 240, d = h, p = [], f = function n(f) { var m, g, v, _, y = a() - u, x = !0 === f; if (y > o && (c += y - l), ((m = (v = (u += y) - c) - d) > 0 || x) && (_ = ++i.frame, r = v - 1e3 * i.time, i.time = v /= 1e3, d += m + (m >= h ? 4 : h - m), g = 1), x || (e = t(n)), g) for (s = 0; s < p.length; s++)p[s](v, r, _, f) }; return i = { time: 0, frame: 0, tick: function () { f(!0) }, deltaRatio: function (e) { return r / (1e3 / (e || 60)) }, wake: function () { oe && (!se && Le() && (re = se = window, ae = re.document || {}, Ge.gsap = xi, (re.gsapVersions || (re.gsapVersions = [])).push(xi.version), We(Ve || re.GreenSockGlobals || !re.gsap && re || {}), n = re.requestAnimationFrame, hn.forEach(dn)), e && i.sleep(), t = n || function (e) { return setTimeout(e, d - 1e3 * i.time + 1 | 0) }, ue = 1, f(2)) }, sleep: function () { (n ? re.cancelAnimationFrame : clearTimeout)(e), ue = 0, t = Ye }, lagSmoothing: function (e, t) { o = e || 1 / 0, l = Math.min(t || 33, o) }, fps: function (e) { h = 1e3 / (e || 240), d = 1e3 * i.time + h }, add: function (e, t, n) { var r = t ? function (t, n, s, a) { e(t, n, s, a), i.remove(r) } : e; return i.remove(e), p[n ? "unshift" : "push"](r), Tn(), r }, remove: function (e, t) { ~(t = p.indexOf(e)) && p.splice(t, 1) && s >= t && s-- }, _listeners: p } }(), Tn = function () { return !ue && En.wake() }, Sn = {}, Mn = /^[\d.\-M][\d.\-,\s]/, wn = /["']/g, An = function (e) { for (var t, n, i, r = {}, s = e.substr(1, e.length - 3).split(":"), a = s[0], o = 1, l = s.length; o < l; o++)n = s[o], t = o !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, t), r[a] = isNaN(i) ? i.replace(wn, "").trim() : +i, a = n.substr(t + 1).trim(); return r }, Dn = function (e) { return function (t) { return 1 - e(1 - t) } }, Cn = function e(t, n) { for (var i, r = t._first; r;)r instanceof Un ? e(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? e(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next }, Rn = function (e, t) { return e && (we(e) ? e : Sn[e] || function (e) { var t, n, i, r, s = (e + "").split("("), a = Sn[s[0]]; return a && s.length > 1 && a.config ? a.config.apply(null, ~e.indexOf("{") ? [An(s[1])] : (t = e, n = t.indexOf("(") + 1, i = t.indexOf(")"), r = t.indexOf("(", n), t.substring(n, ~r && r < i ? t.indexOf(")", i + 1) : i)).split(",").map(gt)) : Sn._CE && Mn.test(e) ? Sn._CE("", e) : a }(e)) || t }, Ln = function (e, t, n, i) { void 0 === n && (n = function (e) { return 1 - t(1 - e) }), void 0 === i && (i = function (e) { return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2 }); var r, s = { easeIn: t, easeOut: n, easeInOut: i }; return ct(e, (function (e) { for (var t in Sn[e] = Ge[e] = s, Sn[r = e.toLowerCase()] = n, s) Sn[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = Sn[e + "." + t] = s[t] })), s }, Pn = function (e) { return function (t) { return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2 } }, In = function e(t, n, i) { var r = n >= 1 ? n : 1, s = (i || (t ? .3 : .45)) / (n < 1 ? n : 1), a = s / ye * (Math.asin(1 / r) || 0), o = function (e) { return 1 === e ? 1 : r * Math.pow(2, -10 * e) * Se((e - a) * s) + 1 }, l = "out" === t ? o : "in" === t ? function (e) { return 1 - o(1 - e) } : Pn(o); return s = ye / s, l.config = function (n, i) { return e(t, n, i) }, l }, Nn = function e(t, n) { void 0 === n && (n = 1.70158); var i = function (e) { return e ? --e * e * ((n + 1) * e + n) + 1 : 0 }, r = "out" === t ? i : "in" === t ? function (e) { return 1 - i(1 - e) } : Pn(i); return r.config = function (n) { return e(t, n) }, r }; ct("Linear,Quad,Cubic,Quart,Quint,Strong", (function (e, t) { var n = t < 5 ? t + 1 : t; Ln(e + ",Power" + (n - 1), t ? function (e) { return Math.pow(e, n) } : function (e) { return e }, (function (e) { return 1 - Math.pow(1 - e, n) }), (function (e) { return e < .5 ? Math.pow(2 * e, n) / 2 : 1 - Math.pow(2 * (1 - e), n) / 2 })) })), Sn.Linear.easeNone = Sn.none = Sn.Linear.easeIn, Ln("Elastic", In("in"), In("out"), In()), he = 7.5625, pe = 1 / (de = 2.75), Ln("Bounce", (function (e) { return 1 - fe(1 - e) }), fe = function (e) { return e < pe ? he * e * e : e < .7272727272727273 ? he * Math.pow(e - 1.5 / de, 2) + .75 : e < .9090909090909092 ? he * (e -= 2.25 / de) * e + .9375 : he * Math.pow(e - 2.625 / de, 2) + .984375 }), Ln("Expo", (function (e) { return e ? Math.pow(2, 10 * (e - 1)) : 0 })), Ln("Circ", (function (e) { return -(Ee(1 - e * e) - 1) })), Ln("Sine", (function (e) { return 1 === e ? 1 : 1 - Te(e * xe) })), Ln("Back", Nn("in"), Nn("out"), Nn()), Sn.SteppedEase = Sn.steps = Ge.SteppedEase = { config: function (e, t) { void 0 === e && (e = 1); var n = 1 / e, i = e + (t ? 0 : 1), r = t ? 1 : 0; return function (e) { return ((i * Xt(0, .99999999, e) | 0) + r) * n } } }, ge.ease = Sn["quad.out"], ct("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (e) { return st += e + "," + e + "Params," })); var On = function (e, t) { this.id = be++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : lt, this.set = t ? t.getSetter : Qn }, Fn = function () { function e(e) { this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, zt(this, +e.duration, 1, 1), this.data = e.data, ne && (this._ctx = ne, ne.data.push(this)), ue || En.wake() } var t = e.prototype; return t.delay = function (e) { return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay }, t.duration = function (e) { return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur }, t.totalDuration = function (e) { return arguments.length ? (this._dirty = 0, zt(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, t.totalTime = function (e, t) { if (Tn(), !arguments.length) return this._tTime; var n = this._dp; if (n && n.smoothChildTiming && this._ts) { for (It(this, e), !n._dp || n.parent || Nt(n, this); n && n.parent;)n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent; !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && Ot(this._dp, this, this._start - this._delay) } return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === _e || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e), mt(this, e, t)), this }, t.time = function (e, t) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + Ct(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time }, t.totalProgress = function (e, t) { return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio }, t.progress = function (e, t) { return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + Ct(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio }, t.iteration = function (e, t) { var n = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (e - 1) * n, t) : this._repeat ? Rt(this._tTime, n) + 1 : 1 }, t.timeScale = function (e) { if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts; if (this._rts === e) return this; var t = this.parent && this._ts ? Lt(this.parent._time, this) : this._tTime; return this._rts = +e || 0, this._ts = this._ps || -1e-8 === e ? 0 : this._rts, this.totalTime(Xt(-Math.abs(this._delay), this._tDur, t), !0), Pt(this), function (e) { for (var t = e.parent; t && t.parent;)t._dirty = 1, t.totalDuration(), t = t.parent; return e }(this) }, t.paused = function (e) { return arguments.length ? (this._ps !== e && (this._ps = e, e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Tn(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== _e && (this._tTime -= _e)))), this) : this._ps }, t.startTime = function (e) { if (arguments.length) { this._start = e; var t = this.parent || this._dp; return t && (t._sort || !this.parent) && Ot(t, this, e - this._delay), this } return this._start }, t.endTime = function (e) { return this._start + (Re(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1) }, t.rawTime = function (e) { var t = this.parent || this._dp; return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Lt(t.rawTime(e), this) : this._tTime : this._tTime }, t.revert = function (e) { void 0 === e && (e = Ze); var t = te; return te = e, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(e), this.totalTime(-.01, e.suppressEvents)), "nested" !== this.data && !1 !== e.kill && this.kill(), te = t, this }, t.globalTime = function (e) { for (var t = this, n = arguments.length ? e : t.rawTime(); t;)n = t._start + n / (t._ts || 1), t = t._dp; return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(e) : n }, t.repeat = function (e) { return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, Ht(this)) : -2 === this._repeat ? 1 / 0 : this._repeat }, t.repeatDelay = function (e) { if (arguments.length) { var t = this._time; return this._rDelay = e, Ht(this), t ? this.time(t) : this } return this._rDelay }, t.yoyo = function (e) { return arguments.length ? (this._yoyo = e, this) : this._yoyo }, t.seek = function (e, t) { return this.totalTime(Vt(this, e), Re(t)) }, t.restart = function (e, t) { return this.play().totalTime(e ? -this._delay : 0, Re(t)) }, t.play = function (e, t) { return null != e && this.seek(e, t), this.reversed(!1).paused(!1) }, t.reverse = function (e, t) { return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1) }, t.pause = function (e, t) { return null != e && this.seek(e, t), this.paused(!0) }, t.resume = function () { return this.paused(!1) }, t.reversed = function (e) { return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -1e-8 : 0)), this) : this._rts < 0 }, t.invalidate = function () { return this._initted = this._act = 0, this._zTime = -1e-8, this }, t.isActive = function () { var e, t = this.parent || this._dp, n = this._start; return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= n && e < this.endTime(!0) - _e)) }, t.eventCallback = function (e, t, n) { var i = this.vars; return arguments.length > 1 ? (t ? (i[e] = t, n && (i[e + "Params"] = n), "onUpdate" === e && (this._onUpdate = t)) : delete i[e], this) : i[e] }, t.then = function (e) { var t = this; return new Promise((function (n) { var i = we(e) ? e : vt, r = function () { var e = t.then; t.then = null, we(i) && (i = i(t)) && (i.then || i === t) && (t.then = e), n(i), t.then = e }; t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? r() : t._prom = r })) }, t.kill = function () { un(this) }, e }(); _t(Fn.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -1e-8, _prom: 0, _ps: !1, _rts: 1 }); var Un = function (e) { function t(t, n) { var i; return void 0 === t && (t = {}), (i = e.call(this, t) || this).labels = {}, i.smoothChildTiming = !!t.smoothChildTiming, i.autoRemoveChildren = !!t.autoRemoveChildren, i._sort = Re(t.sortChildren), ie && Ot(t.parent || ie, J(i), n), t.reversed && i.reverse(), t.paused && i.paused(!0), t.scrollTrigger && Ft(J(i), t.scrollTrigger), i } Q(t, e); var n = t.prototype; return n.to = function (e, t, n) { return Wt(0, arguments, this), this }, n.from = function (e, t, n) { return Wt(1, arguments, this), this }, n.fromTo = function (e, t, n, i) { return Wt(2, arguments, this), this }, n.set = function (e, t, n) { return t.duration = 0, t.parent = this, Et(t).repeatDelay || (t.repeat = 0), t.immediateRender = !!t.immediateRender, new Yn(e, t, Vt(this, n), 1), this }, n.call = function (e, t, n) { return Ot(this, Yn.delayedCall(0, e, t), n) }, n.staggerTo = function (e, t, n, i, r, s, a) { return n.duration = t, n.stagger = n.stagger || i, n.onComplete = s, n.onCompleteParams = a, n.parent = this, new Yn(e, n, Vt(this, r)), this }, n.staggerFrom = function (e, t, n, i, r, s, a) { return n.runBackwards = 1, Et(n).immediateRender = Re(n.immediateRender), this.staggerTo(e, t, n, i, r, s, a) }, n.staggerFromTo = function (e, t, n, i, r, s, a, o) { return i.startAt = n, Et(i).immediateRender = Re(i.immediateRender), this.staggerTo(e, t, i, r, s, a, o) }, n.render = function (e, t, n) { var i, r, s, a, o, l, c, u, h, d, p, f, m = this._time, g = this._dirty ? this.totalDuration() : this._tDur, v = this._dur, _ = e <= 0 ? 0 : ht(e), y = this._zTime < 0 != e < 0 && (this._initted || !v); if (this !== ie && _ > g && e >= 0 && (_ = g), _ !== this._tTime || n || y) { if (m !== this._time && v && (_ += this._time - m, e += this._time - m), i = _, h = this._start, l = !(u = this._ts), y && (v || (m = this._zTime), (e || !t) && (this._zTime = e)), this._repeat) { if (p = this._yoyo, o = v + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * o + e, t, n); if (i = ht(_ % o), _ === g ? (a = this._repeat, i = v) : ((a = ~~(_ / o)) && a === _ / o && (i = v, a--), i > v && (i = v)), d = Rt(this._tTime, o), !m && this._tTime && d !== a && this._tTime - d * o - this._dur <= 0 && (d = a), p && 1 & a && (i = v - i, f = 1), a !== d && !this._lock) { var x = p && 1 & d, b = x === (p && 1 & a); if (a < d && (x = !x), m = x ? 0 : v, this._lock = 1, this.render(m || (f ? 0 : ht(a * o)), t, !v)._lock = 0, this._tTime = _, !t && this.parent && cn(this, "onRepeat"), this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1), m && m !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this; if (v = this._dur, g = this._tDur, b && (this._lock = 2, m = x ? v : -1e-4, this.render(m, !0), this.vars.repeatRefresh && !f && this.invalidate()), this._lock = 0, !this._ts && !l) return this; Cn(this, f) } } if (this._hasPause && !this._forcing && this._lock < 2 && (c = function (e, t, n) { var i; if (n > t) for (i = e._first; i && i._start <= n;) { if ("isPause" === i.data && i._start > t) return i; i = i._next } else for (i = e._last; i && i._start >= n;) { if ("isPause" === i.data && i._start < t) return i; i = i._prev } }(this, ht(m), ht(i)), c && (_ -= i - (i = c._start))), this._tTime = _, this._time = i, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = e, m = 0), !m && i && !t && !a && (cn(this, "onStart"), this._tTime !== _)) return this; if (i >= m && e >= 0) for (r = this._first; r;) { if (s = r._next, (r._act || i >= r._start) && r._ts && c !== r) { if (r.parent !== this) return this.render(e, t, n); if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, t, n), i !== this._time || !this._ts && !l) { c = 0, s && (_ += this._zTime = -1e-8); break } } r = s } else { r = this._last; for (var E = e < 0 ? e : i; r;) { if (s = r._prev, (r._act || E <= r._end) && r._ts && c !== r) { if (r.parent !== this) return this.render(e, t, n); if (r.render(r._ts > 0 ? (E - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (E - r._start) * r._ts, t, n || te && (r._initted || r._startAt)), i !== this._time || !this._ts && !l) { c = 0, s && (_ += this._zTime = E ? -1e-8 : _e); break } } r = s } } if (c && !t && (this.pause(), c.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1, this._ts)) return this._start = h, Pt(this), this.render(e, t, n); this._onUpdate && !t && cn(this, "onUpdate", !0), (_ === g && this._tTime >= this.totalDuration() || !_ && m) && (h !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((e || !v) && (_ === g && this._ts > 0 || !_ && this._ts < 0) && Mt(this, 1), t || e < 0 && !m || !_ && !m && g || (cn(this, _ === g && e >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(_ < g && this.timeScale() > 0) && this._prom()))) } return this }, n.add = function (e, t) { var n = this; if (Ae(t) || (t = Vt(this, t, e)), !(e instanceof Fn)) { if (Ne(e)) return e.forEach((function (e) { return n.add(e, t) })), this; if (Me(e)) return this.addLabel(e, t); if (!we(e)) return this; e = Yn.delayedCall(0, e) } return this !== e ? Ot(this, e, t) : this }, n.getChildren = function (e, t, n, i) { void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === n && (n = !0), void 0 === i && (i = -ve); for (var r = [], s = this._first; s;)s._start >= i && (s instanceof Yn ? t && r.push(s) : (n && r.push(s), e && r.push.apply(r, s.getChildren(!0, t, n)))), s = s._next; return r }, n.getById = function (e) { for (var t = this.getChildren(1, 1, 1), n = t.length; n--;)if (t[n].vars.id === e) return t[n] }, n.remove = function (e) { return Me(e) ? this.removeLabel(e) : we(e) ? this.killTweensOf(e) : (St(this, e), e === this._recent && (this._recent = this._last), wt(this)) }, n.totalTime = function (t, n) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = ht(En.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))), e.prototype.totalTime.call(this, t, n), this._forcing = 0, this) : this._tTime }, n.addLabel = function (e, t) { return this.labels[e] = Vt(this, t), this }, n.removeLabel = function (e) { return delete this.labels[e], this }, n.addPause = function (e, t, n) { var i = Yn.delayedCall(0, t || Ye, n); return i.data = "isPause", this._hasPause = 1, Ot(this, i, Vt(this, e)) }, n.removePause = function (e) { var t = this._first; for (e = Vt(this, e); t;)t._start === e && "isPause" === t.data && Mt(t), t = t._next }, n.killTweensOf = function (e, t, n) { for (var i = this.getTweensOf(e, n), r = i.length; r--;)Bn !== i[r] && i[r].kill(e, t); return this }, n.getTweensOf = function (e, t) { for (var n, i = [], r = Zt(e), s = this._first, a = Ae(t); s;)s instanceof Yn ? pt(s._targets, r) && (a ? (!Bn || s._initted && s._ts) && s.globalTime(0) <= t && s.globalTime(s.totalDuration()) > t : !t || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, t)).length && i.push.apply(i, n), s = s._next; return i }, n.tweenTo = function (e, t) { t = t || {}; var n, i = this, r = Vt(i, e), s = t, a = s.startAt, o = s.onStart, l = s.onStartParams, c = s.immediateRender, u = Yn.to(i, _t({ ease: t.ease || "none", lazy: !1, immediateRender: !1, time: r, overwrite: "auto", duration: t.duration || Math.abs((r - (a && "time" in a ? a.time : i._time)) / i.timeScale()) || _e, onStart: function () { if (i.pause(), !n) { var e = t.duration || Math.abs((r - (a && "time" in a ? a.time : i._time)) / i.timeScale()); u._dur !== e && zt(u, e, 0, 1).render(u._time, !0, !0), n = 1 } o && o.apply(u, l || []) } }, t)); return c ? u.render(0) : u }, n.tweenFromTo = function (e, t, n) { return this.tweenTo(t, _t({ startAt: { time: Vt(this, e) } }, n)) }, n.recent = function () { return this._recent }, n.nextLabel = function (e) { return void 0 === e && (e = this._time), ln(this, Vt(this, e)) }, n.previousLabel = function (e) { return void 0 === e && (e = this._time), ln(this, Vt(this, e), 1) }, n.currentLabel = function (e) { return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + _e) }, n.shiftChildren = function (e, t, n) { void 0 === n && (n = 0); for (var i, r = this._first, s = this.labels; r;)r._start >= n && (r._start += e, r._end += e), r = r._next; if (t) for (i in s) s[i] >= n && (s[i] += e); return wt(this) }, n.invalidate = function (t) { var n = this._first; for (this._lock = 0; n;)n.invalidate(t), n = n._next; return e.prototype.invalidate.call(this, t) }, n.clear = function (e) { void 0 === e && (e = !0); for (var t, n = this._first; n;)t = n._next, this.remove(n), n = t; return this._dp && (this._time = this._tTime = this._pTime = 0), e && (this.labels = {}), wt(this) }, n.totalDuration = function (e) { var t, n, i, r = 0, s = this, a = s._last, o = ve; if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -e : e)); if (s._dirty) { for (i = s.parent; a;)t = a._prev, a._dirty && a.totalDuration(), (n = a._start) > o && s._sort && a._ts && !s._lock ? (s._lock = 1, Ot(s, a, n - a._delay, 1)._lock = 0) : o = n, n < 0 && a._ts && (r -= n, (!i && !s._dp || i && i.smoothChildTiming) && (s._start += n / s._ts, s._time -= n, s._tTime -= n), s.shiftChildren(-n, !1, -Infinity), o = 0), a._end > r && a._ts && (r = a._end), a = t; zt(s, s === ie && s._time > r ? s._time : r, 1, 1), s._dirty = 0 } return s._tDur }, t.updateRoot = function (e) { if (ie._ts && (mt(ie, Lt(e, ie)), le = En.frame), En.frame >= it) { it += me.autoSleep || 120; var t = ie._first; if ((!t || !t._ts) && me.autoSleep && En._listeners.length < 2) { for (; t && !t._ts;)t = t._next; t || En.sleep() } } }, t }(Fn); _t(Un.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var Bn, kn, zn = function (e, t, n, i, r, s, a) { var o, l, c, u, h, d, p, f, m = new li(this._pt, e, t, 0, 1, ni, null, r), g = 0, v = 0; for (m.b = n, m.e = i, n += "", (p = ~(i += "").indexOf("random(")) && (i = an(i)), s && (s(f = [n, i], e, t), n = f[0], i = f[1]), l = n.match(Be) || []; o = Be.exec(i);)u = o[0], h = i.substring(g, o.index), c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1), u !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = { _next: m._pt, p: h || 1 === v ? h : ",", s: d, c: "=" === u.charAt(1) ? dt(d, u) - d : parseFloat(u) - d, m: c && c < 4 ? Math.round : 0 }, g = Be.lastIndex); return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = a, (ke.test(i) || p) && (m.e = 0), this._pt = m, m }, Hn = function (e, t, n, i, r, s, a, o, l, c) { we(i) && (i = i(r || 0, e, s)); var u, h = e[t], d = "get" !== n ? n : we(h) ? l ? e[t.indexOf("set") || !we(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : h, p = we(h) ? l ? Zn : $n : Kn; if (Me(i) && (~i.indexOf("random(") && (i = an(i)), "=" === i.charAt(1) && ((u = dt(d, i) + (qt(d) || 0)) || 0 === u) && (i = u)), !c || d !== i || kn) return isNaN(d * i) || "" === i ? (!h && !(t in e) && je(t, i), zn.call(this, e, t, d, i, p, o || me.stringFilter, l)) : (u = new li(this._pt, e, t, +d || 0, i - (d || 0), "boolean" == typeof h ? ti : ei, 0, p), l && (u.fp = l), a && u.modifier(a, this, e), this._pt = u) }, Gn = function (e, t, n, i, r, s) { var a, o, l, c; if (tt[e] && !1 !== (a = new tt[e]).init(r, a.rawVars ? t[e] : function (e, t, n, i, r) { if (we(e) && (e = jn(e, r, t, n, i)), !Ce(e) || e.style && e.nodeType || Ne(e) || Ie(e)) return Me(e) ? jn(e, r, t, n, i) : e; var s, a = {}; for (s in e) a[s] = jn(e[s], r, t, n, i); return a }(t[e], i, r, s, n), n, i, s) && (n._pt = o = new li(n._pt, r, e, 0, 1, a.render, a, 0, a.priority), n !== ce)) for (l = n._ptLookup[n._targets.indexOf(r)], c = a._props.length; c--;)l[a._props[c]] = o; return a }, Vn = function e(t, n, i) { var r, s, a, o, l, c, u, h, d, p, f, m, g, v = t.vars, _ = v.ease, y = v.startAt, x = v.immediateRender, b = v.lazy, E = v.onUpdate, T = v.onUpdateParams, S = v.callbackScope, M = v.runBackwards, w = v.yoyoEase, A = v.keyframes, D = v.autoRevert, C = t._dur, R = t._startAt, L = t._targets, P = t.parent, I = P && "nested" === P.data ? P.vars.targets : L, N = "auto" === t._overwrite && !ee, O = t.timeline; if (O && (!A || !_) && (_ = "none"), t._ease = Rn(_, ge.ease), t._yEase = w ? Dn(Rn(!0 === w ? _ : w, ge.ease)) : 0, w && t._yoyo && !t._repeat && (w = t._yEase, t._yEase = t._ease, t._ease = w), t._from = !O && !!v.runBackwards, !O || A && !v.stagger) { if (m = (h = L[0] ? ot(L[0]).harness : 0) && v[h.prop], r = bt(v, Je), R && (R._zTime < 0 && R.progress(1), n < 0 && M && x && !D ? R.render(-1, !0) : R.revert(M && C ? $e : Ke), R._lazy = 0), y) { if (Mt(t._startAt = Yn.set(L, _t({ data: "isStart", overwrite: !1, parent: P, immediateRender: !0, lazy: !R && Re(b), startAt: null, delay: 0, onUpdate: E, onUpdateParams: T, callbackScope: S, stagger: 0 }, y))), t._startAt._dp = 0, t._startAt._sat = t, n < 0 && (te || !x && !D) && t._startAt.revert($e), x && C && n <= 0 && i <= 0) return void (n && (t._zTime = n)) } else if (M && C && !R) if (n && (x = !1), a = _t({ overwrite: !1, data: "isFromStart", lazy: x && !R && Re(b), immediateRender: x, stagger: 0, parent: P }, r), m && (a[h.prop] = m), Mt(t._startAt = Yn.set(L, a)), t._startAt._dp = 0, t._startAt._sat = t, n < 0 && (te ? t._startAt.revert($e) : t._startAt.render(-1, !0)), t._zTime = n, x) { if (!n) return } else e(t._startAt, _e, _e); for (t._pt = t._ptCache = 0, b = C && Re(b) || b && !C, s = 0; s < L.length; s++) { if (u = (l = L[s])._gsap || at(L)[s]._gsap, t._ptLookup[s] = p = {}, et[u.id] && Qe.length && ft(), f = I === L ? s : I.indexOf(l), h && !1 !== (d = new h).init(l, m || r, t, f, I) && (t._pt = o = new li(t._pt, l, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach((function (e) { p[e] = o })), d.priority && (c = 1)), !h || m) for (a in r) tt[a] && (d = Gn(a, r, t, f, l, I)) ? d.priority && (c = 1) : p[a] = o = Hn.call(t, l, a, "get", r[a], f, I, 0, v.stringFilter); t._op && t._op[s] && t.kill(l, t._op[s]), N && t._pt && (Bn = t, ie.killTweensOf(l, p, t.globalTime(n)), g = !t.parent, Bn = 0), t._pt && b && (et[u.id] = 1) } c && oi(t), t._onInit && t._onInit(t) } t._onUpdate = E, t._initted = (!t._op || t._pt) && !g, A && n <= 0 && O.render(ve, !0, !0) }, Wn = function (e, t, n, i) { var r, s, a = t.ease || i || "power1.inOut"; if (Ne(t)) s = n[e] || (n[e] = []), t.forEach((function (e, n) { return s.push({ t: n / (t.length - 1) * 100, v: e, e: a }) })); else for (r in t) s = n[r] || (n[r] = []), "ease" === r || s.push({ t: parseFloat(e), v: t[r], e: a }) }, jn = function (e, t, n, i, r) { return we(e) ? e.call(t, n, i, r) : Me(e) && ~e.indexOf("random(") ? an(e) : e }, Xn = st + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", qn = {}; ct(Xn + ",id,stagger,delay,duration,paused,scrollTrigger", (function (e) { return qn[e] = 1 })); var Yn = function (e) { function t(t, n, i, r) { var s; "number" == typeof n && (i.duration = n, n = i, i = null); var a, o, l, c, u, h, d, p, f = (s = e.call(this, r ? n : Et(n)) || this).vars, m = f.duration, g = f.delay, v = f.immediateRender, _ = f.stagger, y = f.overwrite, x = f.keyframes, b = f.defaults, E = f.scrollTrigger, T = f.yoyoEase, S = n.parent || ie, M = (Ne(t) || Ie(t) ? Ae(t[0]) : "length" in n) ? [t] : Zt(t); if (s._targets = M.length ? at(M) : Xe("GSAP target " + t + " not found. https://greensock.com", !me.nullTargetWarn) || [], s._ptLookup = [], s._overwrite = y, x || _ || Pe(m) || Pe(g)) { if (n = s.vars, (a = s.timeline = new Un({ data: "nested", defaults: b || {}, targets: S && "nested" === S.data ? S.vars.targets : M })).kill(), a.parent = a._dp = J(s), a._start = 0, _ || Pe(m) || Pe(g)) { if (c = M.length, d = _ && en(_), Ce(_)) for (u in _) ~Xn.indexOf(u) && (p || (p = {}), p[u] = _[u]); for (o = 0; o < c; o++)(l = bt(n, qn)).stagger = 0, T && (l.yoyoEase = T), p && yt(l, p), h = M[o], l.duration = +jn(m, J(s), o, h, M), l.delay = (+jn(g, J(s), o, h, M) || 0) - s._delay, !_ && 1 === c && l.delay && (s._delay = g = l.delay, s._start += g, l.delay = 0), a.to(h, l, d ? d(o, h, M) : 0), a._ease = Sn.none; a.duration() ? m = g = 0 : s.timeline = 0 } else if (x) { Et(_t(a.vars.defaults, { ease: "none" })), a._ease = Rn(x.ease || n.ease || "none"); var w, A, D, C = 0; if (Ne(x)) x.forEach((function (e) { return a.to(M, e, ">") })), a.duration(); else { for (u in l = {}, x) "ease" === u || "easeEach" === u || Wn(u, x[u], l, x.easeEach); for (u in l) for (w = l[u].sort((function (e, t) { return e.t - t.t })), C = 0, o = 0; o < w.length; o++)(D = { ease: (A = w[o]).e, duration: (A.t - (o ? w[o - 1].t : 0)) / 100 * m })[u] = A.v, a.to(M, D, C), C += D.duration; a.duration() < m && a.to({}, { duration: m - a.duration() }) } } m || s.duration(m = a.duration()) } else s.timeline = 0; return !0 !== y || ee || (Bn = J(s), ie.killTweensOf(M), Bn = 0), Ot(S, J(s), i), n.reversed && s.reverse(), n.paused && s.paused(!0), (v || !m && !x && s._start === ht(S._time) && Re(v) && Dt(J(s)) && "nested" !== S.data) && (s._tTime = -1e-8, s.render(Math.max(0, -g) || 0)), E && Ft(J(s), E), s } Q(t, e); var n = t.prototype; return n.render = function (e, t, n) { var i, r, s, a, o, l, c, u, h, d = this._time, p = this._tDur, f = this._dur, m = e < 0, g = e > p - _e && !m ? p : e < _e ? 0 : e; if (f) { if (g !== this._tTime || !e || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== m) { if (i = g, u = this.timeline, this._repeat) { if (a = f + this._rDelay, this._repeat < -1 && m) return this.totalTime(100 * a + e, t, n); if (i = ht(g % a), g === p ? (s = this._repeat, i = f) : ((s = ~~(g / a)) && s === g / a && (i = f, s--), i > f && (i = f)), (l = this._yoyo && 1 & s) && (h = this._yEase, i = f - i), o = Rt(this._tTime, a), i === d && !n && this._initted) return this._tTime = g, this; s !== o && (u && this._yEase && Cn(u, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(ht(a * s), !0).invalidate()._lock = 0)) } if (!this._initted) { if (Ut(this, m ? e : i, n, t, g)) return this._tTime = 0, this; if (d !== this._time) return this; if (f !== this._dur) return this.render(e, t, n) } if (this._tTime = g, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (h || this._ease)(i / f), this._from && (this.ratio = c = 1 - c), i && !d && !t && !s && (cn(this, "onStart"), this._tTime !== g)) return this; for (r = this._pt; r;)r.r(c, r.d), r = r._next; u && u.render(e < 0 ? e : !i && l ? -1e-8 : u._dur * u._ease(i / this._dur), t, n) || this._startAt && (this._zTime = e), this._onUpdate && !t && (m && At(this, e, 0, n), cn(this, "onUpdate")), this._repeat && s !== o && this.vars.onRepeat && !t && this.parent && cn(this, "onRepeat"), g !== this._tDur && g || this._tTime !== g || (m && !this._onUpdate && At(this, e, 0, !0), (e || !f) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && Mt(this, 1), t || m && !d || !(g || d || l) || (cn(this, g === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(g < p && this.timeScale() > 0) && this._prom())) } } else !function (e, t, n, i) { var r, s, a, o = e.ratio, l = t < 0 || !t && (!e._start && Bt(e) && (e._initted || !kt(e)) || (e._ts < 0 || e._dp._ts < 0) && !kt(e)) ? 0 : 1, c = e._rDelay, u = 0; if (c && e._repeat && (u = Xt(0, e._tDur, t), s = Rt(u, c), e._yoyo && 1 & s && (l = 1 - l), s !== Rt(e._tTime, c) && (o = 1 - l, e.vars.repeatRefresh && e._initted && e.invalidate())), l !== o || te || i || e._zTime === _e || !t && e._zTime) { if (!e._initted && Ut(e, t, i, n, u)) return; for (a = e._zTime, e._zTime = t || (n ? _e : 0), n || (n = t && !a), e.ratio = l, e._from && (l = 1 - l), e._time = 0, e._tTime = u, r = e._pt; r;)r.r(l, r.d), r = r._next; t < 0 && At(e, t, 0, !0), e._onUpdate && !n && cn(e, "onUpdate"), u && e._repeat && !n && e.parent && cn(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === l && (l && Mt(e, 1), n || te || (cn(e, l ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom())) } else e._zTime || (e._zTime = t) }(this, e, t, n); return this }, n.targets = function () { return this._targets }, n.invalidate = function (t) { return (!t || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(t), e.prototype.invalidate.call(this, t) }, n.resetTo = function (e, t, n, i) { ue || En.wake(), this._ts || this.play(); var r = Math.min(this._dur, (this._dp._time - this._start) * this._ts); return this._initted || Vn(this, r), function (e, t, n, i, r, s, a) { var o, l, c, u, h = (e._pt && e._ptCache || (e._ptCache = {}))[t]; if (!h) for (h = e._ptCache[t] = [], c = e._ptLookup, u = e._targets.length; u--;) { if ((o = c[u][t]) && o.d && o.d._pt) for (o = o.d._pt; o && o.p !== t && o.fp !== t;)o = o._next; if (!o) return kn = 1, e.vars[t] = "+=0", Vn(e, a), kn = 0, 1; h.push(o) } for (u = h.length; u--;)(o = (l = h[u])._pt || l).s = !i && 0 !== i || r ? o.s + (i || 0) + s * o.c : i, o.c = n - o.s, l.e && (l.e = ut(n) + qt(l.e)), l.b && (l.b = o.s + qt(l.b)) }(this, e, t, n, i, this._ease(r / this._dur), r) ? this.resetTo(e, t, n, i) : (It(this, 0), this.parent || Tt(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0)) }, n.kill = function (e, t) { if (void 0 === t && (t = "all"), !(e || t && "all" !== t)) return this._lazy = this._pt = 0, this.parent ? un(this) : this; if (this.timeline) { var n = this.timeline.totalDuration(); return this.timeline.killTweensOf(e, t, Bn && !0 !== Bn.vars.overwrite)._first || un(this), this.parent && n !== this.timeline.totalDuration() && zt(this, this._dur * this.timeline._tDur / n, 0, 1), this } var i, r, s, a, o, l, c, u = this._targets, h = e ? Zt(e) : u, d = this._ptLookup, p = this._pt; if ((!t || "all" === t) && function (e, t) { for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n];); return n < 0 }(u, h)) return "all" === t && (this._pt = 0), un(this); for (i = this._op = this._op || [], "all" !== t && (Me(t) && (o = {}, ct(t, (function (e) { return o[e] = 1 })), t = o), t = function (e, t) { var n, i, r, s, a = e[0] ? ot(e[0]).harness : 0, o = a && a.aliases; if (!o) return t; for (i in n = yt({}, t), o) if (i in n) for (r = (s = o[i].split(",")).length; r--;)n[s[r]] = n[i]; return n }(u, t)), c = u.length; c--;)if (~h.indexOf(u[c])) for (o in r = d[c], "all" === t ? (i[c] = t, a = r, s = {}) : (s = i[c] = i[c] || {}, a = t), a) (l = r && r[o]) && ("kill" in l.d && !0 !== l.d.kill(o) || St(this, l, "_pt"), delete r[o]), "all" !== s && (s[o] = 1); return this._initted && !this._pt && p && un(this), this }, t.to = function (e, n) { return new t(e, n, arguments[2]) }, t.from = function (e, t) { return Wt(1, arguments) }, t.delayedCall = function (e, n, i, r) { return new t(n, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: e, onComplete: n, onReverseComplete: n, onCompleteParams: i, onReverseCompleteParams: i, callbackScope: r }) }, t.fromTo = function (e, t, n) { return Wt(2, arguments) }, t.set = function (e, n) { return n.duration = 0, n.repeatDelay || (n.repeat = 0), new t(e, n) }, t.killTweensOf = function (e, t, n) { return ie.killTweensOf(e, t, n) }, t }(Fn); _t(Yn.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }), ct("staggerTo,staggerFrom,staggerFromTo", (function (e) { Yn[e] = function () { var t = new Un, n = Yt.call(arguments, 0); return n.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, n) } })); var Kn = function (e, t, n) { return e[t] = n }, $n = function (e, t, n) { return e[t](n) }, Zn = function (e, t, n, i) { return e[t](i.fp, n) }, Jn = function (e, t, n) { return e.setAttribute(t, n) }, Qn = function (e, t) { return we(e[t]) ? $n : De(e[t]) && e.setAttribute ? Jn : Kn }, ei = function (e, t) { return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t) }, ti = function (e, t) { return t.set(t.t, t.p, !!(t.s + t.c * e), t) }, ni = function (e, t) { var n = t._pt, i = ""; if (!e && t.b) i = t.b; else if (1 === e && t.e) i = t.e; else { for (; n;)i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round(1e4 * (n.s + n.c * e)) / 1e4) + i, n = n._next; i += t.c } t.set(t.t, t.p, i, t) }, ii = function (e, t) { for (var n = t._pt; n;)n.r(e, n.d), n = n._next }, ri = function (e, t, n, i) { for (var r, s = this._pt; s;)r = s._next, s.p === i && s.modifier(e, t, n), s = r }, si = function (e) { for (var t, n, i = this._pt; i;)n = i._next, i.p === e && !i.op || i.op === e ? St(this, i, "_pt") : i.dep || (t = 1), i = n; return !t }, ai = function (e, t, n, i) { i.mSet(e, t, i.m.call(i.tween, n, i.mt), i) }, oi = function (e) { for (var t, n, i, r, s = e._pt; s;) { for (t = s._next, n = i; n && n.pr > s.pr;)n = n._next; (s._prev = n ? n._prev : r) ? s._prev._next = s : i = s, (s._next = n) ? n._prev = s : r = s, s = t } e._pt = i }, li = function () { function e(e, t, n, i, r, s, a, o, l) { this.t = t, this.s = i, this.c = r, this.p = n, this.r = s || ei, this.d = a || this, this.set = o || Kn, this.pr = l || 0, this._next = e, e && (e._prev = this) } return e.prototype.modifier = function (e, t, n) { this.mSet = this.mSet || this.set, this.set = ai, this.m = e, this.mt = n, this.tween = t }, e }(); ct(st + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (e) { return Je[e] = 1 })), Ge.TweenMax = Ge.TweenLite = Yn, Ge.TimelineLite = Ge.TimelineMax = Un, ie = new Un({ sortChildren: !1, defaults: ge, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }), me.stringFilter = bn; var ci = [], ui = {}, hi = [], di = 0, pi = function (e) { return (ui[e] || hi).map((function (e) { return e() })) }, fi = function () { var e = Date.now(), t = []; e - di > 2 && (pi("matchMediaInit"), ci.forEach((function (e) { var n, i, r, s, a = e.queries, o = e.conditions; for (i in a) (n = re.matchMedia(a[i]).matches) && (r = 1), n !== o[i] && (o[i] = n, s = 1); s && (e.revert(), r && t.push(e)) })), pi("matchMediaRevert"), t.forEach((function (e) { return e.onMatch(e) })), di = e, pi("matchMedia")) }, mi = function () { function e(e, t) { this.selector = t && Jt(t), this.data = [], this._r = [], this.isReverted = !1, e && this.add(e) } var t = e.prototype; return t.add = function (e, t, n) { we(e) && (n = t, t = e, e = we); var i = this, r = function () { var e, r = ne, s = i.selector; return r && r !== i && r.data.push(i), n && (i.selector = Jt(n)), ne = i, e = t.apply(i, arguments), we(e) && i._r.push(e), ne = r, i.selector = s, i.isReverted = !1, e }; return i.last = r, e === we ? r(i) : e ? i[e] = r : r }, t.ignore = function (e) { var t = ne; ne = null, e(this), ne = t }, t.getTweens = function () { var t = []; return this.data.forEach((function (n) { return n instanceof e ? t.push.apply(t, n.getTweens()) : n instanceof Yn && !(n.parent && "nested" === n.parent.data) && t.push(n) })), t }, t.clear = function () { this._r.length = this.data.length = 0 }, t.kill = function (e, t) { var n = this; if (e) { var i = this.getTweens(); this.data.forEach((function (e) { "isFlip" === e.data && (e.revert(), e.getChildren(!0, !0, !1).forEach((function (e) { return i.splice(i.indexOf(e), 1) }))) })), i.map((function (e) { return { g: e.globalTime(0), t: e } })).sort((function (e, t) { return t.g - e.g || -1 })).forEach((function (t) { return t.t.revert(e) })), this.data.forEach((function (t) { return !(t instanceof Fn) && t.revert && t.revert(e) })), this._r.forEach((function (t) { return t(e, n) })), this.isReverted = !0 } else this.data.forEach((function (e) { return e.kill && e.kill() })); if (this.clear(), t) { var r = ci.indexOf(this); ~r && ci.splice(r, 1) } }, t.revert = function (e) { this.kill(e || {}) }, e }(), gi = function () { function e(e) { this.contexts = [], this.scope = e } var t = e.prototype; return t.add = function (e, t, n) { Ce(e) || (e = { matches: e }); var i, r, s, a = new mi(0, n || this.scope), o = a.conditions = {}; for (r in this.contexts.push(a), t = a.add("onMatch", t), a.queries = e, e) "all" === r ? s = 1 : (i = re.matchMedia(e[r])) && (ci.indexOf(a) < 0 && ci.push(a), (o[r] = i.matches) && (s = 1), i.addListener ? i.addListener(fi) : i.addEventListener("change", fi)); return s && t(a), this }, t.revert = function (e) { this.kill(e || {}) }, t.kill = function (e) { this.contexts.forEach((function (t) { return t.kill(e, !0) })) }, e }(), vi = { registerPlugin: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; t.forEach((function (e) { return dn(e) })) }, timeline: function (e) { return new Un(e) }, getTweensOf: function (e, t) { return ie.getTweensOf(e, t) }, getProperty: function (e, t, n, i) { Me(e) && (e = Zt(e)[0]); var r = ot(e || {}).get, s = n ? vt : gt; return "native" === n && (n = ""), e ? t ? s((tt[t] && tt[t].get || r)(e, t, n, i)) : function (t, n, i) { return s((tt[t] && tt[t].get || r)(e, t, n, i)) } : e }, quickSetter: function (e, t, n) { if ((e = Zt(e)).length > 1) { var i = e.map((function (e) { return xi.quickSetter(e, t, n) })), r = i.length; return function (e) { for (var t = r; t--;)i[t](e) } } e = e[0] || {}; var s = tt[t], a = ot(e), o = a.harness && (a.harness.aliases || {})[t] || t, l = s ? function (t) { var i = new s; ce._pt = 0, i.init(e, n ? t + n : t, ce, 0, [e]), i.render(1, i), ce._pt && ii(1, ce) } : a.set(e, o); return s ? l : function (t) { return l(e, o, n ? t + n : t, a, 1) } }, quickTo: function (e, t, n) { var i, r = xi.to(e, yt(((i = {})[t] = "+=0.1", i.paused = !0, i), n || {})), s = function (e, n, i) { return r.resetTo(t, e, n, i) }; return s.tween = r, s }, isTweening: function (e) { return ie.getTweensOf(e, !0).length > 0 }, defaults: function (e) { return e && e.ease && (e.ease = Rn(e.ease, ge.ease)), xt(ge, e || {}) }, config: function (e) { return xt(me, e || {}) }, registerEffect: function (e) { var t = e.name, n = e.effect, i = e.plugins, r = e.defaults, s = e.extendTimeline; (i || "").split(",").forEach((function (e) { return e && !tt[e] && !Ge[e] && Xe(t + " effect requires " + e + " plugin.") })), nt[t] = function (e, t, i) { return n(Zt(e), _t(t || {}, r), i) }, s && (Un.prototype[t] = function (e, n, i) { return this.add(nt[t](e, Ce(n) ? n : (i = n) && {}, this), i) }) }, registerEase: function (e, t) { Sn[e] = Rn(t) }, parseEase: function (e, t) { return arguments.length ? Rn(e, t) : Sn }, getById: function (e) { return ie.getById(e) }, exportRoot: function (e, t) { void 0 === e && (e = {}); var n, i, r = new Un(e); for (r.smoothChildTiming = Re(e.smoothChildTiming), ie.remove(r), r._dp = 0, r._time = r._tTime = ie._time, n = ie._first; n;)i = n._next, !t && !n._dur && n instanceof Yn && n.vars.onComplete === n._targets[0] || Ot(r, n, n._start - n._delay), n = i; return Ot(ie, r, 0), r }, context: function (e, t) { return e ? new mi(e, t) : ne }, matchMedia: function (e) { return new gi(e) }, matchMediaRefresh: function () { return ci.forEach((function (e) { var t, n, i = e.conditions; for (n in i) i[n] && (i[n] = !1, t = 1); t && e.revert() })) || fi() }, addEventListener: function (e, t) { var n = ui[e] || (ui[e] = []); ~n.indexOf(t) || n.push(t) }, removeEventListener: function (e, t) { var n = ui[e], i = n && n.indexOf(t); i >= 0 && n.splice(i, 1) }, utils: { wrap: function e(t, n, i) { var r = n - t; return Ne(t) ? sn(t, e(0, t.length), n) : jt(i, (function (e) { return (r + (e - t) % r) % r + t })) }, wrapYoyo: function e(t, n, i) { var r = n - t, s = 2 * r; return Ne(t) ? sn(t, e(0, t.length - 1), n) : jt(i, (function (e) { return t + ((e = (s + (e - t) % s) % s || 0) > r ? s - e : e) })) }, distribute: en, random: rn, snap: nn, normalize: function (e, t, n) { return on(e, t, 0, 1, n) }, getUnit: qt, clamp: function (e, t, n) { return jt(n, (function (n) { return Xt(e, t, n) })) }, splitColor: gn, toArray: Zt, selector: Jt, mapRange: on, pipe: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return function (e) { return t.reduce((function (e, t) { return t(e) }), e) } }, unitize: function (e, t) { return function (n) { return e(parseFloat(n)) + (t || qt(n)) } }, interpolate: function e(t, n, i, r) { var s = isNaN(t + n) ? 0 : function (e) { return (1 - e) * t + e * n }; if (!s) { var a, o, l, c, u, h = Me(t), d = {}; if (!0 === i && (r = 1) && (i = null), h) t = { p: t }, n = { p: n }; else if (Ne(t) && !Ne(n)) { for (l = [], c = t.length, u = c - 2, o = 1; o < c; o++)l.push(e(t[o - 1], t[o])); c--, s = function (e) { e *= c; var t = Math.min(u, ~~e); return l[t](e - t) }, i = n } else r || (t = yt(Ne(t) ? [] : {}, t)); if (!l) { for (a in n) Hn.call(d, t, a, "get", n[a]); s = function (e) { return ii(e, d) || (h ? t.p : t) } } } return jt(i, s) }, shuffle: Qt }, install: We, effects: nt, ticker: En, updateRoot: Un.updateRoot, plugins: tt, globalTimeline: ie, core: { PropTween: li, globals: qe, Tween: Yn, Timeline: Un, Animation: Fn, getCache: ot, _removeLinkedListItem: St, reverting: function () { return te }, context: function (e) { return e && ne && (ne.data.push(e), e._ctx = ne), ne }, suppressOverwrites: function (e) { return ee = e } } }; ct("to,from,fromTo,delayedCall,set,killTweensOf", (function (e) { return vi[e] = Yn[e] })), En.add(Un.updateRoot), ce = vi.to({}, { duration: 0 }); var _i = function (e, t) { for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;)n = n._next; return n }, yi = function (e, t) { return { name: e, rawVars: 1, init: function (e, n, i) { i._onInit = function (e) { var i, r; if (Me(n) && (i = {}, ct(n, (function (e) { return i[e] = 1 })), n = i), t) { for (r in i = {}, n) i[r] = t(n[r]); n = i } !function (e, t) { var n, i, r, s = e._targets; for (n in t) for (i = s.length; i--;)(r = e._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = _i(r, n)), r && r.modifier && r.modifier(t[n], e, s[i], n)) }(e, n) } } } }, xi = vi.registerPlugin({ name: "attr", init: function (e, t, n, i, r) { var s, a, o; for (s in this.tween = n, t) o = e.getAttribute(s) || "", (a = this.add(e, "setAttribute", (o || 0) + "", t[s], i, r, 0, 0, s)).op = s, a.b = o, this._props.push(s) }, render: function (e, t) { for (var n = t._pt; n;)te ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next } }, { name: "endArray", init: function (e, t) { for (var n = t.length; n--;)this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1) } }, yi("roundProps", tn), yi("modifiers"), yi("snap", nn)) || vi; Yn.version = Un.version = xi.version = "3.11.5", oe = 1, Le() && Tn(); Sn.Power0, Sn.Power1, Sn.Power2, Sn.Power3, Sn.Power4, Sn.Linear, Sn.Quad, Sn.Cubic, Sn.Quart, Sn.Quint, Sn.Strong, Sn.Elastic, Sn.Back, Sn.SteppedEase, Sn.Bounce, Sn.Sine, Sn.Expo, Sn.Circ; var bi, Ei, Ti, Si, Mi, wi, Ai, Di, Ci = {}, Ri = 180 / Math.PI, Li = Math.PI / 180, Pi = Math.atan2, Ii = /([A-Z])/g, Ni = /(left|right|width|margin|padding|x)/i, Oi = /[\s,\(]\S/, Fi = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, Ui = function (e, t) { return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t) }, Bi = function (e, t) { return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t) }, ki = function (e, t) { return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t) }, zi = function (e, t) { var n = t.s + t.c * e; t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t) }, Hi = function (e, t) { return t.set(t.t, t.p, e ? t.e : t.b, t) }, Gi = function (e, t) { return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t) }, Vi = function (e, t, n) { return e.style[t] = n }, Wi = function (e, t, n) { return e.style.setProperty(t, n) }, ji = function (e, t, n) { return e._gsap[t] = n }, Xi = function (e, t, n) { return e._gsap.scaleX = e._gsap.scaleY = n }, qi = function (e, t, n, i, r) { var s = e._gsap; s.scaleX = s.scaleY = n, s.renderTransform(r, s) }, Yi = function (e, t, n, i, r) { var s = e._gsap; s[t] = n, s.renderTransform(r, s) }, Ki = "transform", $i = Ki + "Origin", Zi = function e(t, n) { var i = this, r = this.target, s = r.style; if (t in Ci) { if (this.tfm = this.tfm || {}, "transform" === t) return Fi.transform.split(",").forEach((function (t) { return e.call(i, t, n) })); if (~(t = Fi[t] || t).indexOf(",") ? t.split(",").forEach((function (e) { return i.tfm[e] = mr(r, e) })) : this.tfm[t] = r._gsap.x ? r._gsap[t] : mr(r, t), this.props.indexOf(Ki) >= 0) return; r._gsap.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push($i, n, "")), t = Ki } (s || n) && this.props.push(t, n, s[t]) }, Ji = function (e) { e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate")) }, Qi = function () { var e, t, n = this.props, i = this.target, r = i.style, s = i._gsap; for (e = 0; e < n.length; e += 3)n[e + 1] ? i[n[e]] = n[e + 2] : n[e + 2] ? r[n[e]] = n[e + 2] : r.removeProperty("--" === n[e].substr(0, 2) ? n[e] : n[e].replace(Ii, "-$1").toLowerCase()); if (this.tfm) { for (t in this.tfm) s[t] = this.tfm[t]; s.svg && (s.renderTransform(), i.setAttribute("data-svg-origin", this.svgo || "")), (e = Ai()) && e.isStart || r[Ki] || (Ji(r), s.uncache = 1) } }, er = function (e, t) { var n = { target: e, props: [], revert: Qi, save: Zi }; return e._gsap || xi.core.getCache(e), t && t.split(",").forEach((function (e) { return n.save(e) })), n }, tr = function (e, t) { var n = Ei.createElementNS ? Ei.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Ei.createElement(e); return n.style ? n : Ei.createElement(e) }, nr = function e(t, n, i) { var r = getComputedStyle(t); return r[n] || r.getPropertyValue(n.replace(Ii, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && e(t, rr(n) || n, 1) || "" }, ir = "O,Moz,ms,Ms,Webkit".split(","), rr = function (e, t, n) { var i = (t || Mi).style, r = 5; if (e in i && !n) return e; for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(ir[r] + e in i);); return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? ir[r] : "") + e }, sr = function () { "undefined" != typeof window && window.document && (bi = window, Ei = bi.document, Ti = Ei.documentElement, Mi = tr("div") || { style: {} }, tr("div"), Ki = rr(Ki), $i = Ki + "Origin", Mi.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Di = !!rr("perspective"), Ai = xi.core.reverting, Si = 1) }, ar = function e(t) { var n, i = tr("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, a = this.style.cssText; if (Ti.appendChild(i), i.appendChild(this), this.style.display = "block", t) try { n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = e } catch (e) { } else this._gsapBBox && (n = this._gsapBBox()); return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), Ti.removeChild(i), this.style.cssText = a, n }, or = function (e, t) { for (var n = t.length; n--;)if (e.hasAttribute(t[n])) return e.getAttribute(t[n]) }, lr = function (e) { var t; try { t = e.getBBox() } catch (n) { t = ar.call(e, !0) } return t && (t.width || t.height) || e.getBBox === ar || (t = ar.call(e, !0)), !t || t.width || t.x || t.y ? t : { x: +or(e, ["x", "cx", "x1"]) || 0, y: +or(e, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } }, cr = function (e) { return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !lr(e)) }, ur = function (e, t) { if (t) { var n = e.style; t in Ci && t !== $i && (t = Ki), n.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), n.removeProperty(t.replace(Ii, "-$1").toLowerCase())) : n.removeAttribute(t) } }, hr = function (e, t, n, i, r, s) { var a = new li(e._pt, t, n, 0, 1, s ? Gi : Hi); return e._pt = a, a.b = i, a.e = r, e._props.push(n), a }, dr = { deg: 1, rad: 1, turn: 1 }, pr = { grid: 1, flex: 1 }, fr = function e(t, n, i, r) { var s, a, o, l, c = parseFloat(i) || 0, u = (i + "").trim().substr((c + "").length) || "px", h = Mi.style, d = Ni.test(n), p = "svg" === t.tagName.toLowerCase(), f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r; return r === u || !c || dr[r] || dr[u] ? c : ("px" !== u && !g && (c = e(t, n, i, "px")), l = t.getCTM && cr(t), !v && "%" !== u || !Ci[n] && !~n.indexOf("adius") ? (h[d ? "width" : "height"] = m + (g ? u : r), a = ~n.indexOf("adius") || "em" === r && t.appendChild && !p ? t : t.parentNode, l && (a = (t.ownerSVGElement || {}).parentNode), a && a !== Ei && a.appendChild || (a = Ei.body), (o = a._gsap) && v && o.width && d && o.time === En.time && !o.uncache ? ut(c / o.width * m) : ((v || "%" === u) && !pr[nr(a, "display")] && (h.position = nr(t, "position")), a === t && (h.position = "static"), a.appendChild(Mi), s = Mi[f], a.removeChild(Mi), h.position = "absolute", d && v && ((o = ot(a)).time = En.time, o.width = a[f]), ut(g ? s * c / m : s && c ? m / s * c : 0))) : (s = l ? t.getBBox()[d ? "width" : "height"] : t[f], ut(v ? c / s * m : c / 100 * s))) }, mr = function (e, t, n, i) { var r; return Si || sr(), t in Fi && "transform" !== t && ~(t = Fi[t]).indexOf(",") && (t = t.split(",")[0]), Ci[t] && "transform" !== t ? (r = wr(e, i), r = "transformOrigin" !== t ? r[t] : r.svg ? r.origin : Ar(nr(e, $i)) + " " + r.zOrigin + "px") : (!(r = e.style[t]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = yr[t] && yr[t](e, t, n) || nr(e, t) || lt(e, t) || ("opacity" === t ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? fr(e, t, r, n) + n : r }, gr = function (e, t, n, i) { if (!n || "none" === n) { var r = rr(t, e, 1), s = r && nr(e, r, 1); s && s !== n ? (t = r, n = s) : "borderColor" === t && (n = nr(e, "borderTopColor")) } var a, o, l, c, u, h, d, p, f, m, g, v = new li(this._pt, e.style, t, 0, 1, ni), _ = 0, y = 0; if (v.b = n, v.e = i, n += "", "auto" === (i += "") && (e.style[t] = i, i = nr(e, t) || i, e.style[t] = n), bn(a = [n, i]), i = a[1], l = (n = a[0]).match(Ue) || [], (i.match(Ue) || []).length) { for (; o = Ue.exec(i);)d = o[0], f = i.substring(_, o.index), u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1), d !== (h = l[y++] || "") && (c = parseFloat(h) || 0, g = h.substr((c + "").length), "=" === d.charAt(1) && (d = dt(c, d) + g), p = parseFloat(d), m = d.substr((p + "").length), _ = Ue.lastIndex - m.length, m || (m = m || me.units[t] || g, _ === i.length && (i += m, v.e += m)), g !== m && (c = fr(e, t, h, m) || 0), v._pt = { _next: v._pt, p: f || 1 === y ? f : ",", s: c, c: p - c, m: u && u < 4 || "zIndex" === t ? Math.round : 0 }); v.c = _ < i.length ? i.substring(_, i.length) : "" } else v.r = "display" === t && "none" === i ? Gi : Hi; return ke.test(i) && (v.e = 0), this._pt = v, v }, vr = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, _r = function (e, t) { if (t.tween && t.tween._time === t.tween._dur) { var n, i, r, s = t.t, a = s.style, o = t.u, l = s._gsap; if ("all" === o || !0 === o) a.cssText = "", i = 1; else for (r = (o = o.split(",")).length; --r > -1;)n = o[r], Ci[n] && (i = 1, n = "transformOrigin" === n ? $i : Ki), ur(s, n); i && (ur(s, Ki), l && (l.svg && s.removeAttribute("transform"), wr(s, 1), l.uncache = 1, Ji(a))) } }, yr = { clearProps: function (e, t, n, i, r) { if ("isFromStart" !== r.data) { var s = e._pt = new li(e._pt, t, n, 0, 0, _r); return s.u = i, s.pr = -10, s.tween = r, e._props.push(n), 1 } } }, xr = [1, 0, 0, 1, 0, 0], br = {}, Er = function (e) { return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e }, Tr = function (e) { var t = nr(e, Ki); return Er(t) ? xr : t.substr(7).match(Fe).map(ut) }, Sr = function (e, t) { var n, i, r, s, a = e._gsap || ot(e), o = e.style, l = Tr(e); return a.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? xr : l : (l !== xr || e.offsetParent || e === Ti || a.svg || (r = o.display, o.display = "block", (n = e.parentNode) && e.offsetParent || (s = 1, i = e.nextElementSibling, Ti.appendChild(e)), l = Tr(e), r ? o.display = r : ur(e, "display"), s && (i ? n.insertBefore(e, i) : n ? n.appendChild(e) : Ti.removeChild(e))), t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l) }, Mr = function (e, t, n, i, r, s) { var a, o, l, c = e._gsap, u = r || Sr(e, !0), h = c.xOrigin || 0, d = c.yOrigin || 0, p = c.xOffset || 0, f = c.yOffset || 0, m = u[0], g = u[1], v = u[2], _ = u[3], y = u[4], x = u[5], b = t.split(" "), E = parseFloat(b[0]) || 0, T = parseFloat(b[1]) || 0; n ? u !== xr && (o = m * _ - g * v) && (l = E * (-g / o) + T * (m / o) - (m * x - g * y) / o, E = E * (_ / o) + T * (-v / o) + (v * x - _ * y) / o, T = l) : (E = (a = lr(e)).x + (~b[0].indexOf("%") ? E / 100 * a.width : E), T = a.y + (~(b[1] || b[0]).indexOf("%") ? T / 100 * a.height : T)), i || !1 !== i && c.smooth ? (y = E - h, x = T - d, c.xOffset = p + (y * m + x * v) - y, c.yOffset = f + (y * g + x * _) - x) : c.xOffset = c.yOffset = 0, c.xOrigin = E, c.yOrigin = T, c.smooth = !!i, c.origin = t, c.originIsAbsolute = !!n, e.style[$i] = "0px 0px", s && (hr(s, c, "xOrigin", h, E), hr(s, c, "yOrigin", d, T), hr(s, c, "xOffset", p, c.xOffset), hr(s, c, "yOffset", f, c.yOffset)), e.setAttribute("data-svg-origin", E + " " + T) }, wr = function (e, t) { var n = e._gsap || new On(e); if ("x" in n && !t && !n.uncache) return n; var i, r, s, a, o, l, c, u, h, d, p, f, m, g, v, _, y, x, b, E, T, S, M, w, A, D, C, R, L, P, I, N, O = e.style, F = n.scaleX < 0, U = "px", B = "deg", k = getComputedStyle(e), z = nr(e, $i) || "0"; return i = r = s = l = c = u = h = d = p = 0, a = o = 1, n.svg = !(!e.getCTM || !cr(e)), k.translate && ("none" === k.translate && "none" === k.scale && "none" === k.rotate || (O[Ki] = ("none" !== k.translate ? "translate3d(" + (k.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== k.rotate ? "rotate(" + k.rotate + ") " : "") + ("none" !== k.scale ? "scale(" + k.scale.split(" ").join(",") + ") " : "") + ("none" !== k[Ki] ? k[Ki] : "")), O.scale = O.rotate = O.translate = "none"), g = Sr(e, n.svg), n.svg && (n.uncache ? (A = e.getBBox(), z = n.xOrigin - A.x + "px " + (n.yOrigin - A.y) + "px", w = "") : w = !t && e.getAttribute("data-svg-origin"), Mr(e, w || z, !!w || n.originIsAbsolute, !1 !== n.smooth, g)), f = n.xOrigin || 0, m = n.yOrigin || 0, g !== xr && (x = g[0], b = g[1], E = g[2], T = g[3], i = S = g[4], r = M = g[5], 6 === g.length ? (a = Math.sqrt(x * x + b * b), o = Math.sqrt(T * T + E * E), l = x || b ? Pi(b, x) * Ri : 0, (h = E || T ? Pi(E, T) * Ri + l : 0) && (o *= Math.abs(Math.cos(h * Li))), n.svg && (i -= f - (f * x + m * E), r -= m - (f * b + m * T))) : (N = g[6], P = g[7], C = g[8], R = g[9], L = g[10], I = g[11], i = g[12], r = g[13], s = g[14], c = (v = Pi(N, L)) * Ri, v && (w = S * (_ = Math.cos(-v)) + C * (y = Math.sin(-v)), A = M * _ + R * y, D = N * _ + L * y, C = S * -y + C * _, R = M * -y + R * _, L = N * -y + L * _, I = P * -y + I * _, S = w, M = A, N = D), u = (v = Pi(-E, L)) * Ri, v && (_ = Math.cos(-v), I = T * (y = Math.sin(-v)) + I * _, x = w = x * _ - C * y, b = A = b * _ - R * y, E = D = E * _ - L * y), l = (v = Pi(b, x)) * Ri, v && (w = x * (_ = Math.cos(v)) + b * (y = Math.sin(v)), A = S * _ + M * y, b = b * _ - x * y, M = M * _ - S * y, x = w, S = A), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, u = 180 - u), a = ut(Math.sqrt(x * x + b * b + E * E)), o = ut(Math.sqrt(M * M + N * N)), v = Pi(S, M), h = Math.abs(v) > 2e-4 ? v * Ri : 0, p = I ? 1 / (I < 0 ? -I : I) : 0), n.svg && (w = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !Er(nr(e, Ki)), w && e.setAttribute("transform", w))), Math.abs(h) > 90 && Math.abs(h) < 270 && (F ? (a *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (o *= -1, h += h <= 0 ? 180 : -180)), t = t || n.uncache, n.x = i - ((n.xPercent = i && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + U, n.y = r - ((n.yPercent = r && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + U, n.z = s + U, n.scaleX = ut(a), n.scaleY = ut(o), n.rotation = ut(l) + B, n.rotationX = ut(c) + B, n.rotationY = ut(u) + B, n.skewX = h + B, n.skewY = d + B, n.transformPerspective = p + U, (n.zOrigin = parseFloat(z.split(" ")[2]) || 0) && (O[$i] = Ar(z)), n.xOffset = n.yOffset = 0, n.force3D = me.force3D, n.renderTransform = n.svg ? Nr : Di ? Ir : Cr, n.uncache = 0, n }, Ar = function (e) { return (e = e.split(" "))[0] + " " + e[1] }, Dr = function (e, t, n) { var i = qt(t); return ut(parseFloat(t) + parseFloat(fr(e, "x", n + "px", i))) + i }, Cr = function (e, t) { t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, Ir(e, t) }, Rr = "0deg", Lr = "0px", Pr = ") ", Ir = function (e, t) { var n = t || this, i = n.xPercent, r = n.yPercent, s = n.x, a = n.y, o = n.z, l = n.rotation, c = n.rotationY, u = n.rotationX, h = n.skewX, d = n.skewY, p = n.scaleX, f = n.scaleY, m = n.transformPerspective, g = n.force3D, v = n.target, _ = n.zOrigin, y = "", x = "auto" === g && e && 1 !== e || !0 === g; if (_ && (u !== Rr || c !== Rr)) { var b, E = parseFloat(c) * Li, T = Math.sin(E), S = Math.cos(E); E = parseFloat(u) * Li, b = Math.cos(E), s = Dr(v, s, T * b * -_), a = Dr(v, a, -Math.sin(E) * -_), o = Dr(v, o, S * b * -_ + _) } m !== Lr && (y += "perspective(" + m + Pr), (i || r) && (y += "translate(" + i + "%, " + r + "%) "), (x || s !== Lr || a !== Lr || o !== Lr) && (y += o !== Lr || x ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + Pr), l !== Rr && (y += "rotate(" + l + Pr), c !== Rr && (y += "rotateY(" + c + Pr), u !== Rr && (y += "rotateX(" + u + Pr), h === Rr && d === Rr || (y += "skew(" + h + ", " + d + Pr), 1 === p && 1 === f || (y += "scale(" + p + ", " + f + Pr), v.style[Ki] = y || "translate(0, 0)" }, Nr = function (e, t) { var n, i, r, s, a, o = t || this, l = o.xPercent, c = o.yPercent, u = o.x, h = o.y, d = o.rotation, p = o.skewX, f = o.skewY, m = o.scaleX, g = o.scaleY, v = o.target, _ = o.xOrigin, y = o.yOrigin, x = o.xOffset, b = o.yOffset, E = o.forceCSS, T = parseFloat(u), S = parseFloat(h); d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= Li, p *= Li, n = Math.cos(d) * m, i = Math.sin(d) * m, r = Math.sin(d - p) * -g, s = Math.cos(d - p) * g, p && (f *= Li, a = Math.tan(p - f), r *= a = Math.sqrt(1 + a * a), s *= a, f && (a = Math.tan(f), n *= a = Math.sqrt(1 + a * a), i *= a)), n = ut(n), i = ut(i), r = ut(r), s = ut(s)) : (n = m, s = g, i = r = 0), (T && !~(u + "").indexOf("px") || S && !~(h + "").indexOf("px")) && (T = fr(v, "x", u, "px"), S = fr(v, "y", h, "px")), (_ || y || x || b) && (T = ut(T + _ - (_ * n + y * r) + x), S = ut(S + y - (_ * i + y * s) + b)), (l || c) && (a = v.getBBox(), T = ut(T + l / 100 * a.width), S = ut(S + c / 100 * a.height)), a = "matrix(" + n + "," + i + "," + r + "," + s + "," + T + "," + S + ")", v.setAttribute("transform", a), E && (v.style[Ki] = a) }, Or = function (e, t, n, i, r) { var s, a, o = 360, l = Me(r), c = parseFloat(r) * (l && ~r.indexOf("rad") ? Ri : 1) - i, u = i + c + "deg"; return l && ("short" === (s = r.split("_")[1]) && (c %= o) !== c % 180 && (c += c < 0 ? o : -360), "cw" === s && c < 0 ? c = (c + 36e9) % o - ~~(c / o) * o : "ccw" === s && c > 0 && (c = (c - 36e9) % o - ~~(c / o) * o)), e._pt = a = new li(e._pt, t, n, i, c, Bi), a.e = u, a.u = "deg", e._props.push(n), a }, Fr = function (e, t) { for (var n in t) e[n] = t[n]; return e }, Ur = function (e, t, n) { var i, r, s, a, o, l, c, u = Fr({}, n._gsap), h = n.style; for (r in u.svg ? (s = n.getAttribute("transform"), n.setAttribute("transform", ""), h[Ki] = t, i = wr(n, 1), ur(n, Ki), n.setAttribute("transform", s)) : (s = getComputedStyle(n)[Ki], h[Ki] = t, i = wr(n, 1), h[Ki] = s), Ci) (s = u[r]) !== (a = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = qt(s) !== (c = qt(a)) ? fr(n, r, s, c) : parseFloat(s), l = parseFloat(a), e._pt = new li(e._pt, i, r, o, l - o, Ui), e._pt.u = c || 0, e._props.push(r)); Fr(i, u) }; ct("padding,margin,Width,Radius", (function (e, t) { var n = "Top", i = "Right", r = "Bottom", s = "Left", a = (t < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function (n) { return t < 2 ? e + n : "border" + n + e })); yr[t > 1 ? "border" + e : e] = function (e, t, n, i, r) { var s, o; if (arguments.length < 4) return s = a.map((function (t) { return mr(e, t, n) })), 5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o; s = (i + "").split(" "), o = {}, a.forEach((function (e, t) { return o[e] = s[t] = s[t] || s[(t - 1) / 2 | 0] })), e.init(t, o, r) } })); var Br, kr, zr, Hr = { name: "css", register: sr, targetTest: function (e) { return e.style && e.nodeType }, init: function (e, t, n, i, r) { var s, a, o, l, c, u, h, d, p, f, m, g, v, _, y, x, b, E, T, S, M = this._props, w = e.style, A = n.vars.startAt; for (h in Si || sr(), this.styles = this.styles || er(e), x = this.styles.props, this.tween = n, t) if ("autoRound" !== h && (a = t[h], !tt[h] || !Gn(h, t, n, i, e, r))) if (c = typeof a, u = yr[h], "function" === c && (c = typeof (a = a.call(n, i, e, r))), "string" === c && ~a.indexOf("random(") && (a = an(a)), u) u(this, e, h, a, n) && (y = 1); else if ("--" === h.substr(0, 2)) s = (getComputedStyle(e).getPropertyValue(h) + "").trim(), a += "", yn.lastIndex = 0, yn.test(s) || (d = qt(s), p = qt(a)), p ? d !== p && (s = fr(e, h, s, p) + p) : d && (a += d), this.add(w, "setProperty", s, a, i, r, 0, 0, h), M.push(h), x.push(h, 0, w[h]); else if ("undefined" !== c) { if (A && h in A ? (s = "function" == typeof A[h] ? A[h].call(n, i, e, r) : A[h], Me(s) && ~s.indexOf("random(") && (s = an(s)), qt(s + "") || (s += me.units[h] || qt(mr(e, h)) || ""), "=" === (s + "").charAt(1) && (s = mr(e, h))) : s = mr(e, h), l = parseFloat(s), (f = "string" === c && "=" === a.charAt(1) && a.substr(0, 2)) && (a = a.substr(2)), o = parseFloat(a), h in Fi && ("autoAlpha" === h && (1 === l && "hidden" === mr(e, "visibility") && o && (l = 0), x.push("visibility", 0, w.visibility), hr(this, w, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== h && "transform" !== h && ~(h = Fi[h]).indexOf(",") && (h = h.split(",")[0])), m = h in Ci) if (this.styles.save(h), g || ((v = e._gsap).renderTransform && !t.parseTransform || wr(e, t.parseTransform), _ = !1 !== t.smoothOrigin && v.smooth, (g = this._pt = new li(this._pt, w, Ki, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === h) this._pt = new li(this._pt, v, "scaleY", v.scaleY, (f ? dt(v.scaleY, f + o) : o) - v.scaleY || 0, Ui), this._pt.u = 0, M.push("scaleY", h), h += "X"; else { if ("transformOrigin" === h) { x.push($i, 0, w[$i]), E = void 0, T = void 0, S = void 0, E = (b = a).split(" "), T = E[0], S = E[1] || "50%", "top" !== T && "bottom" !== T && "left" !== S && "right" !== S || (b = T, T = S, S = b), E[0] = vr[T] || T, E[1] = vr[S] || S, a = E.join(" "), v.svg ? Mr(e, a, 0, _, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== v.zOrigin && hr(this, v, "zOrigin", v.zOrigin, p), hr(this, w, h, Ar(s), Ar(a))); continue } if ("svgOrigin" === h) { Mr(e, a, 1, _, 0, this); continue } if (h in br) { Or(this, v, h, l, f ? dt(l, f + a) : a); continue } if ("smoothOrigin" === h) { hr(this, v, "smooth", v.smooth, a); continue } if ("force3D" === h) { v[h] = a; continue } if ("transform" === h) { Ur(this, a, e); continue } } else h in w || (h = rr(h) || h); if (m || (o || 0 === o) && (l || 0 === l) && !Oi.test(a) && h in w) o || (o = 0), (d = (s + "").substr((l + "").length)) !== (p = qt(a) || (h in me.units ? me.units[h] : d)) && (l = fr(e, h, s, p)), this._pt = new li(this._pt, m ? v : w, h, l, (f ? dt(l, f + o) : o) - l, m || "px" !== p && "zIndex" !== h || !1 === t.autoRound ? Ui : zi), this._pt.u = p || 0, d !== p && "%" !== p && (this._pt.b = s, this._pt.r = ki); else if (h in w) gr.call(this, e, h, s, f ? f + a : a); else if (h in e) this.add(e, h, s || e[h], f ? f + a : a, i, r); else if ("parseTransform" !== h) { je(h, a); continue } m || (h in w ? x.push(h, 0, w[h]) : x.push(h, 1, s || e[h])), M.push(h) } y && oi(this) }, render: function (e, t) { if (t.tween._time || !Ai()) for (var n = t._pt; n;)n.r(e, n.d), n = n._next; else t.styles.revert() }, get: mr, aliases: Fi, getSetter: function (e, t, n) { var i = Fi[t]; return i && i.indexOf(",") < 0 && (t = i), t in Ci && t !== $i && (e._gsap.x || mr(e, "x")) ? n && wi === n ? "scale" === t ? Xi : ji : (wi = n || {}) && ("scale" === t ? qi : Yi) : e.style && !De(e.style[t]) ? Vi : ~t.indexOf("-") ? Wi : Qn(e, t) }, core: { _removeProperty: ur, _getMatrix: Sr } }; xi.utils.checkPrefix = rr, xi.core.getStyleSaver = er, zr = ct((Br = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (kr = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (e) { Ci[e] = 1 })), ct(kr, (function (e) { me.units[e] = "deg", br[e] = 1 })), Fi[zr[13]] = Br + "," + kr, ct("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (e) { var t = e.split(":"); Fi[t[1]] = zr[t[0]] })), ct("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (e) { me.units[e] = "px" })), xi.registerPlugin(Hr); var Gr = xi.registerPlugin(Hr) || xi; Gr.core.Tween; const Vr = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/; function Wr(e) { let t = e.nodeType, n = ""; if (1 === t || 9 === t || 11 === t) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += Wr(e) } else if (3 === t || 4 === t) return e.nodeValue; return n } let jr, Xr, qr, Yr = /(?:\r|\n|\t\t)/g, Kr = /(?:\s\s+)/g, $r = e => Xr.getComputedStyle(e), Zr = Array.isArray, Jr = [].slice, Qr = (e, t) => { let n; return Zr(e) ? e : "string" == (n = typeof e) && !t && e ? Jr.call(jr.querySelectorAll(e), 0) : e && "object" === n && "length" in e ? Jr.call(e, 0) : e ? [e] : [] }, es = e => "absolute" === e.position || !0 === e.absolute, ts = (e, t) => { let n, i = t.length; for (; --i > -1;)if (n = t[i], e.substr(0, n.length) === n) return n.length }, ns = (e = "", t) => { let n = ~e.indexOf("++"), i = 1; return n && (e = e.split("++").join("")), () => "<" + t + " style='position:relative;display:inline-block;'" + (e ? " class='" + e + (n ? i++ : "") + "'>" : ">") }, is = (e, t, n) => { let i = e.nodeType; if (1 === i || 9 === i || 11 === i) for (e = e.firstChild; e; e = e.nextSibling)is(e, t, n); else 3 !== i && 4 !== i || (e.nodeValue = e.nodeValue.split(t).join(n)) }, rs = (e, t) => { let n = t.length; for (; --n > -1;)e.push(t[n]) }, ss = (e, t, n) => { let i; for (; e && e !== t;) { if (i = e._next || e.nextSibling, i) return i.textContent.charAt(0) === n; e = e.parentNode || e._parent } }, as = e => { let t, n, i = Qr(e.childNodes), r = i.length; for (t = 0; t < r; t++)n = i[t], n._isSplit ? as(n) : t && n.previousSibling && 3 === n.previousSibling.nodeType ? (n.previousSibling.nodeValue += 3 === n.nodeType ? n.nodeValue : n.firstChild.nodeValue, e.removeChild(n)) : 3 !== n.nodeType && (e.insertBefore(n.firstChild, n), e.removeChild(n)) }, os = (e, t) => parseFloat(t[e]) || 0, ls = (e, t, n, i, r, s, a) => { let o, l, c, u, h, d, p, f, m, g, v, _, y = $r(e), x = os("paddingLeft", y), b = -999, E = os("borderBottomWidth", y) + os("borderTopWidth", y), T = os("borderLeftWidth", y) + os("borderRightWidth", y), S = os("paddingTop", y) + os("paddingBottom", y), M = os("paddingLeft", y) + os("paddingRight", y), w = os("fontSize", y) * (t.lineThreshold || .2), A = y.textAlign, D = [], C = [], R = [], L = t.wordDelimiter || " ", P = t.tag ? t.tag : t.span ? "span" : "div", I = t.type || t.split || "chars,words,lines", N = r && ~I.indexOf("lines") ? [] : null, O = ~I.indexOf("words"), F = ~I.indexOf("chars"), U = es(t), B = t.linesClass, k = ~(B || "").indexOf("++"), z = [], H = "flex" === y.display, G = e.style.display; for (k && (B = B.split("++").join("")), H && (e.style.display = "block"), l = e.getElementsByTagName("*"), c = l.length, h = [], o = 0; o < c; o++)h[o] = l[o]; if (N || U) for (o = 0; o < c; o++)u = h[o], d = u.parentNode === e, (d || U || F && !O) && (_ = u.offsetTop, N && d && Math.abs(_ - b) > w && ("BR" !== u.nodeName || 0 === o) && (p = [], N.push(p), b = _), U && (u._x = u.offsetLeft, u._y = _, u._w = u.offsetWidth, u._h = u.offsetHeight), N && ((u._isSplit && d || !F && d || O && d || !O && u.parentNode.parentNode === e && !u.parentNode._isSplit) && (p.push(u), u._x -= x, ss(u, e, L) && (u._wordEnd = !0)), "BR" === u.nodeName && (u.nextSibling && "BR" === u.nextSibling.nodeName || 0 === o) && N.push([]))); for (o = 0; o < c; o++)if (u = h[o], d = u.parentNode === e, "BR" !== u.nodeName) if (U && (m = u.style, O || d || (u._x += u.parentNode._x, u._y += u.parentNode._y), m.left = u._x + "px", m.top = u._y + "px", m.position = "absolute", m.display = "block", m.width = u._w + 1 + "px", m.height = u._h + "px"), !O && F) if (u._isSplit) for (u._next = l = u.nextSibling, u.parentNode.appendChild(u); l && 3 === l.nodeType && " " === l.textContent;)u._next = l.nextSibling, u.parentNode.appendChild(l), l = l.nextSibling; else u.parentNode._isSplit ? (u._parent = u.parentNode, !u.previousSibling && u.firstChild && (u.firstChild._isFirst = !0), u.nextSibling && " " === u.nextSibling.textContent && !u.nextSibling.nextSibling && z.push(u.nextSibling), u._next = u.nextSibling && u.nextSibling._isFirst ? null : u.nextSibling, u.parentNode.removeChild(u), h.splice(o--, 1), c--) : d || (_ = !u.nextSibling && ss(u.parentNode, e, L), u.parentNode._parent && u.parentNode._parent.appendChild(u), _ && u.parentNode.appendChild(jr.createTextNode(" ")), "span" === P && (u.style.display = "inline"), D.push(u)); else u.parentNode._isSplit && !u._isSplit && "" !== u.innerHTML ? C.push(u) : F && !u._isSplit && ("span" === P && (u.style.display = "inline"), D.push(u)); else N || U ? (u.parentNode && u.parentNode.removeChild(u), h.splice(o--, 1), c--) : O || e.appendChild(u); for (o = z.length; --o > -1;)z[o].parentNode.removeChild(z[o]); if (N) { for (U && (g = jr.createElement(P), e.appendChild(g), v = g.offsetWidth + "px", _ = g.offsetParent === e ? 0 : e.offsetLeft, e.removeChild(g)), m = e.style.cssText, e.style.cssText = "display:none;"; e.firstChild;)e.removeChild(e.firstChild); for (f = " " === L && (!U || !O && !F), o = 0; o < N.length; o++) { for (p = N[o], g = jr.createElement(P), g.style.cssText = "display:block;text-align:" + A + ";position:" + (U ? "absolute;" : "relative;"), B && (g.className = B + (k ? o + 1 : "")), R.push(g), c = p.length, l = 0; l < c; l++)"BR" !== p[l].nodeName && (u = p[l], g.appendChild(u), f && u._wordEnd && g.appendChild(jr.createTextNode(" ")), U && (0 === l && (g.style.top = u._y + "px", g.style.left = x + _ + "px"), u.style.top = "0px", _ && (u.style.left = u._x - _ + "px"))); 0 === c ? g.innerHTML = "&nbsp;" : O || F || (as(g), is(g, String.fromCharCode(160), " ")), U && (g.style.width = v, g.style.height = u._h + "px"), e.appendChild(g) } e.style.cssText = m } U && (a > e.clientHeight && (e.style.height = a - S + "px", e.clientHeight < a && (e.style.height = a + E + "px")), s > e.clientWidth && (e.style.width = s - M + "px", e.clientWidth < s && (e.style.width = s + T + "px"))), H && (G ? e.style.display = G : e.style.removeProperty("display")), rs(n, D), O && rs(i, C), rs(r, R) }, cs = (e, t, n, i) => { let r, s, a, o, l, c, u, h, d = t.tag ? t.tag : t.span ? "span" : "div", p = ~(t.type || t.split || "chars,words,lines").indexOf("chars"), f = es(t), m = t.wordDelimiter || " ", g = " " !== m ? "" : f ? "&#173; " : " ", v = "</" + d + ">", _ = 1, y = t.specialChars ? "function" == typeof t.specialChars ? t.specialChars : ts : null, x = jr.createElement("div"), b = e.parentNode; for (b.insertBefore(x, e), x.textContent = e.nodeValue, b.removeChild(e), r = Wr(e = x), u = -1 !== r.indexOf("<"), !1 !== t.reduceWhiteSpace && (r = r.replace(Kr, " ").replace(Yr, "")), u && (r = r.split("<").join("{{LT}}")), l = r.length, s = (" " === r.charAt(0) ? g : "") + n(), a = 0; a < l; a++)if (c = r.charAt(a), y && (h = y(r.substr(a), t.specialChars))) c = r.substr(a, h || 1), s += p && " " !== c ? i() + c + "</" + d + ">" : c, a += h - 1; else if (c === m && r.charAt(a - 1) !== m && a) { for (s += _ ? v : "", _ = 0; r.charAt(a + 1) === m;)s += g, a++; a === l - 1 ? s += g : ")" !== r.charAt(a + 1) && (s += g + n(), _ = 1) } else "{" === c && "{{LT}}" === r.substr(a, 6) ? (s += p ? i() + "{{LT}}</" + d + ">" : "{{LT}}", a += 5) : c.charCodeAt(0) >= 55296 && c.charCodeAt(0) <= 56319 || r.charCodeAt(a + 1) >= 65024 && r.charCodeAt(a + 1) <= 65039 ? (o = ((r.substr(a, 12).split(Vr) || [])[1] || "").length || 2, s += p && " " !== c ? i() + r.substr(a, o) + "</" + d + ">" : r.substr(a, o), a += o - 1) : s += p && " " !== c ? i() + c + "</" + d + ">" : c; e.outerHTML = s + (_ ? v : ""), u && is(b, "{{LT}}", "<") }, us = (e, t, n, i) => { let r, s, a = Qr(e.childNodes), o = a.length, l = es(t); if (3 !== e.nodeType || o > 1) { for (t.absolute = !1, r = 0; r < o; r++)s = a[r], s._next = s._isFirst = s._parent = s._wordEnd = null, (3 !== s.nodeType || /\S+/.test(s.nodeValue)) && (l && 3 !== s.nodeType && "inline" === $r(s).display && (s.style.display = "inline-block", s.style.position = "relative"), s._isSplit = !0, us(s, t, n, i)); return t.absolute = l, void (e._isSplit = !0) } cs(e, t, n, i) }; class hs { constructor(e, t) { qr || (jr = document, Xr = window, qr = 1), this.elements = Qr(e), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = t || {}, this.split(t) } split(e) { this.isSplit && this.revert(), this.vars = e = e || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0; let t, n, i, r = this.elements.length, s = e.tag ? e.tag : e.span ? "span" : "div", a = ns(e.wordsClass, s), o = ns(e.charsClass, s); for (; --r > -1;)i = this.elements[r], this._originals[r] = i.innerHTML, t = i.clientHeight, n = i.clientWidth, us(i, e, a, o), ls(i, e, this.chars, this.words, this.lines, n, t); return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this } revert() { let e = this._originals; if (!e) throw "revert() call wasn't scoped properly."; return this.elements.forEach(((t, n) => t.innerHTML = e[n])), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this } static create(e, t) { return new hs(e, t) } } hs.version = "3.11.3"; var ds, ps, fs, ms, gs, vs, _s, ys, xs = function () { return "undefined" != typeof window }, bs = function () { return ds || xs() && (ds = window.gsap) && ds.registerPlugin && ds }, Es = function (e) { return "string" == typeof e }, Ts = function (e) { return "function" == typeof e }, Ss = function (e, t) { var n = "x" === t ? "Width" : "Height", i = "scroll" + n, r = "client" + n; return e === fs || e === ms || e === gs ? Math.max(ms[i], gs[i]) - (fs["inner" + n] || ms[r] || gs[r]) : e[i] - e["offset" + n] }, Ms = function (e, t) { var n = "scroll" + ("x" === t ? "Left" : "Top"); return e === fs && (null != e.pageXOffset ? n = "page" + t.toUpperCase() + "Offset" : e = null != ms[n] ? ms : gs), function () { return e[n] } }, ws = function (e, t) { if (!(e = vs(e)[0]) || !e.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || { x: 0, y: 0 }; var n = e.getBoundingClientRect(), i = !t || t === fs || t === gs, r = i ? { top: ms.clientTop - (fs.pageYOffset || ms.scrollTop || gs.scrollTop || 0), left: ms.clientLeft - (fs.pageXOffset || ms.scrollLeft || gs.scrollLeft || 0) } : t.getBoundingClientRect(), s = { x: n.left - r.left, y: n.top - r.top }; return !i && t && (s.x += Ms(t, "x")(), s.y += Ms(t, "y")()), s }, As = function (e, t, n, i, r) { return isNaN(e) || "object" == typeof e ? Es(e) && "=" === e.charAt(1) ? parseFloat(e.substr(2)) * ("-" === e.charAt(0) ? -1 : 1) + i - r : "max" === e ? Ss(t, n) - r : Math.min(Ss(t, n), ws(e, t)[n] - r) : parseFloat(e) - r }, Ds = function () { ds = bs(), xs() && ds && "undefined" != typeof document && document.body && (fs = window, gs = document.body, ms = document.documentElement, vs = ds.utils.toArray, ds.config({ autoKillThreshold: 7 }), _s = ds.config(), ps = 1) }, Cs = { version: "3.11.5", name: "scrollTo", rawVars: 1, register: function (e) { ds = e, Ds() }, init: function (e, t, n, i, r) { ps || Ds(); var s = this, a = ds.getProperty(e, "scrollSnapType"); s.isWin = e === fs, s.target = e, s.tween = n, t = function (e, t, n, i) { if (Ts(e) && (e = e(t, n, i)), "object" != typeof e) return Es(e) && "max" !== e && "=" !== e.charAt(1) ? { x: e, y: e } : { y: e }; if (e.nodeType) return { y: e, x: e }; var r, s = {}; for (r in e) s[r] = "onAutoKill" !== r && Ts(e[r]) ? e[r](t, n, i) : e[r]; return s }(t, i, e, r), s.vars = t, s.autoKill = !!t.autoKill, s.getX = Ms(e, "x"), s.getY = Ms(e, "y"), s.x = s.xPrev = s.getX(), s.y = s.yPrev = s.getY(), ys || (ys = ds.core.globals().ScrollTrigger), "smooth" === ds.getProperty(e, "scrollBehavior") && ds.set(e, { scrollBehavior: "auto" }), a && "none" !== a && (s.snap = 1, s.snapInline = e.style.scrollSnapType, e.style.scrollSnapType = "none"), null != t.x ? (s.add(s, "x", s.x, As(t.x, e, "x", s.x, t.offsetX || 0), i, r), s._props.push("scrollTo_x")) : s.skipX = 1, null != t.y ? (s.add(s, "y", s.y, As(t.y, e, "y", s.y, t.offsetY || 0), i, r), s._props.push("scrollTo_y")) : s.skipY = 1 }, render: function (e, t) { for (var n, i, r, s, a, o = t._pt, l = t.target, c = t.tween, u = t.autoKill, h = t.xPrev, d = t.yPrev, p = t.isWin, f = t.snap, m = t.snapInline; o;)o.r(e, o.d), o = o._next; n = p || !t.skipX ? t.getX() : h, r = (i = p || !t.skipY ? t.getY() : d) - d, s = n - h, a = _s.autoKillThreshold, t.x < 0 && (t.x = 0), t.y < 0 && (t.y = 0), u && (!t.skipX && (s > a || s < -a) && n < Ss(l, "x") && (t.skipX = 1), !t.skipY && (r > a || r < -a) && i < Ss(l, "y") && (t.skipY = 1), t.skipX && t.skipY && (c.kill(), t.vars.onAutoKill && t.vars.onAutoKill.apply(c, t.vars.onAutoKillParams || []))), p ? fs.scrollTo(t.skipX ? n : t.x, t.skipY ? i : t.y) : (t.skipY || (l.scrollTop = t.y), t.skipX || (l.scrollLeft = t.x)), !f || 1 !== e && 0 !== e || (i = l.scrollTop, n = l.scrollLeft, m ? l.style.scrollSnapType = m : l.style.removeProperty("scroll-snap-type"), l.scrollTop = i + 1, l.scrollLeft = n + 1, l.scrollTop = i, l.scrollLeft = n), t.xPrev = t.x, t.yPrev = t.y, ys && ys.update() }, kill: function (e) { var t = "scrollTo" === e; (t || "scrollTo_x" === e) && (this.skipX = 1), (t || "scrollTo_y" === e) && (this.skipY = 1) } }; function Rs(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } Cs.max = Ss, Cs.getOffset = ws, Cs.buildGetter = Ms, bs() && ds.registerPlugin(Cs); var Ls, Ps, Is, Ns, Os, Fs, Us, Bs, ks, zs, Hs, Gs, Vs, Ws = function () { return Ls || "undefined" != typeof window && (Ls = window.gsap) && Ls.registerPlugin && Ls }, js = 1, Xs = [], qs = [], Ys = [], Ks = Date.now, $s = function (e, t) { return t }, Zs = function (e, t) { return ~Ys.indexOf(e) && Ys[Ys.indexOf(e) + 1][t] }, Js = function (e) { return !!~zs.indexOf(e) }, Qs = function (e, t, n, i, r) { return e.addEventListener(t, n, { passive: !i, capture: !!r }) }, ea = function (e, t, n, i) { return e.removeEventListener(t, n, !!i) }, ta = "scrollLeft", na = "scrollTop", ia = function () { return Hs && Hs.isPressed || qs.cache++ }, ra = function (e, t) { var n = function n(i) { if (i || 0 === i) { js && (Is.history.scrollRestoration = "manual"); var r = Hs && Hs.isPressed; i = n.v = Math.round(i) || (Hs && Hs.iOS ? 1 : 0), e(i), n.cacheID = qs.cache, r && $s("ss", i) } else (t || qs.cache !== n.cacheID || $s("ref")) && (n.cacheID = qs.cache, n.v = e()); return n.v + n.offset }; return n.offset = 0, e && n }, sa = { s: ta, p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: ra((function (e) { return arguments.length ? Is.scrollTo(e, aa.sc()) : Is.pageXOffset || Ns[ta] || Os[ta] || Fs[ta] || 0 })) }, aa = { s: na, p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: sa, sc: ra((function (e) { return arguments.length ? Is.scrollTo(sa.sc(), e) : Is.pageYOffset || Ns[na] || Os[na] || Fs[na] || 0 })) }, oa = function (e) { return Ls.utils.toArray(e)[0] || ("string" == typeof e && !1 !== Ls.config().nullTargetWarn ? console.warn("Element not found:", e) : null) }, la = function (e, t) { var n = t.s, i = t.sc; Js(e) && (e = Ns.scrollingElement || Os); var r = qs.indexOf(e), s = i === aa.sc ? 1 : 2; !~r && (r = qs.push(e) - 1), qs[r + s] || e.addEventListener("scroll", ia); var a = qs[r + s], o = a || (qs[r + s] = ra(Zs(e, n), !0) || (Js(e) ? i : ra((function (t) { return arguments.length ? e[n] = t : e[n] })))); return o.target = e, a || (o.smooth = "smooth" === Ls.getProperty(e, "scrollBehavior")), o }, ca = function (e, t, n) { var i = e, r = e, s = Ks(), a = s, o = t || 50, l = Math.max(500, 3 * o), c = function (e, t) { var l = Ks(); t || l - s > o ? (r = i, i = e, a = s, s = l) : n ? i += e : i = r + (e - r) / (l - a) * (s - a) }; return { update: c, reset: function () { r = i = n ? 0 : i, a = s = 0 }, getVelocity: function (e) { var t = a, o = r, u = Ks(); return (e || 0 === e) && e !== i && c(e), s === a || u - a > l ? 0 : (i + (n ? o : -o)) / ((n ? u : s) - t) * 1e3 } } }, ua = function (e, t) { return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e }, ha = function (e) { var t = Math.max.apply(Math, e), n = Math.min.apply(Math, e); return Math.abs(t) >= Math.abs(n) ? t : n }, da = function () { (ks = Ls.core.globals().ScrollTrigger) && ks.core && function () { var e = ks.core, t = e.bridge || {}, n = e._scrollers, i = e._proxies; n.push.apply(n, qs), i.push.apply(i, Ys), qs = n, Ys = i, $s = function (e, n) { return t[e](n) } }() }, pa = function (e) { return (Ls = e || Ws()) && "undefined" != typeof document && document.body && (Is = window, Ns = document, Os = Ns.documentElement, Fs = Ns.body, zs = [Is, Ns, Os, Fs], Ls.utils.clamp, Vs = Ls.core.context || function () { }, Bs = "onpointerenter" in Fs ? "pointer" : "mouse", Us = fa.isTouch = Is.matchMedia && Is.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Is || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, Gs = fa.eventTypes = ("ontouchstart" in Os ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Os ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout((function () { return js = 0 }), 500), da(), Ps = 1), Ps }; sa.op = aa, qs.cache = 0; var fa = function () { function e(e) { this.init(e) } var t, n, i; return e.prototype.init = function (e) { Ps || pa(Ls) || console.warn("Please gsap.registerPlugin(Observer)"), ks || da(); var t = e.tolerance, n = e.dragMinimum, i = e.type, r = e.target, s = e.lineHeight, a = e.debounce, o = e.preventDefault, l = e.onStop, c = e.onStopDelay, u = e.ignore, h = e.wheelSpeed, d = e.event, p = e.onDragStart, f = e.onDragEnd, m = e.onDrag, g = e.onPress, v = e.onRelease, _ = e.onRight, y = e.onLeft, x = e.onUp, b = e.onDown, E = e.onChangeX, T = e.onChangeY, S = e.onChange, M = e.onToggleX, w = e.onToggleY, A = e.onHover, D = e.onHoverEnd, C = e.onMove, R = e.ignoreCheck, L = e.isNormalizer, P = e.onGestureStart, I = e.onGestureEnd, N = e.onWheel, O = e.onEnable, F = e.onDisable, U = e.onClick, B = e.scrollSpeed, k = e.capture, z = e.allowClicks, H = e.lockAxis, G = e.onLockAxis; this.target = r = oa(r) || Os, this.vars = e, u && (u = Ls.utils.toArray(u)), t = t || 1e-9, n = n || 0, h = h || 1, B = B || 1, i = i || "wheel,touch,pointer", a = !1 !== a, s || (s = parseFloat(Is.getComputedStyle(Fs).lineHeight) || 22); var V, W, j, X, q, Y, K, $ = this, Z = 0, J = 0, Q = la(r, sa), ee = la(r, aa), te = Q(), ne = ee(), ie = ~i.indexOf("touch") && !~i.indexOf("pointer") && "pointerdown" === Gs[0], re = Js(r), se = r.ownerDocument || Ns, ae = [0, 0, 0], oe = [0, 0, 0], le = 0, ce = function () { return le = Ks() }, ue = function (e, t) { return ($.event = e) && u && ~u.indexOf(e.target) || t && ie && "touch" !== e.pointerType || R && R(e, t) }, he = function () { var e = $.deltaX = ha(ae), n = $.deltaY = ha(oe), i = Math.abs(e) >= t, r = Math.abs(n) >= t; S && (i || r) && S($, e, n, ae, oe), i && (_ && $.deltaX > 0 && _($), y && $.deltaX < 0 && y($), E && E($), M && $.deltaX < 0 != Z < 0 && M($), Z = $.deltaX, ae[0] = ae[1] = ae[2] = 0), r && (b && $.deltaY > 0 && b($), x && $.deltaY < 0 && x($), T && T($), w && $.deltaY < 0 != J < 0 && w($), J = $.deltaY, oe[0] = oe[1] = oe[2] = 0), (X || j) && (C && C($), j && (m($), j = !1), X = !1), Y && !(Y = !1) && G && G($), q && (N($), q = !1), V = 0 }, de = function (e, t, n) { ae[n] += e, oe[n] += t, $._vx.update(e), $._vy.update(t), a ? V || (V = requestAnimationFrame(he)) : he() }, pe = function (e, t) { H && !K && ($.axis = K = Math.abs(e) > Math.abs(t) ? "x" : "y", Y = !0), "y" !== K && (ae[2] += e, $._vx.update(e, !0)), "x" !== K && (oe[2] += t, $._vy.update(t, !0)), a ? V || (V = requestAnimationFrame(he)) : he() }, fe = function (e) { if (!ue(e, 1)) { var t = (e = ua(e, o)).clientX, i = e.clientY, r = t - $.x, s = i - $.y, a = $.isDragging; $.x = t, $.y = i, (a || Math.abs($.startX - t) >= n || Math.abs($.startY - i) >= n) && (m && (j = !0), a || ($.isDragging = !0), pe(r, s), a || p && p($)) } }, me = $.onPress = function (e) { ue(e, 1) || e && e.button || ($.axis = K = null, W.pause(), $.isPressed = !0, e = ua(e), Z = J = 0, $.startX = $.x = e.clientX, $.startY = $.y = e.clientY, $._vx.reset(), $._vy.reset(), Qs(L ? r : se, Gs[1], fe, o, !0), $.deltaX = $.deltaY = 0, g && g($)) }, ge = $.onRelease = function (e) { if (!ue(e, 1)) { ea(L ? r : se, Gs[1], fe, !0); var t = !isNaN($.y - $.startY), n = $.isDragging && (Math.abs($.x - $.startX) > 3 || Math.abs($.y - $.startY) > 3), i = ua(e); !n && t && ($._vx.reset(), $._vy.reset(), o && z && Ls.delayedCall(.08, (function () { if (Ks() - le > 300 && !e.defaultPrevented) if (e.target.click) e.target.click(); else if (se.createEvent) { var t = se.createEvent("MouseEvents"); t.initMouseEvent("click", !0, !0, Is, 1, i.screenX, i.screenY, i.clientX, i.clientY, !1, !1, !1, !1, 0, null), e.target.dispatchEvent(t) } }))), $.isDragging = $.isGesturing = $.isPressed = !1, l && !L && W.restart(!0), f && n && f($), v && v($, n) } }, ve = function (e) { return e.touches && e.touches.length > 1 && ($.isGesturing = !0) && P(e, $.isDragging) }, _e = function () { return ($.isGesturing = !1) || I($) }, ye = function (e) { if (!ue(e)) { var t = Q(), n = ee(); de((t - te) * B, (n - ne) * B, 1), te = t, ne = n, l && W.restart(!0) } }, xe = function (e) { if (!ue(e)) { e = ua(e, o), N && (q = !0); var t = (1 === e.deltaMode ? s : 2 === e.deltaMode ? Is.innerHeight : 1) * h; de(e.deltaX * t, e.deltaY * t, 0), l && !L && W.restart(!0) } }, be = function (e) { if (!ue(e)) { var t = e.clientX, n = e.clientY, i = t - $.x, r = n - $.y; $.x = t, $.y = n, X = !0, (i || r) && pe(i, r) } }, Ee = function (e) { $.event = e, A($) }, Te = function (e) { $.event = e, D($) }, Se = function (e) { return ue(e) || ua(e, o) && U($) }; W = $._dc = Ls.delayedCall(c || .25, (function () { $._vx.reset(), $._vy.reset(), W.pause(), l && l($) })).pause(), $.deltaX = $.deltaY = 0, $._vx = ca(0, 50, !0), $._vy = ca(0, 50, !0), $.scrollX = Q, $.scrollY = ee, $.isDragging = $.isGesturing = $.isPressed = !1, Vs(this), $.enable = function (e) { return $.isEnabled || (Qs(re ? se : r, "scroll", ia), i.indexOf("scroll") >= 0 && Qs(re ? se : r, "scroll", ye, o, k), i.indexOf("wheel") >= 0 && Qs(r, "wheel", xe, o, k), (i.indexOf("touch") >= 0 && Us || i.indexOf("pointer") >= 0) && (Qs(r, Gs[0], me, o, k), Qs(se, Gs[2], ge), Qs(se, Gs[3], ge), z && Qs(r, "click", ce, !1, !0), U && Qs(r, "click", Se), P && Qs(se, "gesturestart", ve), I && Qs(se, "gestureend", _e), A && Qs(r, Bs + "enter", Ee), D && Qs(r, Bs + "leave", Te), C && Qs(r, Bs + "move", be)), $.isEnabled = !0, e && e.type && me(e), O && O($)), $ }, $.disable = function () { $.isEnabled && (Xs.filter((function (e) { return e !== $ && Js(e.target) })).length || ea(re ? se : r, "scroll", ia), $.isPressed && ($._vx.reset(), $._vy.reset(), ea(L ? r : se, Gs[1], fe, !0)), ea(re ? se : r, "scroll", ye, k), ea(r, "wheel", xe, k), ea(r, Gs[0], me, k), ea(se, Gs[2], ge), ea(se, Gs[3], ge), ea(r, "click", ce, !0), ea(r, "click", Se), ea(se, "gesturestart", ve), ea(se, "gestureend", _e), ea(r, Bs + "enter", Ee), ea(r, Bs + "leave", Te), ea(r, Bs + "move", be), $.isEnabled = $.isPressed = $.isDragging = !1, F && F($)) }, $.kill = $.revert = function () { $.disable(); var e = Xs.indexOf($); e >= 0 && Xs.splice(e, 1), Hs === $ && (Hs = 0) }, Xs.push($), L && Js(r) && (Hs = $), $.enable(d) }, t = e, (n = [{ key: "velocityX", get: function () { return this._vx.getVelocity() } }, { key: "velocityY", get: function () { return this._vy.getVelocity() } }]) && Rs(t.prototype, n), i && Rs(t, i), e }(); fa.version = "3.11.5", fa.create = function (e) { return new fa(e) }, fa.register = pa, fa.getAll = function () { return Xs.slice() }, fa.getById = function (e) { return Xs.filter((function (t) { return t.vars.id === e }))[0] }, Ws() && Ls.registerPlugin(fa); var ma, ga, va, _a, ya, xa, ba, Ea, Ta, Sa, Ma, wa, Aa, Da, Ca, Ra, La, Pa, Ia, Na, Oa, Fa, Ua, Ba, ka, za, Ha, Ga, Va, Wa, ja, Xa, qa, Ya, Ka = 1, $a = Date.now, Za = $a(), Ja = 0, Qa = 0, eo = function e() { return Qa && requestAnimationFrame(e) }, to = function () { return Da = 1 }, no = function () { return Da = 0 }, io = function (e) { return e }, ro = function (e) { return Math.round(1e5 * e) / 1e5 || 0 }, so = function () { return "undefined" != typeof window }, ao = function () { return ma || so() && (ma = window.gsap) && ma.registerPlugin && ma }, oo = function (e) { return !!~ba.indexOf(e) }, lo = function (e) { return Zs(e, "getBoundingClientRect") || (oo(e) ? function () { return xl.width = va.innerWidth, xl.height = va.innerHeight, xl } : function () { return Oo(e) }) }, co = function (e, t) { var n = t.s, i = t.d2, r = t.d, s = t.a; return Math.max(0, (n = "scroll" + i) && (s = Zs(e, n)) ? s() - lo(e)()[r] : oo(e) ? (ya[n] || xa[n]) - (va["inner" + i] || ya["client" + i] || xa["client" + i]) : e[n] - e["offset" + i]) }, uo = function (e, t) { for (var n = 0; n < Ia.length; n += 3)(!t || ~t.indexOf(Ia[n + 1])) && e(Ia[n], Ia[n + 1], Ia[n + 2]) }, ho = function (e) { return "string" == typeof e }, po = function (e) { return "function" == typeof e }, fo = function (e) { return "number" == typeof e }, mo = function (e) { return "object" == typeof e }, go = function (e, t, n) { return e && e.progress(t ? 0 : 1) && n && e.pause() }, vo = function (e, t) { if (e.enabled) { var n = t(e); n && n.totalTime && (e.callbackAnimation = n) } }, _o = Math.abs, yo = "left", xo = "right", bo = "bottom", Eo = "width", To = "height", So = "Right", Mo = "Left", wo = "Top", Ao = "Bottom", Do = "padding", Co = "margin", Ro = "Width", Lo = "Height", Po = "px", Io = function (e) { return va.getComputedStyle(e) }, No = function (e, t) { for (var n in t) n in e || (e[n] = t[n]); return e }, Oo = function (e, t) { var n = t && "matrix(1, 0, 0, 1, 0, 0)" !== Io(e)[Ca] && ma.to(e, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), i = e.getBoundingClientRect(); return n && n.progress(0).kill(), i }, Fo = function (e, t) { var n = t.d2; return e["offset" + n] || e["client" + n] || 0 }, Uo = function (e) { var t, n = [], i = e.labels, r = e.duration(); for (t in i) n.push(i[t] / r); return n }, Bo = function (e) { var t = ma.utils.snap(e), n = Array.isArray(e) && e.slice(0).sort((function (e, t) { return e - t })); return n ? function (e, i, r) { var s; if (void 0 === r && (r = .001), !i) return t(e); if (i > 0) { for (e -= r, s = 0; s < n.length; s++)if (n[s] >= e) return n[s]; return n[s - 1] } for (s = n.length, e += r; s--;)if (n[s] <= e) return n[s]; return n[0] } : function (n, i, r) { void 0 === r && (r = .001); var s = t(n); return !i || Math.abs(s - n) < r || s - n < 0 == i < 0 ? s : t(i < 0 ? n - e : n + e) } }, ko = function (e, t, n, i) { return n.split(",").forEach((function (n) { return e(t, n, i) })) }, zo = function (e, t, n, i, r) { return e.addEventListener(t, n, { passive: !i, capture: !!r }) }, Ho = function (e, t, n, i) { return e.removeEventListener(t, n, !!i) }, Go = function (e, t, n) { (n = n && n.wheelHandler) && (e(t, "wheel", n), e(t, "touchmove", n)) }, Vo = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" }, Wo = { toggleActions: "play", anticipatePin: 0 }, jo = { top: 0, left: 0, center: .5, bottom: 1, right: 1 }, Xo = function (e, t) { if (ho(e)) { var n = e.indexOf("="), i = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0; ~n && (e.indexOf("%") > n && (i *= t / 100), e = e.substr(0, n - 1)), e = i + (e in jo ? jo[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0) } return e }, qo = function (e, t, n, i, r, s, a, o) { var l = r.startColor, c = r.endColor, u = r.fontSize, h = r.indent, d = r.fontWeight, p = _a.createElement("div"), f = oo(n) || "fixed" === Zs(n, "pinType"), m = -1 !== e.indexOf("scroller"), g = f ? xa : n, v = -1 !== e.indexOf("start"), _ = v ? l : c, y = "border-color:" + _ + ";font-size:" + u + ";color:" + _ + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;"; return y += "position:" + ((m || o) && f ? "fixed;" : "absolute;"), (m || o || !f) && (y += (i === aa ? xo : bo) + ":" + (s + parseFloat(h)) + "px;"), a && (y += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), p._isStart = v, p.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), p.style.cssText = y, p.innerText = t || 0 === t ? e + "-" + t : e, g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p), p._offset = p["offset" + i.op.d2], Yo(p, 0, i, v), p }, Yo = function (e, t, n, i) { var r = { display: "block" }, s = n[i ? "os2" : "p2"], a = n[i ? "p2" : "os2"]; e._isFlipped = i, r[n.a + "Percent"] = i ? -100 : 0, r[n.a] = i ? "1px" : 0, r["border" + s + Ro] = 1, r["border" + a + Ro] = 0, r[n.p] = t + "px", ma.set(e, r) }, Ko = [], $o = {}, Zo = function () { return $a() - Ja > 34 && (ja || (ja = requestAnimationFrame(pl))) }, Jo = function () { (!Ua || !Ua.isPressed || Ua.startX > xa.clientWidth) && (qs.cache++, Ua ? ja || (ja = requestAnimationFrame(pl)) : pl(), Ja || rl("scrollStart"), Ja = $a()) }, Qo = function () { za = va.innerWidth, ka = va.innerHeight }, el = function () { qs.cache++, !Aa && !Fa && !_a.fullscreenElement && !_a.webkitFullscreenElement && (!Ba || za !== va.innerWidth || Math.abs(va.innerHeight - ka) > .25 * va.innerHeight) && Ea.restart(!0) }, tl = {}, nl = [], il = function e() { return Ho(wl, "scrollEnd", e) || ul(!0) }, rl = function (e) { return tl[e] && tl[e].map((function (e) { return e() })) || nl }, sl = [], al = function (e) { for (var t = 0; t < sl.length; t += 5)(!e || sl[t + 4] && sl[t + 4].query === e) && (sl[t].style.cssText = sl[t + 1], sl[t].getBBox && sl[t].setAttribute("transform", sl[t + 2] || ""), sl[t + 3].uncache = 1) }, ol = function (e, t) { var n; for (Ra = 0; Ra < Ko.length; Ra++)!(n = Ko[Ra]) || t && n._ctx !== t || (e ? n.kill(1) : n.revert(!0, !0)); t && al(t), t || rl("revert") }, ll = function (e, t) { qs.cache++, (t || !Xa) && qs.forEach((function (e) { return po(e) && e.cacheID++ && (e.rec = 0) })), ho(e) && (va.history.scrollRestoration = Va = e) }, cl = 0, ul = function (e, t) { if (!Ja || e) { Xa = wl.isRefreshing = !0, qs.forEach((function (e) { return po(e) && e.cacheID++ && (e.rec = e()) })); var n = rl("refreshInit"); Na && wl.sort(), t || ol(), qs.forEach((function (e) { po(e) && (e.smooth && (e.target.style.scrollBehavior = "auto"), e(0)) })), Ko.slice(0).forEach((function (e) { return e.refresh() })), Ko.forEach((function (e, t) { if (e._subPinOffset && e.pin) { var n = e.vars.horizontal ? "offsetWidth" : "offsetHeight", i = e.pin[n]; e.revert(!0, 1), e.adjustPinSpacing(e.pin[n] - i), e.refresh() } })), Ko.forEach((function (e) { return "max" === e.vars.end && e.setPositions(e.start, Math.max(e.start + 1, co(e.scroller, e._dir))) })), n.forEach((function (e) { return e && e.render && e.render(-1) })), qs.forEach((function (e) { po(e) && (e.smooth && requestAnimationFrame((function () { return e.target.style.scrollBehavior = "smooth" })), e.rec && e(e.rec)) })), ll(Va, 1), Ea.pause(), cl++, Xa = 2, pl(2), Ko.forEach((function (e) { return po(e.vars.onRefresh) && e.vars.onRefresh(e) })), Xa = wl.isRefreshing = !1, rl("refresh") } else zo(wl, "scrollEnd", il) }, hl = 0, dl = 1, pl = function (e) { if (!Xa || 2 === e) { wl.isUpdating = !0, Ya && Ya.update(0); var t = Ko.length, n = $a(), i = n - Za >= 50, r = t && Ko[0].scroll(); if (dl = hl > r ? -1 : 1, Xa || (hl = r), i && (Ja && !Da && n - Ja > 200 && (Ja = 0, rl("scrollEnd")), Ma = Za, Za = n), dl < 0) { for (Ra = t; Ra-- > 0;)Ko[Ra] && Ko[Ra].update(0, i); dl = 1 } else for (Ra = 0; Ra < t; Ra++)Ko[Ra] && Ko[Ra].update(0, i); wl.isUpdating = !1 } ja = 0 }, fl = [yo, "top", bo, xo, Co + Ao, Co + So, Co + wo, Co + Mo, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], ml = fl.concat([Eo, To, "boxSizing", "max" + Ro, "max" + Lo, "position", Co, Do, Do + wo, Do + So, Do + Ao, Do + Mo]), gl = function (e, t, n, i) { if (!e._gsap.swappedIn) { for (var r, s = fl.length, a = t.style, o = e.style; s--;)a[r = fl[s]] = n[r]; a.position = "absolute" === n.position ? "absolute" : "relative", "inline" === n.display && (a.display = "inline-block"), o[bo] = o[xo] = "auto", a.flexBasis = n.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[Eo] = Fo(e, sa) + Po, a[To] = Fo(e, aa) + Po, a[Do] = o[Co] = o.top = o[yo] = "0", _l(i), o[Eo] = o["max" + Ro] = n[Eo], o[To] = o["max" + Lo] = n[To], o[Do] = n[Do], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0 } }, vl = /([A-Z])/g, _l = function (e) { if (e) { var t, n, i = e.t.style, r = e.length, s = 0; for ((e.t._gsap || ma.core.getCache(e.t)).uncache = 1; s < r; s += 2)n = e[s + 1], t = e[s], n ? i[t] = n : i[t] && i.removeProperty(t.replace(vl, "-$1").toLowerCase()) } }, yl = function (e) { for (var t = ml.length, n = e.style, i = [], r = 0; r < t; r++)i.push(ml[r], n[ml[r]]); return i.t = e, i }, xl = { left: 0, top: 0 }, bl = function (e, t, n, i, r, s, a, o, l, c, u, h, d) { po(e) && (e = e(o)), ho(e) && "max" === e.substr(0, 3) && (e = h + ("=" === e.charAt(4) ? Xo("0" + e.substr(3), n) : 0)); var p, f, m, g = d ? d.time() : 0; if (d && d.seek(0), fo(e)) d && (e = ma.utils.mapRange(d.scrollTrigger.start, d.scrollTrigger.end, 0, h, e)), a && Yo(a, n, i, !0); else { po(t) && (t = t(o)); var v, _, y, x, b = (e || "0").split(" "); m = oa(t) || xa, (v = Oo(m) || {}) && (v.left || v.top) || "none" !== Io(m).display || (x = m.style.display, m.style.display = "block", v = Oo(m), x ? m.style.display = x : m.style.removeProperty("display")), _ = Xo(b[0], v[i.d]), y = Xo(b[1] || "0", n), e = v[i.p] - l[i.p] - c + _ + r - y, a && Yo(a, y, i, n - y < 20 || a._isStart && y > 20), n -= n - y } if (s) { var E = e + n, T = s._isStart; p = "scroll" + i.d2, Yo(s, E, i, T && E > 20 || !T && (u ? Math.max(xa[p], ya[p]) : s.parentNode[p]) <= E + 1), u && (l = Oo(a), u && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + Po)) } return d && m && (p = Oo(m), d.seek(h), f = Oo(m), d._caScrollDist = p[i.p] - f[i.p], e = e / d._caScrollDist * h), d && d.seek(g), d ? e : Math.round(e) }, El = /(webkit|moz|length|cssText|inset)/i, Tl = function (e, t, n, i) { if (e.parentNode !== t) { var r, s, a = e.style; if (t === xa) { for (r in e._stOrig = a.cssText, s = Io(e)) +r || El.test(r) || !s[r] || "string" != typeof a[r] || "0" === r || (a[r] = s[r]); a.top = n, a.left = i } else a.cssText = e._stOrig; ma.core.getCache(e).uncache = 1, t.appendChild(e) } }, Sl = function (e, t, n) { var i = t, r = i; return function (t) { var s = Math.round(e()); return s !== i && s !== r && Math.abs(s - i) > 3 && Math.abs(s - r) > 3 && (t = s, n && n()), r = i, i = t, t } }, Ml = function (e, t) { var n = la(e, t), i = "_scroll" + t.p2, r = function t(r, s, a, o, l) { var c = t.tween, u = s.onComplete, h = {}; a = a || n(); var d = Sl(n, a, (function () { c.kill(), t.tween = 0 })); return l = o && l || 0, o = o || r - a, c && c.kill(), Math.round(a), s[i] = r, s.modifiers = h, h[i] = function () { return d(a + o * c.ratio + l * c.ratio * c.ratio) }, s.onUpdate = function () { qs.cache++, pl() }, s.onComplete = function () { t.tween = 0, u && u.call(c) }, c = t.tween = ma.to(e, s) }; return e[i] = n, n.wheelHandler = function () { return r.tween && r.tween.kill() && (r.tween = 0) }, zo(e, "wheel", n.wheelHandler), wl.isTouch && zo(e, "touchmove", n.wheelHandler), r }, wl = function () { function e(t, n) { ga || e.register(ma) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), this.init(t, n) } return e.prototype.init = function (t, n) { if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), Qa) { var i, r, s, a, o, l, c, u, h, d, p, f, m, g, v, _, y, x, b, E, T, S, M, w, A, D, C, R, L, P, I, N, O, F, U, B, k, z, H, G, V, W, j = t = No(ho(t) || fo(t) || t.nodeType ? { trigger: t } : t, Wo), X = j.onUpdate, q = j.toggleClass, Y = j.id, K = j.onToggle, $ = j.onRefresh, Z = j.scrub, J = j.trigger, Q = j.pin, ee = j.pinSpacing, te = j.invalidateOnRefresh, ne = j.anticipatePin, ie = j.onScrubComplete, re = j.onSnapComplete, se = j.once, ae = j.snap, oe = j.pinReparent, le = j.pinSpacer, ce = j.containerAnimation, ue = j.fastScrollEnd, he = j.preventOverlaps, de = t.horizontal || t.containerAnimation && !1 !== t.horizontal ? sa : aa, pe = !Z && 0 !== Z, fe = oa(t.scroller || va), me = ma.core.getCache(fe), ge = oo(fe), ve = "fixed" === ("pinType" in t ? t.pinType : Zs(fe, "pinType") || ge && "fixed"), _e = [t.onEnter, t.onLeave, t.onEnterBack, t.onLeaveBack], ye = pe && t.toggleActions.split(" "), xe = "markers" in t ? t.markers : Wo.markers, be = ge ? 0 : parseFloat(Io(fe)["border" + de.p2 + Ro]) || 0, Ee = this, Te = t.onRefreshInit && function () { return t.onRefreshInit(Ee) }, Se = function (e, t, n) { var i = n.d, r = n.d2, s = n.a; return (s = Zs(e, "getBoundingClientRect")) ? function () { return s()[i] } : function () { return (t ? va["inner" + r] : e["client" + r]) || 0 } }(fe, ge, de), Me = function (e, t) { return !t || ~Ys.indexOf(e) ? lo(e) : function () { return xl } }(fe, ge), we = 0, Ae = 0, De = la(fe, de); if (Ga(Ee), Ee._dir = de, ne *= 45, Ee.scroller = fe, Ee.scroll = ce ? ce.time.bind(ce) : De, a = De(), Ee.vars = t, n = n || t.animation, "refreshPriority" in t && (Na = 1, -9999 === t.refreshPriority && (Ya = Ee)), me.tweenScroll = me.tweenScroll || { top: Ml(fe, aa), left: Ml(fe, sa) }, Ee.tweenTo = i = me.tweenScroll[de.p], Ee.scrubDuration = function (e) { (N = fo(e) && e) ? I ? I.duration(e) : I = ma.to(n, { ease: "expo", totalProgress: "+=0.001", duration: N, paused: !0, onComplete: function () { return ie && ie(Ee) } }) : (I && I.progress(1).kill(), I = 0) }, n && (n.vars.lazy = !1, n._initted || !1 !== n.vars.immediateRender && !1 !== t.immediateRender && n.duration() && n.render(0, !0, !0), Ee.animation = n.pause(), n.scrollTrigger = Ee, Ee.scrubDuration(Z), I && I.resetTo && I.resetTo("totalProgress", 0), L = 0, Y || (Y = n.vars.id)), Ko.push(Ee), ae && (mo(ae) && !ae.push || (ae = { snapTo: ae }), "scrollBehavior" in xa.style && ma.set(ge ? [xa, ya] : fe, { scrollBehavior: "auto" }), qs.forEach((function (e) { return po(e) && e.target === (ge ? _a.scrollingElement || ya : fe) && (e.smooth = !1) })), s = po(ae.snapTo) ? ae.snapTo : "labels" === ae.snapTo ? function (e) { return function (t) { return ma.utils.snap(Uo(e), t) } }(n) : "labelsDirectional" === ae.snapTo ? (G = n, function (e, t) { return Bo(Uo(G))(e, t.direction) }) : !1 !== ae.directional ? function (e, t) { return Bo(ae.snapTo)(e, $a() - Ae < 500 ? 0 : t.direction) } : ma.utils.snap(ae.snapTo), O = ae.duration || { min: .1, max: 2 }, O = mo(O) ? Sa(O.min, O.max) : Sa(O, O), F = ma.delayedCall(ae.delay || N / 2 || .1, (function () { var e = De(), t = $a() - Ae < 500, r = i.tween; if (!(t || Math.abs(Ee.getVelocity()) < 10) || r || Da || we === e) Ee.isActive && we !== e && F.restart(!0); else { var a = (e - l) / m, o = n && !pe ? n.totalProgress() : a, u = t ? 0 : (o - P) / ($a() - Ma) * 1e3 || 0, h = ma.utils.clamp(-a, 1 - a, _o(u / 2) * u / .185), d = a + (!1 === ae.inertia ? 0 : h), p = Sa(0, 1, s(d, Ee)), f = Math.round(l + p * m), g = ae, v = g.onStart, _ = g.onInterrupt, y = g.onComplete; if (e <= c && e >= l && f !== e) { if (r && !r._initted && r.data <= _o(f - e)) return; !1 === ae.inertia && (h = p - a), i(f, { duration: O(_o(.185 * Math.max(_o(d - o), _o(p - o)) / u / .05 || 0)), ease: ae.ease || "power3", data: _o(f - e), onInterrupt: function () { return F.restart(!0) && _ && _(Ee) }, onComplete: function () { Ee.update(), we = De(), L = P = n && !pe ? n.totalProgress() : Ee.progress, re && re(Ee), y && y(Ee) } }, e, h * m, f - e - h * m), v && v(Ee, i.tween) } } })).pause()), Y && ($o[Y] = Ee), (H = (J = Ee.trigger = oa(J || Q)) && J._gsap && J._gsap.stRevert) && (H = H(Ee)), Q = !0 === Q ? J : oa(Q), ho(q) && (q = { targets: J, className: q }), Q && (!1 === ee || ee === Co || (ee = !(!ee && Q.parentNode && Q.parentNode.style && "flex" === Io(Q.parentNode).display) && Do), Ee.pin = Q, (r = ma.core.getCache(Q)).spacer ? g = r.pinState : (le && ((le = oa(le)) && !le.nodeType && (le = le.current || le.nativeElement), r.spacerIsNative = !!le, le && (r.spacerState = yl(le))), r.spacer = y = le || _a.createElement("div"), y.classList.add("pin-spacer"), Y && y.classList.add("pin-spacer-" + Y), r.pinState = g = yl(Q)), !1 !== t.force3D && ma.set(Q, { force3D: !0 }), Ee.spacer = y = r.spacer, R = Io(Q), M = R[ee + de.os2], b = ma.getProperty(Q), E = ma.quickSetter(Q, de.a, Po), gl(Q, y, R), _ = yl(Q)), xe) { f = mo(xe) ? No(xe, Vo) : Vo, d = qo("scroller-start", Y, fe, de, f, 0), p = qo("scroller-end", Y, fe, de, f, 0, d), x = d["offset" + de.op.d2]; var Ce = oa(Zs(fe, "content") || fe); u = this.markerStart = qo("start", Y, Ce, de, f, x, 0, ce), h = this.markerEnd = qo("end", Y, Ce, de, f, x, 0, ce), ce && (z = ma.quickSetter([u, h], de.a, Po)), ve || Ys.length && !0 === Zs(fe, "fixedMarkers") || (W = Io(V = ge ? xa : fe).position, V.style.position = "absolute" === W || "fixed" === W ? W : "relative", ma.set([d, p], { force3D: !0 }), A = ma.quickSetter(d, de.a, Po), C = ma.quickSetter(p, de.a, Po)) } if (ce) { var Re = ce.vars.onUpdate, Le = ce.vars.onUpdateParams; ce.eventCallback("onUpdate", (function () { Ee.update(0, 0, 1), Re && Re.apply(ce, Le || []) })) } Ee.previous = function () { return Ko[Ko.indexOf(Ee) - 1] }, Ee.next = function () { return Ko[Ko.indexOf(Ee) + 1] }, Ee.revert = function (e, t) { if (!t) return Ee.kill(!0); var i = !1 !== e || !Ee.enabled, r = Aa; i !== Ee.isReverted && (i && (B = Math.max(De(), Ee.scroll.rec || 0), U = Ee.progress, k = n && n.progress()), u && [u, h, d, p].forEach((function (e) { return e.style.display = i ? "none" : "block" })), i && (Aa = Ee, Ee.update(i)), !Q || oe && Ee.isActive || (i ? function (e, t, n) { _l(n); var i = e._gsap; if (i.spacerIsNative) _l(i.spacerState); else if (e._gsap.swappedIn) { var r = t.parentNode; r && (r.insertBefore(e, t), r.removeChild(t)) } e._gsap.swappedIn = !1 }(Q, y, g) : gl(Q, y, Io(Q), w)), i || Ee.update(i), Aa = r, Ee.isReverted = i) }, Ee.refresh = function (r, s) { if (!Aa && Ee.enabled || s) if (Q && r && Ja) zo(e, "scrollEnd", il); else { !Xa && Te && Te(Ee), Aa = Ee, Ae = $a(), i.tween && (i.tween.kill(), i.tween = 0), I && I.pause(), te && n && n.revert({ kill: !1 }).invalidate(), Ee.isReverted || Ee.revert(!0, !0), Ee._subPinOffset = !1; for (var f, x, E, M, A, C, R, L, P, N, O, z = Se(), H = Me(), G = ce ? ce.duration() : co(fe, de), V = m <= .01, W = 0, j = 0, X = t.end, q = t.endTrigger || J, Y = t.start || (0 !== t.start && J ? Q ? "0 0" : "0 100%" : 0), K = Ee.pinnedContainer = t.pinnedContainer && oa(t.pinnedContainer), Z = J && Math.max(0, Ko.indexOf(Ee)) || 0, ne = Z; ne--;)(C = Ko[ne]).end || C.refresh(0, 1) || (Aa = Ee), !(R = C.pin) || R !== J && R !== Q && R !== K || C.isReverted || (N || (N = []), N.unshift(C), C.revert(!0, !0)), C !== Ko[ne] && (Z--, ne--); for (po(Y) && (Y = Y(Ee)), l = bl(Y, J, z, de, De(), u, d, Ee, H, be, ve, G, ce) || (Q ? -.001 : 0), po(X) && (X = X(Ee)), ho(X) && !X.indexOf("+=") && (~X.indexOf(" ") ? X = (ho(Y) ? Y.split(" ")[0] : "") + X : (W = Xo(X.substr(2), z), X = ho(Y) ? Y : (ce ? ma.utils.mapRange(0, ce.duration(), ce.scrollTrigger.start, ce.scrollTrigger.end, l) : l) + W, q = J)), c = Math.max(l, bl(X || (q ? "100% 0" : G), q, z, de, De() + W, h, p, Ee, H, be, ve, G, ce)) || -.001, m = c - l || (l -= .01) && .001, W = 0, ne = Z; ne--;)(R = (C = Ko[ne]).pin) && C.start - C._pinPush <= l && !ce && C.end > 0 && (f = C.end - C.start, (R === J && C.start - C._pinPush < l || R === K) && !fo(Y) && (W += f * (1 - C.progress)), R === Q && (j += f)); if (l += W, c += W, V && (U = ma.utils.clamp(0, 1, ma.utils.normalize(l, c, B))), Ee._pinPush = j, u && W && ((f = {})[de.a] = "+=" + W, K && (f[de.p] = "-=" + De()), ma.set([u, h], f)), Q) f = Io(Q), M = de === aa, E = De(), T = parseFloat(b(de.a)) + j, !G && c > 1 && ((O = { style: O = (ge ? _a.scrollingElement || ya : fe).style, value: O["overflow" + de.a.toUpperCase()] }).style["overflow" + de.a.toUpperCase()] = "scroll"), gl(Q, y, f), _ = yl(Q), x = Oo(Q, !0), L = ve && la(fe, M ? sa : aa)(), ee && ((w = [ee + de.os2, m + j + Po]).t = y, (ne = ee === Do ? Fo(Q, de) + m + j : 0) && w.push(de.d, ne + Po), _l(w), K && Ko.forEach((function (e) { e.pin === K && !1 !== e.vars.pinSpacing && (e._subPinOffset = !0) })), ve && De(B)), ve && ((A = { top: x.top + (M ? E - l : L) + Po, left: x.left + (M ? L : E - l) + Po, boxSizing: "border-box", position: "fixed" })[Eo] = A["max" + Ro] = Math.ceil(x.width) + Po, A[To] = A["max" + Lo] = Math.ceil(x.height) + Po, A[Co] = A[Co + wo] = A[Co + So] = A[Co + Ao] = A[Co + Mo] = "0", A[Do] = f[Do], A[Do + wo] = f[Do + wo], A[Do + So] = f[Do + So], A[Do + Ao] = f[Do + Ao], A[Do + Mo] = f[Do + Mo], v = function (e, t, n) { for (var i, r = [], s = e.length, a = n ? 8 : 0; a < s; a += 2)i = e[a], r.push(i, i in t ? t[i] : e[a + 1]); return r.t = e.t, r }(g, A, oe), Xa && De(0)), n ? (P = n._initted, Oa(1), n.render(n.duration(), !0, !0), S = b(de.a) - T + m + j, D = Math.abs(m - S) > 1, ve && D && v.splice(v.length - 2, 2), n.render(0, !0, !0), P || n.invalidate(!0), n.parent || n.totalTime(n.totalTime()), Oa(0)) : S = m, O && (O.value ? O.style["overflow" + de.a.toUpperCase()] = O.value : O.style.removeProperty("overflow-" + de.a)); else if (J && De() && !ce) for (x = J.parentNode; x && x !== xa;)x._pinOffset && (l -= x._pinOffset, c -= x._pinOffset), x = x.parentNode; N && N.forEach((function (e) { return e.revert(!1, !0) })), Ee.start = l, Ee.end = c, a = o = Xa ? B : De(), ce || Xa || (a < B && De(B), Ee.scroll.rec = 0), Ee.revert(!1, !0), F && (we = -1, Ee.isActive && De(l + m * U), F.restart(!0)), Aa = 0, n && pe && (n._initted || k) && n.progress() !== k && n.progress(k, !0).render(n.time(), !0, !0), (V || U !== Ee.progress || ce) && (n && !pe && n.totalProgress(ce && l < -.001 && !U ? ma.utils.normalize(l, c, 0) : U, !0), Ee.progress = (a - l) / m === U ? 0 : U), Q && ee && (y._pinOffset = Math.round(Ee.progress * S)), I && I.invalidate(), $ && !Xa && $(Ee) } }, Ee.getVelocity = function () { return (De() - o) / ($a() - Ma) * 1e3 || 0 }, Ee.endAnimation = function () { go(Ee.callbackAnimation), n && (I ? I.progress(1) : n.paused() ? pe || go(n, Ee.direction < 0, 1) : go(n, n.reversed())) }, Ee.labelToScroll = function (e) { return n && n.labels && (l || Ee.refresh() || l) + n.labels[e] / n.duration() * m || 0 }, Ee.getTrailing = function (e) { var t = Ko.indexOf(Ee), n = Ee.direction > 0 ? Ko.slice(0, t).reverse() : Ko.slice(t + 1); return (ho(e) ? n.filter((function (t) { return t.vars.preventOverlaps === e })) : n).filter((function (e) { return Ee.direction > 0 ? e.end <= l : e.start >= c })) }, Ee.update = function (e, t, r) { if (!ce || r || e) { var s, u, h, p, f, g, x, b = !0 === Xa ? B : Ee.scroll(), w = e ? 0 : (b - l) / m, R = w < 0 ? 0 : w > 1 ? 1 : w || 0, N = Ee.progress; if (t && (o = a, a = ce ? De() : b, ae && (P = L, L = n && !pe ? n.totalProgress() : R)), ne && !R && Q && !Aa && !Ka && Ja && l < b + (b - o) / ($a() - Ma) * ne && (R = 1e-4), R !== N && Ee.enabled) { if (p = (f = (s = Ee.isActive = !!R && R < 1) !== (!!N && N < 1)) || !!R != !!N, Ee.direction = R > N ? 1 : -1, Ee.progress = R, p && !Aa && (u = R && !N ? 0 : 1 === R ? 1 : 1 === N ? 2 : 3, pe && (h = !f && "none" !== ye[u + 1] && ye[u + 1] || ye[u], x = n && ("complete" === h || "reset" === h || h in n))), he && (f || x) && (x || Z || !n) && (po(he) ? he(Ee) : Ee.getTrailing(he).forEach((function (e) { return e.endAnimation() }))), pe || (!I || Aa || Ka ? n && n.totalProgress(R, !!Aa) : (I._dp._time - I._start !== I._time && I.render(I._dp._time - I._start), I.resetTo ? I.resetTo("totalProgress", R, n._tTime / n._tDur) : (I.vars.totalProgress = R, I.invalidate().restart()))), Q) if (e && ee && (y.style[ee + de.os2] = M), ve) { if (p) { if (g = !e && R > N && c + 1 > b && b + 1 >= co(fe, de), oe) if (e || !s && !g) Tl(Q, y); else { var O = Oo(Q, !0), U = b - l; Tl(Q, xa, O.top + (de === aa ? U : 0) + Po, O.left + (de === aa ? 0 : U) + Po) } _l(s || g ? v : _), D && R < 1 && s || E(T + (1 !== R || g ? 0 : S)) } } else E(ro(T + S * R)); ae && !i.tween && !Aa && !Ka && F.restart(!0), q && (f || se && R && (R < 1 || !Wa)) && Ta(q.targets).forEach((function (e) { return e.classList[s || se ? "add" : "remove"](q.className) })), X && !pe && !e && X(Ee), p && !Aa ? (pe && (x && ("complete" === h ? n.pause().totalProgress(1) : "reset" === h ? n.restart(!0).pause() : "restart" === h ? n.restart(!0) : n[h]()), X && X(Ee)), !f && Wa || (K && f && vo(Ee, K), _e[u] && vo(Ee, _e[u]), se && (1 === R ? Ee.kill(!1, 1) : _e[u] = 0), f || _e[u = 1 === R ? 1 : 3] && vo(Ee, _e[u])), ue && !s && Math.abs(Ee.getVelocity()) > (fo(ue) ? ue : 2500) && (go(Ee.callbackAnimation), I ? I.progress(1) : go(n, "reverse" === h ? 1 : !R, 1))) : pe && X && !Aa && X(Ee) } if (C) { var k = ce ? b / ce.duration() * (ce._caScrollDist || 0) : b; A(k + (d._isFlipped ? 1 : 0)), C(k) } z && z(-b / ce.duration() * (ce._caScrollDist || 0)) } }, Ee.enable = function (t, n) { Ee.enabled || (Ee.enabled = !0, zo(fe, "resize", el), zo(ge ? _a : fe, "scroll", Jo), Te && zo(e, "refreshInit", Te), !1 !== t && (Ee.progress = U = 0, a = o = we = De()), !1 !== n && Ee.refresh()) }, Ee.getTween = function (e) { return e && i ? i.tween : I }, Ee.setPositions = function (e, t) { Q && (T += e - l, S += t - e - m, ee === Do && Ee.adjustPinSpacing(t - e - m)), Ee.start = l = e, Ee.end = c = t, m = t - e, Ee.update() }, Ee.adjustPinSpacing = function (e) { if (w && e) { var t = w.indexOf(de.d) + 1; w[t] = parseFloat(w[t]) + e + Po, w[1] = parseFloat(w[1]) + e + Po, _l(w) } }, Ee.disable = function (t, n) { if (Ee.enabled && (!1 !== t && Ee.revert(!0, !0), Ee.enabled = Ee.isActive = !1, n || I && I.pause(), B = 0, r && (r.uncache = 1), Te && Ho(e, "refreshInit", Te), F && (F.pause(), i.tween && i.tween.kill() && (i.tween = 0)), !ge)) { for (var s = Ko.length; s--;)if (Ko[s].scroller === fe && Ko[s] !== Ee) return; Ho(fe, "resize", el), Ho(fe, "scroll", Jo) } }, Ee.kill = function (e, i) { Ee.disable(e, i), I && !i && I.kill(), Y && delete $o[Y]; var s = Ko.indexOf(Ee); s >= 0 && Ko.splice(s, 1), s === Ra && dl > 0 && Ra--, s = 0, Ko.forEach((function (e) { return e.scroller === Ee.scroller && (s = 1) })), s || Xa || (Ee.scroll.rec = 0), n && (n.scrollTrigger = null, e && n.revert({ kill: !1 }), i || n.kill()), u && [u, h, d, p].forEach((function (e) { return e.parentNode && e.parentNode.removeChild(e) })), Ya === Ee && (Ya = 0), Q && (r && (r.uncache = 1), s = 0, Ko.forEach((function (e) { return e.pin === Q && s++ })), s || (r.spacer = 0)), t.onKill && t.onKill(Ee) }, Ee.enable(!1, !1), H && H(Ee), n && n.add && !m ? ma.delayedCall(.01, (function () { return l || c || Ee.refresh() })) && (m = .01) && (l = c = 0) : Ee.refresh(), Q && function () { if (qa !== cl) { var e = qa = cl; requestAnimationFrame((function () { return e === cl && ul(!0) })) } }() } else this.update = this.refresh = this.kill = io }, e.register = function (t) { return ga || (ma = t || ao(), so() && window.document && e.enable(), ga = Qa), ga }, e.defaults = function (e) { if (e) for (var t in e) Wo[t] = e[t]; return Wo }, e.disable = function (e, t) { Qa = 0, Ko.forEach((function (n) { return n[t ? "kill" : "disable"](e) })), Ho(va, "wheel", Jo), Ho(_a, "scroll", Jo), clearInterval(wa), Ho(_a, "touchcancel", io), Ho(xa, "touchstart", io), ko(Ho, _a, "pointerdown,touchstart,mousedown", to), ko(Ho, _a, "pointerup,touchend,mouseup", no), Ea.kill(), uo(Ho); for (var n = 0; n < qs.length; n += 3)Go(Ho, qs[n], qs[n + 1]), Go(Ho, qs[n], qs[n + 2]) }, e.enable = function () { if (va = window, _a = document, ya = _a.documentElement, xa = _a.body, ma && (Ta = ma.utils.toArray, Sa = ma.utils.clamp, Ga = ma.core.context || io, Oa = ma.core.suppressOverwrites || io, Va = va.history.scrollRestoration || "auto", hl = va.pageYOffset, ma.core.globals("ScrollTrigger", e), xa)) { Qa = 1, eo(), fa.register(ma), e.isTouch = fa.isTouch, Ha = fa.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), zo(va, "wheel", Jo), ba = [va, _a, ya, xa], ma.matchMedia ? (e.matchMedia = function (e) { var t, n = ma.matchMedia(); for (t in e) n.add(t, e[t]); return n }, ma.addEventListener("matchMediaInit", (function () { return ol() })), ma.addEventListener("matchMediaRevert", (function () { return al() })), ma.addEventListener("matchMedia", (function () { ul(0, 1), rl("matchMedia") })), ma.matchMedia("(orientation: portrait)", (function () { return Qo(), Qo }))) : console.warn("Requires GSAP 3.11.0 or later"), Qo(), zo(_a, "scroll", Jo); var t, n, i = xa.style, r = i.borderTopStyle, s = ma.core.Animation.prototype; for (s.revert || Object.defineProperty(s, "revert", { value: function () { return this.time(-.01, !0) } }), i.borderTopStyle = "solid", t = Oo(xa), aa.m = Math.round(t.top + aa.sc()) || 0, sa.m = Math.round(t.left + sa.sc()) || 0, r ? i.borderTopStyle = r : i.removeProperty("border-top-style"), wa = setInterval(Zo, 250), ma.delayedCall(.5, (function () { return Ka = 0 })), zo(_a, "touchcancel", io), zo(xa, "touchstart", io), ko(zo, _a, "pointerdown,touchstart,mousedown", to), ko(zo, _a, "pointerup,touchend,mouseup", no), Ca = ma.utils.checkPrefix("transform"), ml.push(Ca), ga = $a(), Ea = ma.delayedCall(.2, ul).pause(), Ia = [_a, "visibilitychange", function () { var e = va.innerWidth, t = va.innerHeight; _a.hidden ? (La = e, Pa = t) : La === e && Pa === t || el() }, _a, "DOMContentLoaded", ul, va, "load", ul, va, "resize", el], uo(zo), Ko.forEach((function (e) { return e.enable(0, 1) })), n = 0; n < qs.length; n += 3)Go(Ho, qs[n], qs[n + 1]), Go(Ho, qs[n], qs[n + 2]) } }, e.config = function (t) { "limitCallbacks" in t && (Wa = !!t.limitCallbacks); var n = t.syncInterval; n && clearInterval(wa) || (wa = n) && setInterval(Zo, n), "ignoreMobileResize" in t && (Ba = 1 === e.isTouch && t.ignoreMobileResize), "autoRefreshEvents" in t && (uo(Ho) || uo(zo, t.autoRefreshEvents || "none"), Fa = -1 === (t.autoRefreshEvents + "").indexOf("resize")) }, e.scrollerProxy = function (e, t) { var n = oa(e), i = qs.indexOf(n), r = oo(n); ~i && qs.splice(i, r ? 6 : 2), t && (r ? Ys.unshift(va, t, xa, t, ya, t) : Ys.unshift(n, t)) }, e.clearMatchMedia = function (e) { Ko.forEach((function (t) { return t._ctx && t._ctx.query === e && t._ctx.kill(!0, !0) })) }, e.isInViewport = function (e, t, n) { var i = (ho(e) ? oa(e) : e).getBoundingClientRect(), r = i[n ? Eo : To] * t || 0; return n ? i.right - r > 0 && i.left + r < va.innerWidth : i.bottom - r > 0 && i.top + r < va.innerHeight }, e.positionInViewport = function (e, t, n) { ho(e) && (e = oa(e)); var i = e.getBoundingClientRect(), r = i[n ? Eo : To], s = null == t ? r / 2 : t in jo ? jo[t] * r : ~t.indexOf("%") ? parseFloat(t) * r / 100 : parseFloat(t) || 0; return n ? (i.left + s) / va.innerWidth : (i.top + s) / va.innerHeight }, e.killAll = function (e) { if (Ko.slice(0).forEach((function (e) { return "ScrollSmoother" !== e.vars.id && e.kill() })), !0 !== e) { var t = tl.killAll || []; tl = {}, t.forEach((function (e) { return e() })) } }, e }(); wl.version = "3.11.5", wl.saveStyles = function (e) { return e ? Ta(e).forEach((function (e) { if (e && e.style) { var t = sl.indexOf(e); t >= 0 && sl.splice(t, 5), sl.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), ma.core.getCache(e), Ga()) } })) : sl }, wl.revert = function (e, t) { return ol(!e, t) }, wl.create = function (e, t) { return new wl(e, t) }, wl.refresh = function (e) { return e ? el() : (ga || wl.register()) && ul(!0) }, wl.update = function (e) { return ++qs.cache && pl(!0 === e ? 2 : 0) }, wl.clearScrollMemory = ll, wl.maxScroll = function (e, t) { return co(e, t ? sa : aa) }, wl.getScrollFunc = function (e, t) { return la(oa(e), t ? sa : aa) }, wl.getById = function (e) { return $o[e] }, wl.getAll = function () { return Ko.filter((function (e) { return "ScrollSmoother" !== e.vars.id })) }, wl.isScrolling = function () { return !!Ja }, wl.snapDirectional = Bo, wl.addEventListener = function (e, t) { var n = tl[e] || (tl[e] = []); ~n.indexOf(t) || n.push(t) }, wl.removeEventListener = function (e, t) { var n = tl[e], i = n && n.indexOf(t); i >= 0 && n.splice(i, 1) }, wl.batch = function (e, t) { var n, i = [], r = {}, s = t.interval || .016, a = t.batchMax || 1e9, o = function (e, t) { var n = [], i = [], r = ma.delayedCall(s, (function () { t(n, i), n = [], i = [] })).pause(); return function (e) { n.length || r.restart(!0), n.push(e.trigger), i.push(e), a <= n.length && r.progress(1) } }; for (n in t) r[n] = "on" === n.substr(0, 2) && po(t[n]) && "onRefreshInit" !== n ? o(0, t[n]) : t[n]; return po(a) && (a = a(), zo(wl, "refresh", (function () { return a = t.batchMax() }))), Ta(e).forEach((function (e) { var t = {}; for (n in r) t[n] = r[n]; t.trigger = e, i.push(wl.create(t)) })), i }; var Al, Dl = function (e, t, n, i) { return t > i ? e(i) : t < 0 && e(0), n > i ? (i - t) / (n - t) : n < 0 ? t / (t - n) : 1 }, Cl = function e(t, n) { !0 === n ? t.style.removeProperty("touch-action") : t.style.touchAction = !0 === n ? "auto" : n ? "pan-" + n + (fa.isTouch ? " pinch-zoom" : "") : "none", t === ya && e(xa, n) }, Rl = { auto: 1, scroll: 1 }, Ll = function (e) { var t, n = e.event, i = e.target, r = e.axis, s = (n.changedTouches ? n.changedTouches[0] : n).target, a = s._gsap || ma.core.getCache(s), o = $a(); if (!a._isScrollT || o - a._isScrollT > 2e3) { for (; s && s !== xa && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !Rl[(t = Io(s)).overflowY] && !Rl[t.overflowX]);)s = s.parentNode; a._isScroll = s && s !== i && !oo(s) && (Rl[(t = Io(s)).overflowY] || Rl[t.overflowX]), a._isScrollT = o } (a._isScroll || "x" === r) && (n.stopPropagation(), n._gsapAllow = !0) }, Pl = function (e, t, n, i) { return fa.create({ target: e, capture: !0, debounce: !1, lockAxis: !0, type: t, onWheel: i = i && Ll, onPress: i, onDrag: i, onScroll: i, onEnable: function () { return n && zo(_a, fa.eventTypes[0], Nl, !1, !0) }, onDisable: function () { return Ho(_a, fa.eventTypes[0], Nl, !0) } }) }, Il = /(input|label|select|textarea)/i, Nl = function (e) { var t = Il.test(e.target.tagName); (t || Al) && (e._gsapAllow = !0, Al = t) }, Ol = function (e) { mo(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer"; var t, n, i, r, s, a, o, l, c = e, u = c.normalizeScrollX, h = c.momentum, d = c.allowNestedScroll, p = c.onRelease, f = oa(e.target) || ya, m = ma.core.globals().ScrollSmoother, g = m && m.get(), v = Ha && (e.content && oa(e.content) || g && !1 !== e.content && !g.smooth() && g.content()), _ = la(f, aa), y = la(f, sa), x = 1, b = (fa.isTouch && va.visualViewport ? va.visualViewport.scale * va.visualViewport.width : va.outerWidth) / va.innerWidth, E = 0, T = po(h) ? function () { return h(t) } : function () { return h || 2.8 }, S = Pl(f, e.type, !0, d), M = function () { return r = !1 }, w = io, A = io, D = function () { n = co(f, aa), A = Sa(Ha ? 1 : 0, n), u && (w = Sa(0, co(f, sa))), i = cl }, C = function () { v._gsap.y = ro(parseFloat(v._gsap.y) + _.offset) + "px", v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(v._gsap.y) + ", 0, 1)", _.offset = _.cacheID = 0 }, R = function () { D(), s.isActive() && s.vars.scrollY > n && (_() > n ? s.progress(1) && _(n) : s.resetTo("scrollY", n)) }; return v && ma.set(v, { y: "+=0" }), e.ignoreCheck = function (e) { return Ha && "touchmove" === e.type && function () { if (r) { requestAnimationFrame(M); var e = ro(t.deltaY / 2), n = A(_.v - e); if (v && n !== _.v + _.offset) { _.offset = n - _.v; var i = ro((parseFloat(v && v._gsap.y) || 0) - _.offset); v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + i + ", 0, 1)", v._gsap.y = i + "px", _.cacheID = qs.cache, pl() } return !0 } _.offset && C(), r = !0 }() || x > 1.05 && "touchstart" !== e.type || t.isGesturing || e.touches && e.touches.length > 1 }, e.onPress = function () { r = !1; var e = x; x = ro((va.visualViewport && va.visualViewport.scale || 1) / b), s.pause(), e !== x && Cl(f, x > 1.01 || !u && "x"), a = y(), o = _(), D(), i = cl }, e.onRelease = e.onGestureStart = function (e, t) { if (_.offset && C(), t) { qs.cache++; var i, r, a = T(); u && (r = (i = y()) + .05 * a * -e.velocityX / .227, a *= Dl(y, i, r, co(f, sa)), s.vars.scrollX = w(r)), r = (i = _()) + .05 * a * -e.velocityY / .227, a *= Dl(_, i, r, co(f, aa)), s.vars.scrollY = A(r), s.invalidate().duration(a).play(.01), (Ha && s.vars.scrollY >= n || i >= n - 1) && ma.to({}, { onUpdate: R, duration: a }) } else l.restart(!0); p && p(e) }, e.onWheel = function () { s._ts && s.pause(), $a() - E > 1e3 && (i = 0, E = $a()) }, e.onChange = function (e, t, n, r, s) { if (cl !== i && D(), t && u && y(w(r[2] === t ? a + (e.startX - e.x) : y() + t - r[1])), n) { _.offset && C(); var l = s[2] === n, c = l ? o + e.startY - e.y : _() + n - s[1], h = A(c); l && c !== h && (o += h - c), _(h) } (n || t) && pl() }, e.onEnable = function () { Cl(f, !u && "x"), wl.addEventListener("refresh", R), zo(va, "resize", R), _.smooth && (_.target.style.scrollBehavior = "auto", _.smooth = y.smooth = !1), S.enable() }, e.onDisable = function () { Cl(f, !0), Ho(va, "resize", R), wl.removeEventListener("refresh", R), S.kill() }, e.lockAxis = !1 !== e.lockAxis, (t = new fa(e)).iOS = Ha, Ha && !_() && _(1), Ha && ma.ticker.add(io), l = t._dc, s = ma.to(t, { ease: "power4", paused: !0, scrollX: u ? "+=0.1" : "+=0", scrollY: "+=0.1", modifiers: { scrollY: Sl(_, _(), (function () { return s.pause() })) }, onUpdate: pl, onComplete: l.vars.onComplete }), t }; wl.sort = function (e) { return Ko.sort(e || function (e, t) { return -1e6 * (e.vars.refreshPriority || 0) + e.start - (t.start + -1e6 * (t.vars.refreshPriority || 0)) }) }, wl.observe = function (e) { return new fa(e) }, wl.normalizeScroll = function (e) { if (void 0 === e) return Ua; if (!0 === e && Ua) return Ua.enable(); if (!1 === e) return Ua && Ua.kill(); var t = e instanceof fa ? e : Ol(e); return Ua && Ua.target === t.target && Ua.kill(), oo(t.target) && (Ua = t), t }, wl.core = { _getVelocityProp: ca, _inputObserver: Pl, _scrollers: qs, _proxies: Ys, bridge: { ss: function () { Ja || rl("scrollStart"), Ja = $a() }, ref: function () { return Aa } } }, ao() && ma.registerPlugin(wl); var Fl = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, Ul = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, Bl = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi, kl = /(^[#\.][a-z]|[a-y][a-z])/i, zl = Math.PI / 180, Hl = 180 / Math.PI, Gl = Math.sin, Vl = Math.cos, Wl = Math.abs, jl = Math.sqrt, Xl = Math.atan2, ql = 1e8, Yl = function (e) { return "string" == typeof e }, Kl = function (e) { return "number" == typeof e }, $l = {}, Zl = {}, Jl = 1e5, Ql = function (e) { return Math.round((e + ql) % 1 * Jl) / Jl || (e < 0 ? 0 : 1) }, ec = function (e) { return Math.round(e * Jl) / Jl || 0 }, tc = function (e) { return Math.round(1e10 * e) / 1e10 || 0 }, nc = function (e, t, n, i) { var r = e[t], s = 1 === i ? 6 : fc(r, n, i); if (s && s + n + 2 < r.length) return e.splice(t, 0, r.slice(0, n + s + 2)), r.splice(0, n + s), 1 }, ic = function (e, t, n) { var i = e.length, r = ~~(n * i); if (e[r] > t) { for (; --r && e[r] > t;); r < 0 && (r = 0) } else for (; e[++r] < t && r < i;); return r < i ? r : i - 1 }, rc = function (e, t) { return t.totalLength = e.totalLength, e.samples ? (t.samples = e.samples.slice(0), t.lookup = e.lookup.slice(0), t.minLength = e.minLength, t.resolution = e.resolution) : e.totalPoints && (t.totalPoints = e.totalPoints), t }, sc = function (e, t) { var n = e.length, i = e[n - 1] || [], r = i.length; n && t[0] === i[r - 2] && t[1] === i[r - 1] && (t = i.concat(t.slice(2)), n--), e[n] = t }; function ac(e) { var t, n = (e = Yl(e) && kl.test(e) && document.querySelector(e) || e).getAttribute ? e : 0; return n && (e = e.getAttribute("d")) ? (n._gsPath || (n._gsPath = {}), (t = n._gsPath[e]) && !t._dirty ? t : n._gsPath[e] = yc(e)) : e ? Yl(e) ? yc(e) : Kl(e[0]) ? [e] : e : console.warn("Expecting a <path> element or an SVG path data string") } function oc(e) { var t, n = 0; for (e.reverse(); n < e.length; n += 2)t = e[n], e[n] = e[n + 1], e[n + 1] = t; e.reversed = !e.reversed } var lc = { rect: "rx,ry,x,y,width,height", circle: "r,cx,cy", ellipse: "rx,ry,cx,cy", line: "x1,x2,y1,y2" }; function cc(e, t) { var n, i, r, s, a, o, l, c, u, h, d, p, f, m, g, v, _, y, x, b, E, T, S = e.tagName.toLowerCase(), M = .552284749831; return "path" !== S && e.getBBox ? (o = function (e, t) { var n, i = document.createElementNS("http://www.w3.org/2000/svg", "path"), r = [].slice.call(e.attributes), s = r.length; for (t = "," + t + ","; --s > -1;)n = r[s].nodeName.toLowerCase(), t.indexOf("," + n + ",") < 0 && i.setAttributeNS(null, n, r[s].nodeValue); return i }(e, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), T = function (e, t) { for (var n = t ? t.split(",") : [], i = {}, r = n.length; --r > -1;)i[n[r]] = +e.getAttribute(n[r]) || 0; return i }(e, lc[S]), "rect" === S ? (s = T.rx, a = T.ry || s, i = T.x, r = T.y, h = T.width - 2 * s, d = T.height - 2 * a, n = s || a ? "M" + (v = (m = (f = i + s) + h) + s) + "," + (y = r + a) + " V" + (x = y + d) + " C" + [v, b = x + a * M, g = m + s * M, E = x + a, m, E, m - (m - f) / 3, E, f + (m - f) / 3, E, f, E, p = i + s * (1 - M), E, i, b, i, x, i, x - (x - y) / 3, i, y + (x - y) / 3, i, y, i, _ = r + a * (1 - M), p, r, f, r, f + (m - f) / 3, r, m - (m - f) / 3, r, m, r, g, r, v, _, v, y].join(",") + "z" : "M" + (i + h) + "," + r + " v" + d + " h" + -h + " v" + -d + " h" + h + "z") : "circle" === S || "ellipse" === S ? ("circle" === S ? c = (s = a = T.r) * M : (s = T.rx, c = (a = T.ry) * M), n = "M" + ((i = T.cx) + s) + "," + (r = T.cy) + " C" + [i + s, r + c, i + (l = s * M), r + a, i, r + a, i - l, r + a, i - s, r + c, i - s, r, i - s, r - c, i - l, r - a, i, r - a, i + l, r - a, i + s, r - c, i + s, r].join(",") + "z") : "line" === S ? n = "M" + T.x1 + "," + T.y1 + " L" + T.x2 + "," + T.y2 : "polyline" !== S && "polygon" !== S || (n = "M" + (i = (u = (e.getAttribute("points") + "").match(Ul) || []).shift()) + "," + (r = u.shift()) + " L" + u.join(","), "polygon" === S && (n += "," + i + "," + r + "z")), o.setAttribute("d", Ec(o._gsRawPath = yc(n))), t && e.parentNode && (e.parentNode.insertBefore(o, e), e.parentNode.removeChild(e)), o) : e } function uc(e, t, n) { var i, r = e[t], s = e[t + 2], a = e[t + 4]; return r += (s - r) * n, r += ((s += (a - s) * n) - r) * n, i = s + (a + (e[t + 6] - a) * n - s) * n - r, r = e[t + 1], r += ((s = e[t + 3]) - r) * n, r += ((s += ((a = e[t + 5]) - s) * n) - r) * n, ec(Xl(s + (a + (e[t + 7] - a) * n - s) * n - r, i) * Hl) } function hc(e, t, n) { n = void 0 === n ? 1 : tc(n) || 0, t = tc(t) || 0; var i = Math.max(0, ~~(Wl(n - t) - 1e-8)), r = function (e) { for (var t = [], n = 0; n < e.length; n++)t[n] = rc(e[n], e[n].slice(0)); return rc(e, t) }(e); if (t > n && (t = 1 - t, n = 1 - n, function (e, t) { var n = e.length; for (t || e.reverse(); n--;)e[n].reversed || oc(e[n]) }(r), r.totalLength = 0), t < 0 || n < 0) { var s = Math.abs(~~Math.min(t, n)) + 1; t += s, n += s } r.totalLength || pc(r); var a, o, l, c, u, h, d, p, f = n > 1, m = mc(r, t, $l, !0), g = mc(r, n, Zl), v = g.segment, _ = m.segment, y = g.segIndex, x = m.segIndex, b = g.i, E = m.i, T = x === y, S = b === E && T; if (f || i) { for (a = y < x || T && b < E || S && g.t < m.t, nc(r, x, E, m.t) && (x++, a || (y++, S ? (g.t = (g.t - m.t) / (1 - m.t), b = 0) : T && (b -= E))), Math.abs(1 - (n - t)) < 1e-5 ? y = x - 1 : !g.t && y ? y-- : nc(r, y, b, g.t) && a && x++, 1 === m.t && (x = (x + 1) % r.length), u = [], d = 1 + (h = r.length) * i, p = x, d += (h - x + y) % h, c = 0; c < d; c++)sc(u, r[p++ % h]); r = u } else if (l = 1 === g.t ? 6 : fc(v, b, g.t), t !== n) for (o = fc(_, E, S ? m.t / g.t : m.t), T && (l += o), v.splice(b + l + 2), (o || E) && _.splice(0, E + o), c = r.length; c--;)(c < x || c > y) && r.splice(c, 1); else v.angle = uc(v, b + l, 0), m = v[b += l], g = v[b + 1], v.length = v.totalLength = 0, v.totalPoints = r.totalPoints = 8, v.push(m, g, m, g, m, g, m, g); return r.totalLength = 0, r } function dc(e, t, n) { t = t || 0, e.samples || (e.samples = [], e.lookup = []); var i, r, s, a, o, l, c, u, h, d, p, f, m, g, v, _, y, x = ~~e.resolution || 12, b = 1 / x, E = n ? t + 6 * n + 1 : e.length, T = e[t], S = e[t + 1], M = t ? t / 6 * x : 0, w = e.samples, A = e.lookup, D = (t ? e.minLength : ql) || ql, C = w[M + n * x - 1], R = t ? w[M - 1] : 0; for (w.length = A.length = 0, r = t + 2; r < E; r += 6) { if (s = e[r + 4] - T, a = e[r + 2] - T, o = e[r] - T, u = e[r + 5] - S, h = e[r + 3] - S, d = e[r + 1] - S, l = c = p = f = 0, Wl(s) < .01 && Wl(u) < .01 && Wl(o) + Wl(d) < .01) e.length > 8 && (e.splice(r, 6), r -= 6, E -= 6); else for (i = 1; i <= x; i++)l = c - (c = ((g = b * i) * g * s + 3 * (m = 1 - g) * (g * a + m * o)) * g), p = f - (f = (g * g * u + 3 * m * (g * h + m * d)) * g), (_ = jl(p * p + l * l)) < D && (D = _), R += _, w[M++] = R; T += s, S += u } if (C) for (C -= R; M < w.length; M++)w[M] += C; if (w.length && D) { if (e.totalLength = y = w[w.length - 1] || 0, e.minLength = D, y / D < 9999) for (_ = v = 0, i = 0; i < y; i += D)A[_++] = w[v] < i ? ++v : v } else e.totalLength = w[0] = 0; return t ? R - w[t / 2 - 1] : R } function pc(e, t) { var n, i, r; for (r = n = i = 0; r < e.length; r++)e[r].resolution = ~~t || 12, i += e[r].length, n += dc(e[r]); return e.totalPoints = i, e.totalLength = n, e } function fc(e, t, n) { if (n <= 0 || n >= 1) return 0; var i = e[t], r = e[t + 1], s = e[t + 2], a = e[t + 3], o = e[t + 4], l = e[t + 5], c = i + (s - i) * n, u = s + (o - s) * n, h = r + (a - r) * n, d = a + (l - a) * n, p = c + (u - c) * n, f = h + (d - h) * n, m = o + (e[t + 6] - o) * n, g = l + (e[t + 7] - l) * n; return u += (m - u) * n, d += (g - d) * n, e.splice(t + 2, 4, ec(c), ec(h), ec(p), ec(f), ec(p + (u - p) * n), ec(f + (d - f) * n), ec(u), ec(d), ec(m), ec(g)), e.samples && e.samples.splice(t / 6 * e.resolution | 0, 0, 0, 0, 0, 0, 0, 0), 6 } function mc(e, t, n, i) { n = n || {}, e.totalLength || pc(e), (t < 0 || t > 1) && (t = Ql(t)); var r, s, a, o, l, c, u, h = 0, d = e[0]; if (t) if (1 === t) u = 1, c = (d = e[h = e.length - 1]).length - 8; else { if (e.length > 1) { for (a = e.totalLength * t, l = c = 0; (l += e[c++].totalLength) < a;)h = c; t = (a - (o = l - (d = e[h]).totalLength)) / (l - o) || 0 } r = d.samples, s = d.resolution, a = d.totalLength * t, o = (c = d.lookup.length ? d.lookup[~~(a / d.minLength)] || 0 : ic(r, a, t)) ? r[c - 1] : 0, (l = r[c]) < a && (o = l, l = r[++c]), u = 1 / s * ((a - o) / (l - o) + c % s), c = 6 * ~~(c / s), i && 1 === u && (c + 6 < d.length ? (c += 6, u = 0) : h + 1 < e.length && (c = u = 0, d = e[++h])) } else u = c = h = 0, d = e[0]; return n.t = u, n.i = c, n.path = e, n.segment = d, n.segIndex = h, n } function gc(e, t, n, i) { var r, s, a, o, l, c, u, h, d, p = e[0], f = i || {}; if ((t < 0 || t > 1) && (t = Ql(t)), p.lookup || pc(e), e.length > 1) { for (a = e.totalLength * t, l = c = 0; (l += e[c++].totalLength) < a;)p = e[c]; t = (a - (o = l - p.totalLength)) / (l - o) || 0 } return r = p.samples, s = p.resolution, a = p.totalLength * t, o = (c = p.lookup.length ? p.lookup[t < 1 ? ~~(a / p.minLength) : p.lookup.length - 1] || 0 : ic(r, a, t)) ? r[c - 1] : 0, (l = r[c]) < a && (o = l, l = r[++c]), d = 1 - (u = 1 / s * ((a - o) / (l - o) + c % s) || 0), h = p[c = 6 * ~~(c / s)], f.x = ec((u * u * (p[c + 6] - h) + 3 * d * (u * (p[c + 4] - h) + d * (p[c + 2] - h))) * u + h), f.y = ec((u * u * (p[c + 7] - (h = p[c + 1])) + 3 * d * (u * (p[c + 5] - h) + d * (p[c + 3] - h))) * u + h), n && (f.angle = p.totalLength ? uc(p, c, u >= 1 ? 1 - 1e-9 : u || 1e-9) : p.angle || 0), f } function vc(e, t, n, i, r, s, a) { for (var o, l, c, u, h, d = e.length; --d > -1;)for (l = (o = e[d]).length, c = 0; c < l; c += 2)u = o[c], h = o[c + 1], o[c] = u * t + h * i + s, o[c + 1] = u * n + h * r + a; return e._dirty = 1, e } function _c(e, t, n, i, r, s, a, o, l) { if (e !== o || t !== l) { n = Wl(n), i = Wl(i); var c = r % 360 * zl, u = Vl(c), h = Gl(c), d = Math.PI, p = 2 * d, f = (e - o) / 2, m = (t - l) / 2, g = u * f + h * m, v = -h * f + u * m, _ = g * g, y = v * v, x = _ / (n * n) + y / (i * i); x > 1 && (n = jl(x) * n, i = jl(x) * i); var b = n * n, E = i * i, T = (b * E - b * y - E * _) / (b * y + E * _); T < 0 && (T = 0); var S = (s === a ? -1 : 1) * jl(T), M = S * (n * v / i), w = S * (-i * g / n), A = (e + o) / 2 + (u * M - h * w), D = (t + l) / 2 + (h * M + u * w), C = (g - M) / n, R = (v - w) / i, L = (-g - M) / n, P = (-v - w) / i, I = C * C + R * R, N = (R < 0 ? -1 : 1) * Math.acos(C / jl(I)), O = (C * P - R * L < 0 ? -1 : 1) * Math.acos((C * L + R * P) / jl(I * (L * L + P * P))); isNaN(O) && (O = d), !a && O > 0 ? O -= p : a && O < 0 && (O += p), N %= p, O %= p; var F, U = Math.ceil(Wl(O) / (p / 4)), B = [], k = O / U, z = 4 / 3 * Gl(k / 2) / (1 + Vl(k / 2)), H = u * n, G = h * n, V = h * -i, W = u * i; for (F = 0; F < U; F++)g = Vl(r = N + F * k), v = Gl(r), C = Vl(r += k), R = Gl(r), B.push(g - z * v, v + z * g, C + z * R, R - z * C, C, R); for (F = 0; F < B.length; F += 2)g = B[F], v = B[F + 1], B[F] = g * H + v * V + A, B[F + 1] = g * G + v * W + D; return B[F - 2] = o, B[F - 1] = l, B } } function yc(e) { var t, n, i, r, s, a, o, l, c, u, h, d, p, f, m, g = (e + "").replace(Bl, (function (e) { var t = +e; return t < 1e-4 && t > -1e-4 ? 0 : t })).match(Fl) || [], v = [], _ = 0, y = 0, x = 2 / 3, b = g.length, E = 0, T = "ERROR: malformed path: " + e, S = function (e, t, n, i) { u = (n - e) / 3, h = (i - t) / 3, o.push(e + u, t + h, n - u, i - h, n, i) }; if (!e || !isNaN(g[0]) || isNaN(g[1])) return console.log(T), v; for (t = 0; t < b; t++)if (p = s, isNaN(g[t]) ? a = (s = g[t].toUpperCase()) !== g[t] : t--, i = +g[t + 1], r = +g[t + 2], a && (i += _, r += y), t || (l = i, c = r), "M" === s) o && (o.length < 8 ? v.length -= 1 : E += o.length), _ = l = i, y = c = r, o = [i, r], v.push(o), t += 2, s = "L"; else if ("C" === s) o || (o = [0, 0]), a || (_ = y = 0), o.push(i, r, _ + 1 * g[t + 3], y + 1 * g[t + 4], _ += 1 * g[t + 5], y += 1 * g[t + 6]), t += 6; else if ("S" === s) u = _, h = y, "C" !== p && "S" !== p || (u += _ - o[o.length - 4], h += y - o[o.length - 3]), a || (_ = y = 0), o.push(u, h, i, r, _ += 1 * g[t + 3], y += 1 * g[t + 4]), t += 4; else if ("Q" === s) u = _ + (i - _) * x, h = y + (r - y) * x, a || (_ = y = 0), _ += 1 * g[t + 3], y += 1 * g[t + 4], o.push(u, h, _ + (i - _) * x, y + (r - y) * x, _, y), t += 4; else if ("T" === s) u = _ - o[o.length - 4], h = y - o[o.length - 3], o.push(_ + u, y + h, i + (_ + 1.5 * u - i) * x, r + (y + 1.5 * h - r) * x, _ = i, y = r), t += 2; else if ("H" === s) S(_, y, _ = i, y), t += 1; else if ("V" === s) S(_, y, _, y = i + (a ? y - _ : 0)), t += 1; else if ("L" === s || "Z" === s) "Z" === s && (i = l, r = c, o.closed = !0), ("L" === s || Wl(_ - i) > .5 || Wl(y - r) > .5) && (S(_, y, i, r), "L" === s && (t += 2)), _ = i, y = r; else if ("A" === s) { if (f = g[t + 4], m = g[t + 5], u = g[t + 6], h = g[t + 7], n = 7, f.length > 1 && (f.length < 3 ? (h = u, u = m, n--) : (h = m, u = f.substr(2), n -= 2), m = f.charAt(1), f = f.charAt(0)), d = _c(_, y, +g[t + 1], +g[t + 2], +g[t + 3], +f, +m, (a ? _ : 0) + 1 * u, (a ? y : 0) + 1 * h), t += n, d) for (n = 0; n < d.length; n++)o.push(d[n]); _ = o[o.length - 2], y = o[o.length - 1] } else console.log(T); return (t = o.length) < 6 ? (v.pop(), t = 0) : o[0] === o[t - 2] && o[1] === o[t - 1] && (o.closed = !0), v.totalPoints = E + t, v } function xc(e, t) { void 0 === t && (t = 1); for (var n = e[0], i = 0, r = [n, i], s = 2; s < e.length; s += 2)r.push(n, i, e[s], i = (e[s] - n) * t / 2, n = e[s], -i); return r } function bc(e, t) { Wl(e[0] - e[2]) < 1e-4 && Wl(e[1] - e[3]) < 1e-4 && (e = e.slice(2)); var n, i, r, s, a, o, l, c, u, h, d, p, f, m, g = e.length - 2, v = +e[0], _ = +e[1], y = +e[2], x = +e[3], b = [v, _, v, _], E = y - v, T = x - _, S = Math.abs(e[g] - v) < .001 && Math.abs(e[g + 1] - _) < .001; for (S && (e.push(y, x), y = v, x = _, v = e[g - 2], _ = e[g - 1], e.unshift(v, _), g += 4), t = t || 0 === t ? +t : 1, r = 2; r < g; r += 2)n = v, i = _, v = y, _ = x, y = +e[r + 2], x = +e[r + 3], v === y && _ === x || (s = E, a = T, E = y - v, T = x - _, c = ((o = jl(s * s + a * a)) + (l = jl(E * E + T * T))) * t * .25 / jl(Math.pow(E / l + s / o, 2) + Math.pow(T / l + a / o, 2)), d = v - ((u = v - (v - n) * (o ? c / o : 0)) + (((h = v + (y - v) * (l ? c / l : 0)) - u) * (3 * o / (o + l) + .5) / 4 || 0)), m = _ - ((p = _ - (_ - i) * (o ? c / o : 0)) + (((f = _ + (x - _) * (l ? c / l : 0)) - p) * (3 * o / (o + l) + .5) / 4 || 0)), v === n && _ === i || b.push(ec(u + d), ec(p + m), ec(v), ec(_), ec(h + d), ec(f + m))); return v !== y || _ !== x || b.length < 4 ? b.push(ec(y), ec(x), ec(y), ec(x)) : b.length -= 2, 2 === b.length ? b.push(v, _, v, _, v, _) : S && (b.splice(0, 6), b.length = b.length - 6), b } function Ec(e) { Kl(e[0]) && (e = [e]); var t, n, i, r, s = "", a = e.length; for (n = 0; n < a; n++) { for (r = e[n], s += "M" + ec(r[0]) + "," + ec(r[1]) + " C", t = r.length, i = 2; i < t; i++)s += ec(r[i++]) + "," + ec(r[i++]) + " " + ec(r[i++]) + "," + ec(r[i++]) + " " + ec(r[i++]) + "," + ec(r[i]) + " "; r.closed && (s += "z") } return s } var Tc, Sc, Mc, wc, Ac, Dc, Cc, Rc, Lc, Pc = "transform", Ic = Pc + "Origin", Nc = function (e) { var t = e.ownerDocument || e; !(Pc in e.style) && "msTransform" in e.style && (Ic = (Pc = "msTransform") + "Origin"); for (; t.parentNode && (t = t.parentNode);); if (Sc = window, Cc = new Gc, t) { Tc = t, Mc = t.documentElement, wc = t.body, (Rc = Tc.createElementNS("http://www.w3.org/2000/svg", "g")).style.transform = "none"; var n = t.createElement("div"), i = t.createElement("div"); wc.appendChild(n), n.appendChild(i), n.style.position = "static", n.style[Pc] = "translate3d(0,0,1px)", Lc = i.offsetParent !== n, wc.removeChild(n) } return t }, Oc = [], Fc = [], Uc = function (e) { return e.ownerSVGElement || ("svg" === (e.tagName + "").toLowerCase() ? e : null) }, Bc = function e(t) { return "fixed" === Sc.getComputedStyle(t).position || ((t = t.parentNode) && 1 === t.nodeType ? e(t) : void 0) }, kc = function e(t, n) { if (t.parentNode && (Tc || Nc(t))) { var i = Uc(t), r = i ? i.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", s = i ? n ? "rect" : "g" : "div", a = 2 !== n ? 0 : 100, o = 3 === n ? 100 : 0, l = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;", c = Tc.createElementNS ? Tc.createElementNS(r.replace(/^https/, "http"), s) : Tc.createElement(s); return n && (i ? (Dc || (Dc = e(t)), c.setAttribute("width", .01), c.setAttribute("height", .01), c.setAttribute("transform", "translate(" + a + "," + o + ")"), Dc.appendChild(c)) : (Ac || ((Ac = e(t)).style.cssText = l), c.style.cssText = l + "width:0.1px;height:0.1px;top:" + o + "px;left:" + a + "px", Ac.appendChild(c))), c } throw "Need document and parent." }, zc = function (e, t) { var n, i, r, s, a, o, l = Uc(e), c = e === l, u = l ? Oc : Fc, h = e.parentNode; if (e === Sc) return e; if (u.length || u.push(kc(e, 1), kc(e, 2), kc(e, 3)), n = l ? Dc : Ac, l) c ? (r = function (e) { var t, n = e.getCTM(); return n || (t = e.style[Pc], e.style[Pc] = "none", e.appendChild(Rc), n = Rc.getCTM(), e.removeChild(Rc), t ? e.style[Pc] = t : e.style.removeProperty(Pc.replace(/([A-Z])/g, "-$1").toLowerCase())), n || Cc.clone() }(e), s = -r.e / r.a, a = -r.f / r.d, i = Cc) : e.getBBox ? (r = e.getBBox(), i = (i = e.transform ? e.transform.baseVal : {}).numberOfItems ? i.numberOfItems > 1 ? function (e) { for (var t = new Gc, n = 0; n < e.numberOfItems; n++)t.multiply(e.getItem(n).matrix); return t }(i) : i.getItem(0).matrix : Cc, s = i.a * r.x + i.c * r.y, a = i.b * r.x + i.d * r.y) : (i = new Gc, s = a = 0), t && "g" === e.tagName.toLowerCase() && (s = a = 0), (c ? l : h).appendChild(n), n.setAttribute("transform", "matrix(" + i.a + "," + i.b + "," + i.c + "," + i.d + "," + (i.e + s) + "," + (i.f + a) + ")"); else { if (s = a = 0, Lc) for (i = e.offsetParent, r = e; r && (r = r.parentNode) && r !== i && r.parentNode;)(Sc.getComputedStyle(r)[Pc] + "").length > 4 && (s = r.offsetLeft, a = r.offsetTop, r = 0); if ("absolute" !== (o = Sc.getComputedStyle(e)).position && "fixed" !== o.position) for (i = e.offsetParent; h && h !== i;)s += h.scrollLeft || 0, a += h.scrollTop || 0, h = h.parentNode; (r = n.style).top = e.offsetTop - a + "px", r.left = e.offsetLeft - s + "px", r[Pc] = o[Pc], r[Ic] = o[Ic], r.position = "fixed" === o.position ? "fixed" : "absolute", e.parentNode.appendChild(n) } return n }, Hc = function (e, t, n, i, r, s, a) { return e.a = t, e.b = n, e.c = i, e.d = r, e.e = s, e.f = a, e }, Gc = function () { function e(e, t, n, i, r, s) { void 0 === e && (e = 1), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 1), void 0 === r && (r = 0), void 0 === s && (s = 0), Hc(this, e, t, n, i, r, s) } var t = e.prototype; return t.inverse = function () { var e = this.a, t = this.b, n = this.c, i = this.d, r = this.e, s = this.f, a = e * i - t * n || 1e-10; return Hc(this, i / a, -t / a, -n / a, e / a, (n * s - i * r) / a, -(e * s - t * r) / a) }, t.multiply = function (e) { var t = this.a, n = this.b, i = this.c, r = this.d, s = this.e, a = this.f, o = e.a, l = e.c, c = e.b, u = e.d, h = e.e, d = e.f; return Hc(this, o * t + c * i, o * n + c * r, l * t + u * i, l * n + u * r, s + h * t + d * i, a + h * n + d * r) }, t.clone = function () { return new e(this.a, this.b, this.c, this.d, this.e, this.f) }, t.equals = function (e) { var t = this.a, n = this.b, i = this.c, r = this.d, s = this.e, a = this.f; return t === e.a && n === e.b && i === e.c && r === e.d && s === e.e && a === e.f }, t.apply = function (e, t) { void 0 === t && (t = {}); var n = e.x, i = e.y, r = this.a, s = this.b, a = this.c, o = this.d, l = this.e, c = this.f; return t.x = n * r + i * a + l || 0, t.y = n * s + i * o + c || 0, t }, e }(); function Vc(e, t, n, i) { if (!e || !e.parentNode || (Tc || Nc(e)).documentElement === e) return new Gc; var r = function (e) { for (var t, n; e && e !== wc;)(n = e._gsap) && n.uncache && n.get(e, "x"), n && !n.scaleX && !n.scaleY && n.renderTransform && (n.scaleX = n.scaleY = 1e-4, n.renderTransform(1, n), t ? t.push(n) : t = [n]), e = e.parentNode; return t }(e), s = Uc(e) ? Oc : Fc, a = zc(e, n), o = s[0].getBoundingClientRect(), l = s[1].getBoundingClientRect(), c = s[2].getBoundingClientRect(), u = a.parentNode, h = !i && Bc(e), d = new Gc((l.left - o.left) / 100, (l.top - o.top) / 100, (c.left - o.left) / 100, (c.top - o.top) / 100, o.left + (h ? 0 : Sc.pageXOffset || Tc.scrollLeft || Mc.scrollLeft || wc.scrollLeft || 0), o.top + (h ? 0 : Sc.pageYOffset || Tc.scrollTop || Mc.scrollTop || wc.scrollTop || 0)); if (u.removeChild(a), r) for (o = r.length; o--;)(l = r[o]).scaleX = l.scaleY = 0, l.renderTransform(1, l); return t ? d.inverse() : d } var Wc, jc, Xc, qc, Yc, Kc, $c = "x,translateX,left,marginLeft,xPercent".split(","), Zc = "y,translateY,top,marginTop,yPercent".split(","), Jc = Math.PI / 180, Qc = function (e, t, n, i) { for (var r = t.length, s = 2 === i ? 0 : i, a = 0; a < r; a++)e[s] = parseFloat(t[a][n]), 2 === i && (e[s + 1] = 0), s += 2; return e }, eu = function (e, t, n) { return parseFloat(e._gsap.get(e, t, n || "px")) || 0 }, tu = function (e) { var t, n = e[0], i = e[1]; for (t = 2; t < e.length; t += 2)n = e[t] += n, i = e[t + 1] += i }, nu = function (e, t, n, i, r, s, a, o, l) { "cubic" === a.type ? t = [t] : (!1 !== a.fromCurrent && t.unshift(eu(n, i, o), r ? eu(n, r, l) : 0), a.relative && tu(t), t = [(r ? bc : xc)(t, a.curviness)]); return t = s(ou(t, n, a)), lu(e, n, i, t, "x", o), r && lu(e, n, r, t, "y", l), pc(t, a.resolution || (0 === a.curviness ? 20 : 12)) }, iu = function (e) { return e }, ru = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g, su = function (e, t, n) { var i, r = Vc(e), s = 0, a = 0; return "svg" === (e.tagName + "").toLowerCase() ? (i = e.viewBox.baseVal).width || (i = { width: +e.getAttribute("width"), height: +e.getAttribute("height") }) : i = t && e.getBBox && e.getBBox(), t && "auto" !== t && (s = t.push ? t[0] * (i ? i.width : e.offsetWidth || 0) : t.x, a = t.push ? t[1] * (i ? i.height : e.offsetHeight || 0) : t.y), n.apply(s || a ? r.apply({ x: s, y: a }) : { x: r.e, y: r.f }) }, au = function (e, t, n, i) { var r, s = Vc(e.parentNode, !0, !0), a = s.clone().multiply(Vc(t)), o = su(e, n, s), l = su(t, i, s), c = l.x, u = l.y; return a.e = a.f = 0, "auto" === i && t.getTotalLength && "path" === t.tagName.toLowerCase() && (r = t.getAttribute("d").match(ru) || [], c += (r = a.apply({ x: +r[0], y: +r[1] })).x, u += r.y), r && (c -= (r = a.apply(t.getBBox())).x, u -= r.y), a.e = c - o.x, a.f = u - o.y, a }, ou = function (e, t, n) { var i, r, s, a = n.align, o = n.matrix, l = n.offsetX, c = n.offsetY, u = n.alignOrigin, h = e[0][0], d = e[0][1], p = eu(t, "x"), f = eu(t, "y"); return e && e.length ? (a && ("self" === a || (i = qc(a)[0] || t) === t ? vc(e, 1, 0, 0, 1, p - h, f - d) : (u && !1 !== u[2] ? Wc.set(t, { transformOrigin: 100 * u[0] + "% " + 100 * u[1] + "%" }) : u = [eu(t, "xPercent") / -100, eu(t, "yPercent") / -100], s = (r = au(t, i, u, "auto")).apply({ x: h, y: d }), vc(e, r.a, r.b, r.c, r.d, p + r.e - (s.x - r.e), f + r.f - (s.y - r.f)))), o ? vc(e, o.a, o.b, o.c, o.d, o.e, o.f) : (l || c) && vc(e, 1, 0, 0, 1, l || 0, c || 0), e) : ac("M0,0L0,0") }, lu = function (e, t, n, i, r, s) { var a = t._gsap, o = a.harness, l = o && o.aliases && o.aliases[n], c = l && l.indexOf(",") < 0 ? l : n, u = e._pt = new jc(e._pt, t, c, 0, 0, iu, 0, a.set(t, c, e)); u.u = Xc(a.get(t, c, s)) || 0, u.path = i, u.pp = r, e._props.push(c) }, cu = { version: "3.11.5", name: "motionPath", register: function (e, t, n) { Xc = (Wc = e).utils.getUnit, qc = Wc.utils.toArray, Yc = Wc.core.getStyleSaver, Kc = Wc.core.reverting || function () { }, jc = n }, init: function (e, t, n) { if (!Wc) return console.warn("Please gsap.registerPlugin(MotionPathPlugin)"), !1; "object" == typeof t && !t.style && t.path || (t = { path: t }); var i, r, s, a, o = [], l = t, c = l.path, u = l.autoRotate, h = l.unitX, d = l.unitY, p = l.x, f = l.y, m = c[0], g = (s = t.start, a = "end" in t ? t.end : 1, function (e) { return s || 1 !== a ? hc(e, s, a) : e }); if (this.rawPaths = o, this.target = e, this.tween = n, this.styles = Yc && Yc(e, "transform"), (this.rotate = u || 0 === u) && (this.rOffset = parseFloat(u) || 0, this.radians = !!t.useRadians, this.rProp = t.rotation || "rotation", this.rSet = e._gsap.set(e, this.rProp, this), this.ru = Xc(e._gsap.get(e, this.rProp)) || 0), Array.isArray(c) && !("closed" in c) && "number" != typeof m) { for (r in m) !p && ~$c.indexOf(r) ? p = r : !f && ~Zc.indexOf(r) && (f = r); for (r in p && f ? o.push(nu(this, Qc(Qc([], c, p, 0), c, f, 1), e, p, f, g, t, h || Xc(c[0][p]), d || Xc(c[0][f]))) : p = f = 0, m) r !== p && r !== f && o.push(nu(this, Qc([], c, r, 2), e, r, 0, g, t, Xc(c[0][r]))) } else pc(i = g(ou(ac(t.path), e, t)), t.resolution), o.push(i), lu(this, e, t.x || "x", i, "x", t.unitX || "px"), lu(this, e, t.y || "y", i, "y", t.unitY || "px") }, render: function (e, t) { var n = t.rawPaths, i = n.length, r = t._pt; if (t.tween._time || !Kc()) { for (e > 1 ? e = 1 : e < 0 && (e = 0); i--;)gc(n[i], e, !i && t.rotate, n[i]); for (; r;)r.set(r.t, r.p, r.path[r.pp] + r.u, r.d, e), r = r._next; t.rotate && t.rSet(t.target, t.rProp, n[0].angle * (t.radians ? Jc : 1) + t.rOffset + t.ru, t, e) } else t.styles.revert() }, getLength: function (e) { return pc(ac(e)).totalLength }, sliceRawPath: hc, getRawPath: ac, pointsToSegment: bc, stringToRawPath: yc, rawPathToString: Ec, transformRawPath: vc, getGlobalMatrix: Vc, getPositionOnPath: gc, cacheRawPathMeasurements: pc, convertToPath: function (e, t) { return qc(e).map((function (e) { return cc(e, !1 !== t) })) }, convertCoordinates: function (e, t, n) { var i = Vc(t, !0, !0).multiply(Vc(e)); return n ? i.apply(n) : i }, getAlignMatrix: au, getRelativePosition: function (e, t, n, i) { var r = au(e, t, n, i); return { x: r.e, y: r.f } }, arrayToRawPath: function (e, t) { var n = Qc(Qc([], e, (t = t || {}).x || "x", 0), e, t.y || "y", 1); return t.relative && tu(n), ["cubic" === t.type ? n : bc(n, t.curviness)] } }; (Wc || "undefined" != typeof window && (Wc = window.gsap) && Wc.registerPlugin && Wc) && Wc.registerPlugin(cu); const uu = "162", hu = 1, du = 2, pu = 3, fu = 0, mu = 1, gu = 100, vu = 0, _u = 1, yu = 2, xu = 0, bu = 1, Eu = 2, Tu = 3, Su = 4, Mu = 5, wu = 6, Au = 7, Du = "attached", Cu = 301, Ru = 302, Lu = 303, Pu = 304, Iu = 306, Nu = 1e3, Ou = 1001, Fu = 1002, Uu = 1003, Bu = 1004, ku = 1005, zu = 1006, Hu = 1007, Gu = 1008, Vu = 1009, Wu = 1012, ju = 1013, Xu = 1014, qu = 1015, Yu = 1016, Ku = 1020, $u = 1023, Zu = 1026, Ju = 1027, Qu = 33776, eh = 33777, th = 33778, nh = 33779, ih = 36492, rh = 2300, sh = 2301, ah = 2302, oh = 2400, lh = 2401, ch = 2402, uh = "", hh = "srgb", dh = "srgb-linear", ph = "display-p3", fh = "display-p3-linear", mh = "linear", gh = "srgb", vh = "rec709", _h = "p3", yh = 7680, xh = 35044, bh = "300 es", Eh = 1035, Th = 2e3, Sh = 2001; class Mh { addEventListener(e, t) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t) } hasEventListener(e, t) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[e] && -1 !== n[e].indexOf(t) } removeEventListener(e, t) { if (void 0 === this._listeners) return; const n = this._listeners[e]; if (void 0 !== n) { const e = n.indexOf(t); -1 !== e && n.splice(e, 1) } } dispatchEvent(e) { if (void 0 === this._listeners) return; const t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; const n = t.slice(0); for (let t = 0, i = n.length; t < i; t++)n[t].call(this, e); e.target = null } } } const wh = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let Ah = 1234567; const Dh = Math.PI / 180, Ch = 180 / Math.PI; function Rh() { const e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0; return (wh[255 & e] + wh[e >> 8 & 255] + wh[e >> 16 & 255] + wh[e >> 24 & 255] + "-" + wh[255 & t] + wh[t >> 8 & 255] + "-" + wh[t >> 16 & 15 | 64] + wh[t >> 24 & 255] + "-" + wh[63 & n | 128] + wh[n >> 8 & 255] + "-" + wh[n >> 16 & 255] + wh[n >> 24 & 255] + wh[255 & i] + wh[i >> 8 & 255] + wh[i >> 16 & 255] + wh[i >> 24 & 255]).toLowerCase() } function Lh(e, t, n) { return Math.max(t, Math.min(n, e)) } function Ph(e, t) { return (e % t + t) % t } function Ih(e, t, n) { return (1 - n) * e + n * t } function Nh(e) { return 0 == (e & e - 1) && 0 !== e } function Oh(e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) } function Fh(e, t) { switch (t.constructor) { case Float32Array: return e; case Uint32Array: return e / 4294967295; case Uint16Array: return e / 65535; case Uint8Array: return e / 255; case Int32Array: return Math.max(e / 2147483647, -1); case Int16Array: return Math.max(e / 32767, -1); case Int8Array: return Math.max(e / 127, -1); default: throw new Error("Invalid component type.") } } function Uh(e, t) { switch (t.constructor) { case Float32Array: return e; case Uint32Array: return Math.round(4294967295 * e); case Uint16Array: return Math.round(65535 * e); case Uint8Array: return Math.round(255 * e); case Int32Array: return Math.round(2147483647 * e); case Int16Array: return Math.round(32767 * e); case Int8Array: return Math.round(127 * e); default: throw new Error("Invalid component type.") } } const Bh = { DEG2RAD: Dh, RAD2DEG: Ch, generateUUID: Rh, clamp: Lh, euclideanModulo: Ph, mapLinear: function (e, t, n, i, r) { return i + (e - t) * (r - i) / (n - t) }, inverseLerp: function (e, t, n) { return e !== t ? (n - e) / (t - e) : 0 }, lerp: Ih, damp: function (e, t, n, i) { return Ih(e, t, 1 - Math.exp(-n * i)) }, pingpong: function (e, t = 1) { return t - Math.abs(Ph(e, 2 * t) - t) }, smoothstep: function (e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e) }, smootherstep: function (e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, seededRandom: function (e) { void 0 !== e && (Ah = e); let t = Ah += 1831565813; return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296 }, degToRad: function (e) { return e * Dh }, radToDeg: function (e) { return e * Ch }, isPowerOfTwo: Nh, ceilPowerOfTwo: function (e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) }, floorPowerOfTwo: Oh, setQuaternionFromProperEuler: function (e, t, n, i, r) { const s = Math.cos, a = Math.sin, o = s(n / 2), l = a(n / 2), c = s((t + i) / 2), u = a((t + i) / 2), h = s((t - i) / 2), d = a((t - i) / 2), p = s((i - t) / 2), f = a((i - t) / 2); switch (r) { case "XYX": e.set(o * u, l * h, l * d, o * c); break; case "YZY": e.set(l * d, o * u, l * h, o * c); break; case "ZXZ": e.set(l * h, l * d, o * u, o * c); break; case "XZX": e.set(o * u, l * f, l * p, o * c); break; case "YXY": e.set(l * p, o * u, l * f, o * c); break; case "ZYZ": e.set(l * f, l * p, o * u, o * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } }, normalize: Uh, denormalize: Fh }; class kh { constructor(e = 0, t = 0) { kh.prototype.isVector2 = !0, this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e) { return this.x += e.x, this.y += e.y, this } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, n = this.y, i = e.elements; return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (0 === t) return Math.PI / 2; const n = this.dot(e) / t; return Math.acos(Lh(n, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, n = this.y - e.y; return t * t + n * n } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const n = Math.cos(t), i = Math.sin(t), r = this.x - e.x, s = this.y - e.y; return this.x = r * n - s * i + e.x, this.y = r * i + s * n + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class zh { constructor(e, t, n, i, r, s, a, o, l) { zh.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, i, r, s, a, o, l) } set(e, t, n, i, r, s, a, o, l) { const c = this.elements; return c[0] = e, c[1] = i, c[2] = a, c[3] = t, c[4] = r, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this } extractBasis(e, t, n) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, i = t.elements, r = this.elements, s = n[0], a = n[3], o = n[6], l = n[1], c = n[4], u = n[7], h = n[2], d = n[5], p = n[8], f = i[0], m = i[3], g = i[6], v = i[1], _ = i[4], y = i[7], x = i[2], b = i[5], E = i[8]; return r[0] = s * f + a * v + o * x, r[3] = s * m + a * _ + o * b, r[6] = s * g + a * y + o * E, r[1] = l * f + c * v + u * x, r[4] = l * m + c * _ + u * b, r[7] = l * g + c * y + u * E, r[2] = h * f + d * v + p * x, r[5] = h * m + d * _ + p * b, r[8] = h * g + d * y + p * E, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], s = e[4], a = e[5], o = e[6], l = e[7], c = e[8]; return t * s * c - t * a * l - n * r * c + n * a * o + i * r * l - i * s * o } invert() { const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], s = e[4], a = e[5], o = e[6], l = e[7], c = e[8], u = c * s - a * l, h = a * o - c * r, d = l * r - s * o, p = t * u + n * h + i * d; if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const f = 1 / p; return e[0] = u * f, e[1] = (i * l - c * n) * f, e[2] = (a * n - i * s) * f, e[3] = h * f, e[4] = (c * t - i * o) * f, e[5] = (i * r - a * t) * f, e[6] = d * f, e[7] = (n * o - l * t) * f, e[8] = (s * t - n * r) * f, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, n, i, r, s, a) { const o = Math.cos(r), l = Math.sin(r); return this.set(n * o, n * l, -n * (o * s + l * a) + s + e, -i * l, i * o, -i * (-l * s + o * a) + a + t, 0, 0, 1), this } scale(e, t) { return this.premultiply(Hh.makeScale(e, t)), this } rotate(e) { return this.premultiply(Hh.makeRotation(-e)), this } translate(e, t) { return this.premultiply(Hh.makeTranslation(e, t)), this } makeTranslation(e, t) { return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this } makeRotation(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this } makeScale(e, t) { return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this } equals(e) { const t = this.elements, n = e.elements; for (let e = 0; e < 9; e++)if (t[e] !== n[e]) return !1; return !0 } fromArray(e, t = 0) { for (let n = 0; n < 9; n++)this.elements[n] = e[n + t]; return this } toArray(e = [], t = 0) { const n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e } clone() { return (new this.constructor).fromArray(this.elements) } } const Hh = new zh; function Gh(e) { for (let t = e.length - 1; t >= 0; --t)if (e[t] >= 65535) return !0; return !1 } Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array; function Vh(e) { return document.createElementNS("http://www.w3.org/1999/xhtml", e) } function Wh() { const e = Vh("canvas"); return e.style.display = "block", e } const jh = {}; function Xh(e) { e in jh || (jh[e] = !0, console.warn(e)) } const qh = (new zh).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199), Yh = (new zh).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735), Kh = { [dh]: { transfer: mh, primaries: vh, toReference: e => e, fromReference: e => e }, [hh]: { transfer: gh, primaries: vh, toReference: e => e.convertSRGBToLinear(), fromReference: e => e.convertLinearToSRGB() }, [fh]: { transfer: mh, primaries: _h, toReference: e => e.applyMatrix3(Yh), fromReference: e => e.applyMatrix3(qh) }, [ph]: { transfer: gh, primaries: _h, toReference: e => e.convertSRGBToLinear().applyMatrix3(Yh), fromReference: e => e.applyMatrix3(qh).convertLinearToSRGB() } }, $h = new Set([dh, fh]), Zh = { enabled: !0, _workingColorSpace: dh, get workingColorSpace() { return this._workingColorSpace }, set workingColorSpace(e) { if (!$h.has(e)) throw new Error(`Unsupported working color space, "${e}".`); this._workingColorSpace = e }, convert: function (e, t, n) { if (!1 === this.enabled || t === n || !t || !n) return e; const i = Kh[t].toReference; return (0, Kh[n].fromReference)(i(e)) }, fromWorkingColorSpace: function (e, t) { return this.convert(e, this._workingColorSpace, t) }, toWorkingColorSpace: function (e, t) { return this.convert(e, t, this._workingColorSpace) }, getPrimaries: function (e) { return Kh[e].primaries }, getTransfer: function (e) { return e === uh ? mh : Kh[e].transfer } }; function Jh(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } function Qh(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } let ed; class td { static getDataURL(e) { if (/^data:/i.test(e.src)) return e.src; if ("undefined" == typeof HTMLCanvasElement) return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { void 0 === ed && (ed = Vh("canvas")), ed.width = e.width, ed.height = e.height; const n = ed.getContext("2d"); e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = ed } return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } static sRGBToLinear(e) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { const t = Vh("canvas"); t.width = e.width, t.height = e.height; const n = t.getContext("2d"); n.drawImage(e, 0, 0, e.width, e.height); const i = n.getImageData(0, 0, e.width, e.height), r = i.data; for (let e = 0; e < r.length; e++)r[e] = 255 * Jh(r[e] / 255); return n.putImageData(i, 0, 0), t } if (e.data) { const t = e.data.slice(0); for (let e = 0; e < t.length; e++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Jh(t[e] / 255)) : t[e] = Jh(t[e]); return { data: t, width: e.width, height: e.height } } return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e } } let nd = 0; class id { constructor(e = null) { this.isSource = !0, Object.defineProperty(this, "id", { value: nd++ }), this.uuid = Rh(), this.data = e, this.dataReady = !0, this.version = 0 } set needsUpdate(e) { !0 === e && this.version++ } toJSON(e) { const t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid]; const n = { uuid: this.uuid, url: "" }, i = this.data; if (null !== i) { let e; if (Array.isArray(i)) { e = []; for (let t = 0, n = i.length; t < n; t++)i[t].isDataTexture ? e.push(rd(i[t].image)) : e.push(rd(i[t])) } else e = rd(i); n.url = e } return t || (e.images[this.uuid] = n), n } } function rd(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? td.getDataURL(e) : e.data ? { data: Array.from(e.data), width: e.width, height: e.height, type: e.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let sd = 0; class ad extends Mh { constructor(e = ad.DEFAULT_IMAGE, t = ad.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, a = 1023, o = 1009, l = ad.DEFAULT_ANISOTROPY, c = "") { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: sd++ }), this.uuid = Rh(), this.name = "", this.source = new id(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new kh(0, 0), this.repeat = new kh(1, 1), this.center = new kh(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new zh, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1 } get image() { return this.source.data } set image(e = null) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } toJSON(e) { const t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; const n = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (300 !== this.mapping) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case Nu: e.x = e.x - Math.floor(e.x); break; case Ou: e.x = e.x < 0 ? 0 : 1; break; case Fu: 1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case Nu: e.y = e.y - Math.floor(e.y); break; case Ou: e.y = e.y < 0 ? 0 : 1; break; case Fu: 1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { !0 === e && (this.version++, this.source.needsUpdate = !0) } } ad.DEFAULT_IMAGE = null, ad.DEFAULT_MAPPING = 300, ad.DEFAULT_ANISOTROPY = 1; class od { constructor(e = 0, t = 0, n = 0, i = 1) { od.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, n, i) { return this.x = e, this.y = t, this.z = n, this.w = i, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, n = this.y, i = this.z, r = this.w, s = e.elements; return this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, n, i, r; const s = .01, a = .1, o = e.elements, l = o[0], c = o[4], u = o[8], h = o[1], d = o[5], p = o[9], f = o[2], m = o[6], g = o[10]; if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(p - m) < s) { if (Math.abs(c + h) < a && Math.abs(u + f) < a && Math.abs(p + m) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this; t = Math.PI; const e = (l + 1) / 2, o = (d + 1) / 2, v = (g + 1) / 2, _ = (c + h) / 4, y = (u + f) / 4, x = (p + m) / 4; return e > o && e > v ? e < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(e), i = _ / n, r = y / n) : o > v ? o < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(o), n = _ / i, r = x / i) : v < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = y / r, i = x / r), this.set(n, i, r, t), this } let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c)); return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (u - f) / v, this.z = (h - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class ld extends Mh { constructor(e = 1, t = 1, n = {}) { super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new od(0, 0, e, t), this.scissorTest = !1, this.viewport = new od(0, 0, e, t); const i = { width: e, height: t, depth: 1 }; n = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: zu, depthBuffer: !0, stencilBuffer: !1, depthTexture: null, samples: 0, count: 1 }, n); const r = new ad(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace); r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = []; const s = n.count; for (let e = 0; e < s; e++)this.textures[e] = r.clone(), this.textures[e].isRenderTargetTexture = !0; this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples } get texture() { return this.textures[0] } set texture(e) { this.textures[0] = e } setSize(e, t, n = 1) { if (this.width !== e || this.height !== t || this.depth !== n) { this.width = e, this.height = t, this.depth = n; for (let i = 0, r = this.textures.length; i < r; i++)this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n; this.dispose() } this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0; for (let t = 0, n = e.textures.length; t < n; t++)this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0; const t = Object.assign({}, e.texture.image); return this.texture.source = new id(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class cd extends ld { constructor(e = 1, t = 1, n = {}) { super(e, t, n), this.isWebGLRenderTarget = !0 } } class ud extends ad { constructor(e = null, t = 1, n = 1, i = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = Uu, this.minFilter = Uu, this.wrapR = Ou, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class hd extends ad { constructor(e = null, t = 1, n = 1, i = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = Uu, this.minFilter = Uu, this.wrapR = Ou, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class dd { constructor(e = 0, t = 0, n = 0, i = 1) { this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i } static slerpFlat(e, t, n, i, r, s, a) { let o = n[i + 0], l = n[i + 1], c = n[i + 2], u = n[i + 3]; const h = r[s + 0], d = r[s + 1], p = r[s + 2], f = r[s + 3]; if (0 === a) return e[t + 0] = o, e[t + 1] = l, e[t + 2] = c, void (e[t + 3] = u); if (1 === a) return e[t + 0] = h, e[t + 1] = d, e[t + 2] = p, void (e[t + 3] = f); if (u !== f || o !== h || l !== d || c !== p) { let e = 1 - a; const t = o * h + l * d + c * p + u * f, n = t >= 0 ? 1 : -1, i = 1 - t * t; if (i > Number.EPSILON) { const r = Math.sqrt(i), s = Math.atan2(r, t * n); e = Math.sin(e * s) / r, a = Math.sin(a * s) / r } const r = a * n; if (o = o * e + h * r, l = l * e + d * r, c = c * e + p * r, u = u * e + f * r, e === 1 - a) { const e = 1 / Math.sqrt(o * o + l * l + c * c + u * u); o *= e, l *= e, c *= e, u *= e } } e[t] = o, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u } static multiplyQuaternionsFlat(e, t, n, i, r, s) { const a = n[i], o = n[i + 1], l = n[i + 2], c = n[i + 3], u = r[s], h = r[s + 1], d = r[s + 2], p = r[s + 3]; return e[t] = a * p + c * u + o * d - l * h, e[t + 1] = o * p + c * h + l * u - a * d, e[t + 2] = l * p + c * d + a * h - o * u, e[t + 3] = c * p - a * u - o * h - l * d, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, n, i) { return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t = !0) { const n = e._x, i = e._y, r = e._z, s = e._order, a = Math.cos, o = Math.sin, l = a(n / 2), c = a(i / 2), u = a(r / 2), h = o(n / 2), d = o(i / 2), p = o(r / 2); switch (s) { case "XYZ": this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p; break; case "YXZ": this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p; break; case "ZXY": this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p; break; case "ZYX": this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p; break; case "YZX": this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p; break; case "XZY": this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s) }return !0 === t && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const n = t / 2, i = Math.sin(n); return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, n = t[0], i = t[4], r = t[8], s = t[1], a = t[5], o = t[9], l = t[2], c = t[6], u = t[10], h = n + a + u; if (h > 0) { const e = .5 / Math.sqrt(h + 1); this._w = .25 / e, this._x = (c - o) * e, this._y = (r - l) * e, this._z = (s - i) * e } else if (n > a && n > u) { const e = 2 * Math.sqrt(1 + n - a - u); this._w = (c - o) / e, this._x = .25 * e, this._y = (i + s) / e, this._z = (r + l) / e } else if (a > u) { const e = 2 * Math.sqrt(1 + a - n - u); this._w = (r - l) / e, this._x = (i + s) / e, this._y = .25 * e, this._z = (o + c) / e } else { const e = 2 * Math.sqrt(1 + u - n - a); this._w = (s - i) / e, this._x = (r + l) / e, this._y = (o + c) / e, this._z = .25 * e } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let n = e.dot(t) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(Lh(this.dot(e), -1, 1))) } rotateTowards(e, t) { const n = this.angleTo(e); if (0 === n) return this; const i = Math.min(1, t / n); return this.slerp(e, i), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e) { return this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const n = e._x, i = e._y, r = e._z, s = e._w, a = t._x, o = t._y, l = t._z, c = t._w; return this._x = n * c + s * a + i * l - r * o, this._y = i * c + s * o + r * a - n * l, this._z = r * c + s * l + n * o - i * a, this._w = s * c - n * a - i * o - r * l, this._onChangeCallback(), this } slerp(e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); const n = this._x, i = this._y, r = this._z, s = this._w; let a = s * e._w + n * e._x + i * e._y + r * e._z; if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this; const o = 1 - a * a; if (o <= Number.EPSILON) { const e = 1 - t; return this._w = e * s + t * this._w, this._x = e * n + t * this._x, this._y = e * i + t * this._y, this._z = e * r + t * this._z, this.normalize(), this } const l = Math.sqrt(o), c = Math.atan2(l, a), u = Math.sin((1 - t) * c) / l, h = Math.sin(t * c) / l; return this._w = s * u + this._w * h, this._x = n * u + this._x * h, this._y = i * u + this._y * h, this._z = r * u + this._z * h, this._onChangeCallback(), this } slerpQuaternions(e, t, n) { return this.copy(e).slerp(t, n) } random() { const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), r = Math.sqrt(n); return this.set(i * Math.sin(e), i * Math.cos(e), r * Math.sin(t), r * Math.cos(t)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this } toJSON() { return this.toArray() } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class pd { constructor(e = 0, t = 0, n = 0) { pd.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n } set(e, t, n) { return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return this.applyQuaternion(md.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(md.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, n = this.y, i = this.z, r = e.elements; return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, n = this.y, i = this.z, r = e.elements, s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]); return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s, this } applyQuaternion(e) { const t = this.x, n = this.y, i = this.z, r = e.x, s = e.y, a = e.z, o = e.w, l = 2 * (s * i - a * n), c = 2 * (a * t - r * i), u = 2 * (r * n - s * t); return this.x = t + o * l + s * u - a * c, this.y = n + o * c + a * l - r * u, this.z = i + o * u + r * c - s * l, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, n = this.y, i = this.z, r = e.elements; return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this } cross(e) { return this.crossVectors(this, e) } crossVectors(e, t) { const n = e.x, i = e.y, r = e.z, s = t.x, a = t.y, o = t.z; return this.x = i * o - r * a, this.y = r * s - n * o, this.z = n * a - i * s, this } projectOnVector(e) { const t = e.lengthSq(); if (0 === t) return this.set(0, 0, 0); const n = e.dot(this) / t; return this.copy(e).multiplyScalar(n) } projectOnPlane(e) { return fd.copy(this).projectOnVector(e), this.sub(fd) } reflect(e) { return this.sub(fd.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (0 === t) return Math.PI / 2; const n = this.dot(e) / t; return Math.acos(Lh(n, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z; return t * t + n * n + i * i } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, n) { const i = Math.sin(t) * e; return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, n) { return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = n, this.z = i, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, 4 * t) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, 3 * t) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } setFromColor(e) { return this.x = e.r, this.y = e.g, this.z = e.b, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const e = Math.random() * Math.PI * 2, t = 2 * Math.random() - 1, n = Math.sqrt(1 - t * t); return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const fd = new pd, md = new dd; class gd { constructor(e = new pd(1 / 0, 1 / 0, 1 / 0), t = new pd(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t += 3)this.expandByPoint(_d.fromArray(e, t)); return this } setFromBufferAttribute(e) { this.makeEmpty(); for (let t = 0, n = e.count; t < n; t++)this.expandByPoint(_d.fromBufferAttribute(e, t)); return this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const n = _d.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } setFromObject(e, t = !1) { return this.makeEmpty(), this.expandByObject(e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, t = !1) { e.updateWorldMatrix(!1, !1); const n = e.geometry; if (void 0 !== n) { const i = n.getAttribute("position"); if (!0 === t && void 0 !== i && !0 !== e.isInstancedMesh) for (let t = 0, n = i.count; t < n; t++)!0 === e.isMesh ? e.getVertexPosition(t, _d) : _d.fromBufferAttribute(i, t), _d.applyMatrix4(e.matrixWorld), this.expandByPoint(_d); else void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(), yd.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), yd.copy(n.boundingBox)), yd.applyMatrix4(e.matrixWorld), this.union(yd) } const i = e.children; for (let e = 0, n = i.length; e < n; e++)this.expandByObject(i[e], t); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, _d), _d.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, n; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(wd), Ad.subVectors(this.max, wd), xd.subVectors(e.a, wd), bd.subVectors(e.b, wd), Ed.subVectors(e.c, wd), Td.subVectors(bd, xd), Sd.subVectors(Ed, bd), Md.subVectors(xd, Ed); let t = [0, -Td.z, Td.y, 0, -Sd.z, Sd.y, 0, -Md.z, Md.y, Td.z, 0, -Td.x, Sd.z, 0, -Sd.x, Md.z, 0, -Md.x, -Td.y, Td.x, 0, -Sd.y, Sd.x, 0, -Md.y, Md.x, 0]; return !!Rd(t, xd, bd, Ed, Ad) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Rd(t, xd, bd, Ed, Ad) && (Dd.crossVectors(Td, Sd), t = [Dd.x, Dd.y, Dd.z], Rd(t, xd, bd, Ed, Ad))) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, _d).distanceTo(e) } getBoundingSphere(e) { return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = .5 * this.getSize(_d).length()), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() || (vd[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), vd[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), vd[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), vd[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), vd[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), vd[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), vd[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), vd[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(vd)), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const vd = [new pd, new pd, new pd, new pd, new pd, new pd, new pd, new pd], _d = new pd, yd = new gd, xd = new pd, bd = new pd, Ed = new pd, Td = new pd, Sd = new pd, Md = new pd, wd = new pd, Ad = new pd, Dd = new pd, Cd = new pd; function Rd(e, t, n, i, r) { for (let s = 0, a = e.length - 3; s <= a; s += 3) { Cd.fromArray(e, s); const a = r.x * Math.abs(Cd.x) + r.y * Math.abs(Cd.y) + r.z * Math.abs(Cd.z), o = t.dot(Cd), l = n.dot(Cd), c = i.dot(Cd); if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1 } return !0 } const Ld = new gd, Pd = new pd, Id = new pd; class Nd { constructor(e = new pd, t = -1) { this.isSphere = !0, this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const n = this.center; void 0 !== t ? n.copy(t) : Ld.setFromPoints(e).getCenter(n); let i = 0; for (let t = 0, r = e.length; t < r; t++)i = Math.max(i, n.distanceToSquared(e[t])); return this.radius = Math.sqrt(i), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const n = this.center.distanceToSquared(e); return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this; Pd.subVectors(e, this.center); const t = Pd.lengthSq(); if (t > this.radius * this.radius) { const e = Math.sqrt(t), n = .5 * (e - this.radius); this.center.addScaledVector(Pd, n / e), this.radius += n } return this } union(e) { return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (Id.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Pd.copy(e.center).add(Id)), this.expandByPoint(Pd.copy(e.center).sub(Id))), this) } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return (new this.constructor).copy(this) } } const Od = new pd, Fd = new pd, Ud = new pd, Bd = new pd, kd = new pd, zd = new pd, Hd = new pd; class Gd { constructor(e = new pd, t = new pd(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.origin).addScaledVector(this.direction, e) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, Od)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); const n = t.dot(this.direction); return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = Od.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (Od.copy(this.origin).addScaledVector(this.direction, t), Od.distanceToSquared(e)) } distanceSqToSegment(e, t, n, i) { Fd.copy(e).add(t).multiplyScalar(.5), Ud.copy(t).sub(e).normalize(), Bd.copy(this.origin).sub(Fd); const r = .5 * e.distanceTo(t), s = -this.direction.dot(Ud), a = Bd.dot(this.direction), o = -Bd.dot(Ud), l = Bd.lengthSq(), c = Math.abs(1 - s * s); let u, h, d, p; if (c > 0) if (u = s * o - a, h = s * a - o, p = r * c, u >= 0) if (h >= -p) if (h <= p) { const e = 1 / c; u *= e, h *= e, d = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * o) + l } else h = r, u = Math.max(0, -(s * h + a)), d = -u * u + h * (h + 2 * o) + l; else h = -r, u = Math.max(0, -(s * h + a)), d = -u * u + h * (h + 2 * o) + l; else h <= -p ? (u = Math.max(0, -(-s * r + a)), h = u > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -u * u + h * (h + 2 * o) + l) : h <= p ? (u = 0, h = Math.min(Math.max(-r, -o), r), d = h * (h + 2 * o) + l) : (u = Math.max(0, -(s * r + a)), h = u > 0 ? r : Math.min(Math.max(-r, -o), r), d = -u * u + h * (h + 2 * o) + l); else h = s > 0 ? -r : r, u = Math.max(0, -(s * h + a)), d = -u * u + h * (h + 2 * o) + l; return n && n.copy(this.origin).addScaledVector(this.direction, u), i && i.copy(Fd).addScaledVector(Ud, h), d } intersectSphere(e, t) { Od.subVectors(e.center, this.origin); const n = Od.dot(this.direction), i = Od.dot(Od) - n * n, r = e.radius * e.radius; if (i > r) return null; const s = Math.sqrt(r - i), a = n - s, o = n + s; return o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(e.normal) + e.constant) / t; return n >= 0 ? n : null } intersectPlane(e, t) { const n = this.distanceToPlane(e); return null === n ? null : this.at(n, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); if (0 === t) return !0; return e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let n, i, r, s, a, o; const l = 1 / this.direction.x, c = 1 / this.direction.y, u = 1 / this.direction.z, h = this.origin; return l >= 0 ? (n = (e.min.x - h.x) * l, i = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, i = (e.min.x - h.x) * l), c >= 0 ? (r = (e.min.y - h.y) * c, s = (e.max.y - h.y) * c) : (r = (e.max.y - h.y) * c, s = (e.min.y - h.y) * c), n > s || r > i ? null : ((r > n || isNaN(n)) && (n = r), (s < i || isNaN(i)) && (i = s), u >= 0 ? (a = (e.min.z - h.z) * u, o = (e.max.z - h.z) * u) : (a = (e.max.z - h.z) * u, o = (e.min.z - h.z) * u), n > o || a > i ? null : ((a > n || n != n) && (n = a), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, t))) } intersectsBox(e) { return null !== this.intersectBox(e, Od) } intersectTriangle(e, t, n, i, r) { kd.subVectors(t, e), zd.subVectors(n, e), Hd.crossVectors(kd, zd); let s, a = this.direction.dot(Hd); if (a > 0) { if (i) return null; s = 1 } else { if (!(a < 0)) return null; s = -1, a = -a } Bd.subVectors(this.origin, e); const o = s * this.direction.dot(zd.crossVectors(Bd, zd)); if (o < 0) return null; const l = s * this.direction.dot(kd.cross(Bd)); if (l < 0) return null; if (o + l > a) return null; const c = -s * Bd.dot(Hd); return c < 0 ? null : this.at(c / a, r) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return (new this.constructor).copy(this) } } class Vd { constructor(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, m) { Vd.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, m) } set(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, m) { const g = this.elements; return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new Vd).fromArray(this.elements) } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this } copyPosition(e) { const t = this.elements, n = e.elements; return t[12] = n[12], t[13] = n[13], t[14] = n[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, n) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } makeBasis(e, t, n) { return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, n = e.elements, i = 1 / Wd.setFromMatrixColumn(e, 0).length(), r = 1 / Wd.setFromMatrixColumn(e, 1).length(), s = 1 / Wd.setFromMatrixColumn(e, 2).length(); return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { const t = this.elements, n = e.x, i = e.y, r = e.z, s = Math.cos(n), a = Math.sin(n), o = Math.cos(i), l = Math.sin(i), c = Math.cos(r), u = Math.sin(r); if ("XYZ" === e.order) { const e = s * c, n = s * u, i = a * c, r = a * u; t[0] = o * c, t[4] = -o * u, t[8] = l, t[1] = n + i * l, t[5] = e - r * l, t[9] = -a * o, t[2] = r - e * l, t[6] = i + n * l, t[10] = s * o } else if ("YXZ" === e.order) { const e = o * c, n = o * u, i = l * c, r = l * u; t[0] = e + r * a, t[4] = i * a - n, t[8] = s * l, t[1] = s * u, t[5] = s * c, t[9] = -a, t[2] = n * a - i, t[6] = r + e * a, t[10] = s * o } else if ("ZXY" === e.order) { const e = o * c, n = o * u, i = l * c, r = l * u; t[0] = e - r * a, t[4] = -s * u, t[8] = i + n * a, t[1] = n + i * a, t[5] = s * c, t[9] = r - e * a, t[2] = -s * l, t[6] = a, t[10] = s * o } else if ("ZYX" === e.order) { const e = s * c, n = s * u, i = a * c, r = a * u; t[0] = o * c, t[4] = i * l - n, t[8] = e * l + r, t[1] = o * u, t[5] = r * l + e, t[9] = n * l - i, t[2] = -l, t[6] = a * o, t[10] = s * o } else if ("YZX" === e.order) { const e = s * o, n = s * l, i = a * o, r = a * l; t[0] = o * c, t[4] = r - e * u, t[8] = i * u + n, t[1] = u, t[5] = s * c, t[9] = -a * c, t[2] = -l * c, t[6] = n * u + i, t[10] = e - r * u } else if ("XZY" === e.order) { const e = s * o, n = s * l, i = a * o, r = a * l; t[0] = o * c, t[4] = -u, t[8] = l * c, t[1] = e * u + r, t[5] = s * c, t[9] = n * u - i, t[2] = i * u - n, t[6] = a * c, t[10] = r * u + e } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(Xd, e, qd) } lookAt(e, t, n) { const i = this.elements; return $d.subVectors(e, t), 0 === $d.lengthSq() && ($d.z = 1), $d.normalize(), Yd.crossVectors(n, $d), 0 === Yd.lengthSq() && (1 === Math.abs(n.z) ? $d.x += 1e-4 : $d.z += 1e-4, $d.normalize(), Yd.crossVectors(n, $d)), Yd.normalize(), Kd.crossVectors($d, Yd), i[0] = Yd.x, i[4] = Kd.x, i[8] = $d.x, i[1] = Yd.y, i[5] = Kd.y, i[9] = $d.y, i[2] = Yd.z, i[6] = Kd.z, i[10] = $d.z, this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, i = t.elements, r = this.elements, s = n[0], a = n[4], o = n[8], l = n[12], c = n[1], u = n[5], h = n[9], d = n[13], p = n[2], f = n[6], m = n[10], g = n[14], v = n[3], _ = n[7], y = n[11], x = n[15], b = i[0], E = i[4], T = i[8], S = i[12], M = i[1], w = i[5], A = i[9], D = i[13], C = i[2], R = i[6], L = i[10], P = i[14], I = i[3], N = i[7], O = i[11], F = i[15]; return r[0] = s * b + a * M + o * C + l * I, r[4] = s * E + a * w + o * R + l * N, r[8] = s * T + a * A + o * L + l * O, r[12] = s * S + a * D + o * P + l * F, r[1] = c * b + u * M + h * C + d * I, r[5] = c * E + u * w + h * R + d * N, r[9] = c * T + u * A + h * L + d * O, r[13] = c * S + u * D + h * P + d * F, r[2] = p * b + f * M + m * C + g * I, r[6] = p * E + f * w + m * R + g * N, r[10] = p * T + f * A + m * L + g * O, r[14] = p * S + f * D + m * P + g * F, r[3] = v * b + _ * M + y * C + x * I, r[7] = v * E + _ * w + y * R + x * N, r[11] = v * T + _ * A + y * L + x * O, r[15] = v * S + _ * D + y * P + x * F, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], n = e[4], i = e[8], r = e[12], s = e[1], a = e[5], o = e[9], l = e[13], c = e[2], u = e[6], h = e[10], d = e[14]; return e[3] * (+r * o * u - i * l * u - r * a * h + n * l * h + i * a * d - n * o * d) + e[7] * (+t * o * d - t * l * h + r * s * h - i * s * d + i * l * c - r * o * c) + e[11] * (+t * l * u - t * a * d - r * s * u + n * s * d + r * a * c - n * l * c) + e[15] * (-i * a * c - t * o * u + t * a * h + i * s * u - n * s * h + n * o * c) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, n) { const i = this.elements; return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this } invert() { const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], s = e[4], a = e[5], o = e[6], l = e[7], c = e[8], u = e[9], h = e[10], d = e[11], p = e[12], f = e[13], m = e[14], g = e[15], v = u * m * l - f * h * l + f * o * d - a * m * d - u * o * g + a * h * g, _ = p * h * l - c * m * l - p * o * d + s * m * d + c * o * g - s * h * g, y = c * f * l - p * u * l + p * a * d - s * f * d - c * a * g + s * u * g, x = p * u * o - c * f * o - p * a * h + s * f * h + c * a * m - s * u * m, b = t * v + n * _ + i * y + r * x; if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const E = 1 / b; return e[0] = v * E, e[1] = (f * h * r - u * m * r - f * i * d + n * m * d + u * i * g - n * h * g) * E, e[2] = (a * m * r - f * o * r + f * i * l - n * m * l - a * i * g + n * o * g) * E, e[3] = (u * o * r - a * h * r - u * i * l + n * h * l + a * i * d - n * o * d) * E, e[4] = _ * E, e[5] = (c * m * r - p * h * r + p * i * d - t * m * d - c * i * g + t * h * g) * E, e[6] = (p * o * r - s * m * r - p * i * l + t * m * l + s * i * g - t * o * g) * E, e[7] = (s * h * r - c * o * r + c * i * l - t * h * l - s * i * d + t * o * d) * E, e[8] = y * E, e[9] = (p * u * r - c * f * r - p * n * d + t * f * d + c * n * g - t * u * g) * E, e[10] = (s * f * r - p * a * r + p * n * l - t * f * l - s * n * g + t * a * g) * E, e[11] = (c * a * r - s * u * r - c * n * l + t * u * l + s * n * d - t * a * d) * E, e[12] = x * E, e[13] = (c * f * i - p * u * i + p * n * h - t * f * h - c * n * m + t * u * m) * E, e[14] = (p * a * i - s * f * i - p * n * o + t * f * o + s * n * m - t * a * m) * E, e[15] = (s * u * i - c * a * i + c * n * o - t * u * o - s * n * h + t * a * h) * E, this } scale(e) { const t = this.elements, n = e.x, i = e.y, r = e.z; return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, n, i)) } makeTranslation(e, t, n) { return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const n = Math.cos(t), i = Math.sin(t), r = 1 - n, s = e.x, a = e.y, o = e.z, l = r * s, c = r * a; return this.set(l * s + n, l * a - i * o, l * o + i * a, 0, l * a + i * o, c * a + n, c * o - i * s, 0, l * o - i * a, c * o + i * s, r * o * o + n, 0, 0, 0, 0, 1), this } makeScale(e, t, n) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } makeShear(e, t, n, i, r, s) { return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this } compose(e, t, n) { const i = this.elements, r = t._x, s = t._y, a = t._z, o = t._w, l = r + r, c = s + s, u = a + a, h = r * l, d = r * c, p = r * u, f = s * c, m = s * u, g = a * u, v = o * l, _ = o * c, y = o * u, x = n.x, b = n.y, E = n.z; return i[0] = (1 - (f + g)) * x, i[1] = (d + y) * x, i[2] = (p - _) * x, i[3] = 0, i[4] = (d - y) * b, i[5] = (1 - (h + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (p + _) * E, i[9] = (m - v) * E, i[10] = (1 - (h + f)) * E, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this } decompose(e, t, n) { const i = this.elements; let r = Wd.set(i[0], i[1], i[2]).length(); const s = Wd.set(i[4], i[5], i[6]).length(), a = Wd.set(i[8], i[9], i[10]).length(); this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], jd.copy(this); const o = 1 / r, l = 1 / s, c = 1 / a; return jd.elements[0] *= o, jd.elements[1] *= o, jd.elements[2] *= o, jd.elements[4] *= l, jd.elements[5] *= l, jd.elements[6] *= l, jd.elements[8] *= c, jd.elements[9] *= c, jd.elements[10] *= c, t.setFromRotationMatrix(jd), n.x = r, n.y = s, n.z = a, this } makePerspective(e, t, n, i, r, s, a = 2e3) { const o = this.elements, l = 2 * r / (t - e), c = 2 * r / (n - i), u = (t + e) / (t - e), h = (n + i) / (n - i); let d, p; if (a === Th) d = -(s + r) / (s - r), p = -2 * s * r / (s - r); else { if (a !== Sh) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a); d = -s / (s - r), p = -s * r / (s - r) } return o[0] = l, o[4] = 0, o[8] = u, o[12] = 0, o[1] = 0, o[5] = c, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = d, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this } makeOrthographic(e, t, n, i, r, s, a = 2e3) { const o = this.elements, l = 1 / (t - e), c = 1 / (n - i), u = 1 / (s - r), h = (t + e) * l, d = (n + i) * c; let p, f; if (a === Th) p = (s + r) * u, f = -2 * u; else { if (a !== Sh) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a); p = r * u, f = -1 * u } return o[0] = 2 * l, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -d, o[2] = 0, o[6] = 0, o[10] = f, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this } equals(e) { const t = this.elements, n = e.elements; for (let e = 0; e < 16; e++)if (t[e] !== n[e]) return !1; return !0 } fromArray(e, t = 0) { for (let n = 0; n < 16; n++)this.elements[n] = e[n + t]; return this } toArray(e = [], t = 0) { const n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e } } const Wd = new pd, jd = new Vd, Xd = new pd(0, 0, 0), qd = new pd(1, 1, 1), Yd = new pd, Kd = new pd, $d = new pd, Zd = new Vd, Jd = new dd; class Qd { constructor(e = 0, t = 0, n = 0, i = Qd.DEFAULT_ORDER) { this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, n, i = this._order) { return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, n = !0) { const i = e.elements, r = i[0], s = i[4], a = i[8], o = i[1], l = i[5], c = i[9], u = i[2], h = i[6], d = i[10]; switch (t) { case "XYZ": this._y = Math.asin(Lh(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(h, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-Lh(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-u, r), this._z = 0); break; case "ZXY": this._x = Math.asin(Lh(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r)); break; case "ZYX": this._y = Math.asin(-Lh(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l)); break; case "YZX": this._z = Math.asin(Lh(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(a, d)); break; case "XZY": this._z = Math.asin(-Lh(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, !0 === n && this._onChangeCallback(), this } setFromQuaternion(e, t, n) { return Zd.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Zd, t, n) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return Jd.setFromEuler(this), this.setFromQuaternion(Jd, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } } Qd.DEFAULT_ORDER = "XYZ"; class ep { constructor() { this.mask = 1 } set(e) { this.mask = (1 << e | 0) >>> 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return 0 != (this.mask & e.mask) } isEnabled(e) { return 0 != (this.mask & (1 << e | 0)) } } let tp = 0; const np = new pd, ip = new dd, rp = new Vd, sp = new pd, ap = new pd, op = new pd, lp = new dd, cp = new pd(1, 0, 0), up = new pd(0, 1, 0), hp = new pd(0, 0, 1), dp = { type: "added" }, pp = { type: "removed" }, fp = { type: "childadded", child: null }, mp = { type: "childremoved", child: null }; class gp extends Mh { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: tp++ }), this.uuid = Rh(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = gp.DEFAULT_UP.clone(); const e = new pd, t = new Qd, n = new dd, i = new pd(1, 1, 1); t._onChange((function () { n.setFromEuler(t, !1) })), n._onChange((function () { t.setFromQuaternion(n, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new Vd }, normalMatrix: { value: new zh } }), this.matrix = new Vd, this.matrixWorld = new Vd, this.matrixAutoUpdate = gp.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = gp.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new ep, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeShadow() { } onAfterShadow() { } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return ip.setFromAxisAngle(e, t), this.quaternion.multiply(ip), this } rotateOnWorldAxis(e, t) { return ip.setFromAxisAngle(e, t), this.quaternion.premultiply(ip), this } rotateX(e) { return this.rotateOnAxis(cp, e) } rotateY(e) { return this.rotateOnAxis(up, e) } rotateZ(e) { return this.rotateOnAxis(hp, e) } translateOnAxis(e, t) { return np.copy(e).applyQuaternion(this.quaternion), this.position.add(np.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(cp, e) } translateY(e) { return this.translateOnAxis(up, e) } translateZ(e) { return this.translateOnAxis(hp, e) } localToWorld(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(rp.copy(this.matrixWorld).invert()) } lookAt(e, t, n) { e.isVector3 ? sp.copy(e) : sp.set(e, t, n); const i = this.parent; this.updateWorldMatrix(!0, !1), ap.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? rp.lookAt(ap, sp, this.up) : rp.lookAt(sp, ap, this.up), this.quaternion.setFromRotationMatrix(rp), i && (rp.extractRotation(i.matrixWorld), ip.setFromRotationMatrix(rp), this.quaternion.premultiply(ip.invert())) } add(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(dp), fp.child = e, this.dispatchEvent(fp), fp.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } const t = this.children.indexOf(e); return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(pp), mp.child = e, this.dispatchEvent(mp), mp.child = null), this } removeFromParent() { const e = this.parent; return null !== e && e.remove(this), this } clear() { return this.remove(...this.children) } attach(e) { return this.updateWorldMatrix(!0, !1), rp.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), rp.multiply(e.parent.matrixWorld)), e.applyMatrix4(rp), this.add(e), e.updateWorldMatrix(!1, !0), this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let n = 0, i = this.children.length; n < i; n++) { const i = this.children[n].getObjectByProperty(e, t); if (void 0 !== i) return i } } getObjectsByProperty(e, t, n = []) { this[e] === t && n.push(this); const i = this.children; for (let r = 0, s = i.length; r < s; r++)i[r].getObjectsByProperty(e, t, n); return n } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ap, e, op), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ap, lp, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); const t = this.children; for (let n = 0, i = t.length; n < i; n++)t[n].traverse(e) } traverseVisible(e) { if (!1 === this.visible) return; e(this); const t = this.children; for (let n = 0, i = t.length; n < i; n++)t[n].traverseVisible(e) } traverseAncestors(e) { const t = this.parent; null !== t && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; !0 !== i.matrixWorldAutoUpdate && !0 !== e || i.updateMatrixWorld(e) } } updateWorldMatrix(e, t) { const n = this.parent; if (!0 === e && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) { const e = this.children; for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0) } } } toJSON(e) { const t = void 0 === e || "string" == typeof e, n = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, n.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" }); const i = {}; function r(t, n) { return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((e => ({ boxInitialized: e.boxInitialized, boxMin: e.box.min.toArray(), boxMax: e.box.max.toArray(), sphereInitialized: e.sphereInitialized, sphereRadius: e.sphere.radius, sphereCenter: e.sphere.center.toArray() }))), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), null !== this.boundingSphere && (i.boundingSphere = { center: i.boundingSphere.center.toArray(), radius: i.boundingSphere.radius }), null !== this.boundingBox && (i.boundingBox = { min: i.boundingBox.min.toArray(), max: i.boundingBox.max.toArray() })), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { i.geometry = r(e.geometries, this.geometry); const t = this.geometry.parameters; if (void 0 !== t && void 0 !== t.shapes) { const n = t.shapes; if (Array.isArray(n)) for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; r(e.shapes, i) } else r(e.shapes, n) } } if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const t = []; for (let n = 0, i = this.material.length; n < i; n++)t.push(r(e.materials, this.material[n])); i.material = t } else i.material = r(e.materials, this.material); if (this.children.length > 0) { i.children = []; for (let t = 0; t < this.children.length; t++)i.children.push(this.children[t].toJSON(e).object) } if (this.animations.length > 0) { i.animations = []; for (let t = 0; t < this.animations.length; t++) { const n = this.animations[t]; i.animations.push(r(e.animations, n)) } } if (t) { const t = s(e.geometries), i = s(e.materials), r = s(e.textures), a = s(e.images), o = s(e.shapes), l = s(e.skeletons), c = s(e.animations), u = s(e.nodes); t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), u.length > 0 && (n.nodes = u) } return n.object = i, n; function s(e) { const t = []; for (const n in e) { const i = e[n]; delete i.metadata, t.push(i) } return t } } clone(e) { return (new this.constructor).copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t) for (let t = 0; t < e.children.length; t++) { const n = e.children[t]; this.add(n.clone()) } return this } } gp.DEFAULT_UP = new pd(0, 1, 0), gp.DEFAULT_MATRIX_AUTO_UPDATE = !0, gp.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; const vp = new pd, _p = new pd, yp = new pd, xp = new pd, bp = new pd, Ep = new pd, Tp = new pd, Sp = new pd, Mp = new pd, wp = new pd; class Ap { constructor(e = new pd, t = new pd, n = new pd) { this.a = e, this.b = t, this.c = n } static getNormal(e, t, n, i) { i.subVectors(n, t), vp.subVectors(e, t), i.cross(vp); const r = i.lengthSq(); return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0) } static getBarycoord(e, t, n, i, r) { vp.subVectors(i, t), _p.subVectors(n, t), yp.subVectors(e, t); const s = vp.dot(vp), a = vp.dot(_p), o = vp.dot(yp), l = _p.dot(_p), c = _p.dot(yp), u = s * l - a * a; if (0 === u) return r.set(0, 0, 0), null; const h = 1 / u, d = (l * o - a * c) * h, p = (s * c - a * o) * h; return r.set(1 - d - p, p, d) } static containsPoint(e, t, n, i) { return null !== this.getBarycoord(e, t, n, i, xp) && (xp.x >= 0 && xp.y >= 0 && xp.x + xp.y <= 1) } static getInterpolation(e, t, n, i, r, s, a, o) { return null === this.getBarycoord(e, t, n, i, xp) ? (o.x = 0, o.y = 0, "z" in o && (o.z = 0), "w" in o && (o.w = 0), null) : (o.setScalar(0), o.addScaledVector(r, xp.x), o.addScaledVector(s, xp.y), o.addScaledVector(a, xp.z), o) } static isFrontFacing(e, t, n, i) { return vp.subVectors(n, t), _p.subVectors(e, t), vp.cross(_p).dot(i) < 0 } set(e, t, n) { return this.a.copy(e), this.b.copy(t), this.c.copy(n), this } setFromPointsAndIndices(e, t, n, i) { return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this } setFromAttributeAndIndices(e, t, n, i) { return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return vp.subVectors(this.c, this.b), _p.subVectors(this.a, this.b), .5 * vp.cross(_p).length() } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return Ap.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return Ap.getBarycoord(e, this.a, this.b, this.c, t) } getInterpolation(e, t, n, i, r) { return Ap.getInterpolation(e, this.a, this.b, this.c, t, n, i, r) } containsPoint(e) { return Ap.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return Ap.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { const n = this.a, i = this.b, r = this.c; let s, a; bp.subVectors(i, n), Ep.subVectors(r, n), Sp.subVectors(e, n); const o = bp.dot(Sp), l = Ep.dot(Sp); if (o <= 0 && l <= 0) return t.copy(n); Mp.subVectors(e, i); const c = bp.dot(Mp), u = Ep.dot(Mp); if (c >= 0 && u <= c) return t.copy(i); const h = o * u - c * l; if (h <= 0 && o >= 0 && c <= 0) return s = o / (o - c), t.copy(n).addScaledVector(bp, s); wp.subVectors(e, r); const d = bp.dot(wp), p = Ep.dot(wp); if (p >= 0 && d <= p) return t.copy(r); const f = d * l - o * p; if (f <= 0 && l >= 0 && p <= 0) return a = l / (l - p), t.copy(n).addScaledVector(Ep, a); const m = c * p - d * u; if (m <= 0 && u - c >= 0 && d - p >= 0) return Tp.subVectors(r, i), a = (u - c) / (u - c + (d - p)), t.copy(i).addScaledVector(Tp, a); const g = 1 / (m + f + h); return s = f * g, a = h * g, t.copy(n).addScaledVector(bp, s).addScaledVector(Ep, a) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } const Dp = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Cp = { h: 0, s: 0, l: 0 }, Rp = { h: 0, s: 0, l: 0 }; function Lp(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e } class Pp { constructor(e, t, n) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n) } set(e, t, n) { if (void 0 === t && void 0 === n) { const t = e; t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t) } else this.setRGB(e, t, n); return this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e, t = hh) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, Zh.toWorkingColorSpace(this, t), this } setRGB(e, t, n, i = Zh.workingColorSpace) { return this.r = e, this.g = t, this.b = n, Zh.toWorkingColorSpace(this, i), this } setHSL(e, t, n, i = Zh.workingColorSpace) { if (e = Ph(e, 1), t = Lh(t, 0, 1), n = Lh(n, 0, 1), 0 === t) this.r = this.g = this.b = n; else { const i = n <= .5 ? n * (1 + t) : n + t - n * t, r = 2 * n - i; this.r = Lp(r, i, e + 1 / 3), this.g = Lp(r, i, e), this.b = Lp(r, i, e - 1 / 3) } return Zh.toWorkingColorSpace(this, i), this } setStyle(e, t = hh) { function n(t) { void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let i; if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) { let r; const s = i[1], a = i[2]; switch (s) { case "rgb": case "rgba": if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t); if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t); break; case "hsl": case "hsla": if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t); break; default: console.warn("THREE.Color: Unknown color model " + e) } } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) { const n = i[1], r = n.length; if (3 === r) return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, t); if (6 === r) return this.setHex(parseInt(n, 16), t); console.warn("THREE.Color: Invalid hex color " + e) } else if (e && e.length > 0) return this.setColorName(e, t); return this } setColorName(e, t = hh) { const n = Dp[e.toLowerCase()]; return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = Jh(e.r), this.g = Jh(e.g), this.b = Jh(e.b), this } copyLinearToSRGB(e) { return this.r = Qh(e.r), this.g = Qh(e.g), this.b = Qh(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(e = hh) { return Zh.fromWorkingColorSpace(Ip.copy(this), e), 65536 * Math.round(Lh(255 * Ip.r, 0, 255)) + 256 * Math.round(Lh(255 * Ip.g, 0, 255)) + Math.round(Lh(255 * Ip.b, 0, 255)) } getHexString(e = hh) { return ("000000" + this.getHex(e).toString(16)).slice(-6) } getHSL(e, t = Zh.workingColorSpace) { Zh.fromWorkingColorSpace(Ip.copy(this), t); const n = Ip.r, i = Ip.g, r = Ip.b, s = Math.max(n, i, r), a = Math.min(n, i, r); let o, l; const c = (a + s) / 2; if (a === s) o = 0, l = 0; else { const e = s - a; switch (l = c <= .5 ? e / (s + a) : e / (2 - s - a), s) { case n: o = (i - r) / e + (i < r ? 6 : 0); break; case i: o = (r - n) / e + 2; break; case r: o = (n - i) / e + 4 }o /= 6 } return e.h = o, e.s = l, e.l = c, e } getRGB(e, t = Zh.workingColorSpace) { return Zh.fromWorkingColorSpace(Ip.copy(this), t), e.r = Ip.r, e.g = Ip.g, e.b = Ip.b, e } getStyle(e = hh) { Zh.fromWorkingColorSpace(Ip.copy(this), e); const t = Ip.r, n = Ip.g, i = Ip.b; return e !== hh ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * n)},${Math.round(255 * i)})` } offsetHSL(e, t, n) { return this.getHSL(Cp), this.setHSL(Cp.h + e, Cp.s + t, Cp.l + n) } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, n) { return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this } lerpHSL(e, t) { this.getHSL(Cp), e.getHSL(Rp); const n = Ih(Cp.h, Rp.h, t), i = Ih(Cp.s, Rp.s, t), r = Ih(Cp.l, Rp.l, t); return this.setHSL(n, i, r), this } setFromVector3(e) { return this.r = e.x, this.g = e.y, this.b = e.z, this } applyMatrix3(e) { const t = this.r, n = this.g, i = this.b, r = e.elements; return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } const Ip = new Pp; Pp.NAMES = Dp; let Np = 0; class Op extends Mh { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Np++ }), this.uuid = Rh(), this.name = "", this.type = "Material", this.blending = 1, this.side = fu, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = gu, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Pp(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = yh, this.stencilZFail = yh, this.stencilZPass = yh, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBuild() { } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (void 0 !== e) for (const t in e) { const n = e[t]; if (void 0 === n) { console.warn(`THREE.Material: parameter '${t}' has value of undefined.`); continue } const i = this[t]; void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`) } } toJSON(e) { const t = void 0 === e || "string" == typeof e; t && (e = { textures: {}, images: {} }); const n = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } }; function i(e) { const t = []; for (const n in e) { const i = e[n]; delete i.metadata, t.push(i) } return t } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), this.side !== fu && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), 204 !== this.blendSrc && (n.blendSrc = this.blendSrc), 205 !== this.blendDst && (n.blendDst = this.blendDst), this.blendEquation !== gu && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== yh && (n.stencilFail = this.stencilFail), this.stencilZFail !== yh && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== yh && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), t) { const t = i(e.textures), r = i(e.images); t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r) } return n } clone() { return (new this.constructor).copy(this) } copy(e) { this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let n = null; if (null !== t) { const e = t.length; n = new Array(e); for (let i = 0; i !== e; ++i)n[i] = t[i].clone() } return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { !0 === e && this.version++ } } class Fp extends Op { constructor(e) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Pp(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qd, this.combine = vu, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } const Up = new pd, Bp = new kh; class kp { constructor(e, t, n = !1) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = n, this.usage = xh, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = qu, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } get updateRange() { return Xh("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange } setUsage(e) { return this.usage = e, this } addUpdateRange(e, t) { this.updateRanges.push({ start: e, count: t }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this } copyAt(e, t, n) { e *= this.itemSize, n *= t.itemSize; for (let i = 0, r = this.itemSize; i < r; i++)this.array[e + i] = t.array[n + i]; return this } copyArray(e) { return this.array.set(e), this } applyMatrix3(e) { if (2 === this.itemSize) for (let t = 0, n = this.count; t < n; t++)Bp.fromBufferAttribute(this, t), Bp.applyMatrix3(e), this.setXY(t, Bp.x, Bp.y); else if (3 === this.itemSize) for (let t = 0, n = this.count; t < n; t++)Up.fromBufferAttribute(this, t), Up.applyMatrix3(e), this.setXYZ(t, Up.x, Up.y, Up.z); return this } applyMatrix4(e) { for (let t = 0, n = this.count; t < n; t++)Up.fromBufferAttribute(this, t), Up.applyMatrix4(e), this.setXYZ(t, Up.x, Up.y, Up.z); return this } applyNormalMatrix(e) { for (let t = 0, n = this.count; t < n; t++)Up.fromBufferAttribute(this, t), Up.applyNormalMatrix(e), this.setXYZ(t, Up.x, Up.y, Up.z); return this } transformDirection(e) { for (let t = 0, n = this.count; t < n; t++)Up.fromBufferAttribute(this, t), Up.transformDirection(e), this.setXYZ(t, Up.x, Up.y, Up.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getComponent(e, t) { let n = this.array[e * this.itemSize + t]; return this.normalized && (n = Fh(n, this.array)), n } setComponent(e, t, n) { return this.normalized && (n = Uh(n, this.array)), this.array[e * this.itemSize + t] = n, this } getX(e) { let t = this.array[e * this.itemSize]; return this.normalized && (t = Fh(t, this.array)), t } setX(e, t) { return this.normalized && (t = Uh(t, this.array)), this.array[e * this.itemSize] = t, this } getY(e) { let t = this.array[e * this.itemSize + 1]; return this.normalized && (t = Fh(t, this.array)), t } setY(e, t) { return this.normalized && (t = Uh(t, this.array)), this.array[e * this.itemSize + 1] = t, this } getZ(e) { let t = this.array[e * this.itemSize + 2]; return this.normalized && (t = Fh(t, this.array)), t } setZ(e, t) { return this.normalized && (t = Uh(t, this.array)), this.array[e * this.itemSize + 2] = t, this } getW(e) { let t = this.array[e * this.itemSize + 3]; return this.normalized && (t = Fh(t, this.array)), t } setW(e, t) { return this.normalized && (t = Uh(t, this.array)), this.array[e * this.itemSize + 3] = t, this } setXY(e, t, n) { return e *= this.itemSize, this.normalized && (t = Uh(t, this.array), n = Uh(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this } setXYZ(e, t, n, i) { return e *= this.itemSize, this.normalized && (t = Uh(t, this.array), n = Uh(n, this.array), i = Uh(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this } setXYZW(e, t, n, i, r) { return e *= this.itemSize, this.normalized && (t = Uh(t, this.array), n = Uh(n, this.array), i = Uh(i, this.array), r = Uh(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return "" !== this.name && (e.name = this.name), this.usage !== xh && (e.usage = this.usage), e } } class zp extends kp { constructor(e, t, n) { super(new Uint16Array(e), t, n) } } class Hp extends kp { constructor(e, t, n) { super(new Uint32Array(e), t, n) } } class Gp extends kp { constructor(e, t, n) { super(new Float32Array(e), t, n) } } let Vp = 0; const Wp = new Vd, jp = new gp, Xp = new pd, qp = new gd, Yp = new gd, Kp = new pd; class $p extends Mh { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Vp++ }), this.uuid = Rh(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (Gh(e) ? Hp : zp)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return void 0 !== this.attributes[e] } addGroup(e, t, n = 0) { this.groups.push({ start: e, count: t, materialIndex: n }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position; void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0); const n = this.attributes.normal; if (void 0 !== n) { const t = (new zh).getNormalMatrix(e); n.applyNormalMatrix(t), n.needsUpdate = !0 } const i = this.attributes.tangent; return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } applyQuaternion(e) { return Wp.makeRotationFromQuaternion(e), this.applyMatrix4(Wp), this } rotateX(e) { return Wp.makeRotationX(e), this.applyMatrix4(Wp), this } rotateY(e) { return Wp.makeRotationY(e), this.applyMatrix4(Wp), this } rotateZ(e) { return Wp.makeRotationZ(e), this.applyMatrix4(Wp), this } translate(e, t, n) { return Wp.makeTranslation(e, t, n), this.applyMatrix4(Wp), this } scale(e, t, n) { return Wp.makeScale(e, t, n), this.applyMatrix4(Wp), this } lookAt(e) { return jp.lookAt(e), jp.updateMatrix(), this.applyMatrix4(jp.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(Xp).negate(), this.translate(Xp.x, Xp.y, Xp.z), this } setFromPoints(e) { const t = []; for (let n = 0, i = e.length; n < i; n++) { const i = e[n]; t.push(i.x, i.y, i.z || 0) } return this.setAttribute("position", new Gp(t, 3)), this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new gd); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), void this.boundingBox.set(new pd(-1 / 0, -1 / 0, -1 / 0), new pd(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; qp.setFromBufferAttribute(n), this.morphTargetsRelative ? (Kp.addVectors(this.boundingBox.min, qp.min), this.boundingBox.expandByPoint(Kp), Kp.addVectors(this.boundingBox.max, qp.max), this.boundingBox.expandByPoint(Kp)) : (this.boundingBox.expandByPoint(qp.min), this.boundingBox.expandByPoint(qp.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new Nd); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), void this.boundingSphere.set(new pd, 1 / 0); if (e) { const n = this.boundingSphere.center; if (qp.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; Yp.setFromBufferAttribute(n), this.morphTargetsRelative ? (Kp.addVectors(qp.min, Yp.min), qp.expandByPoint(Kp), Kp.addVectors(qp.max, Yp.max), qp.expandByPoint(Kp)) : (qp.expandByPoint(Yp.min), qp.expandByPoint(Yp.max)) } qp.getCenter(n); let i = 0; for (let t = 0, r = e.count; t < r; t++)Kp.fromBufferAttribute(e, t), i = Math.max(i, n.distanceToSquared(Kp)); if (t) for (let r = 0, s = t.length; r < s; r++) { const s = t[r], a = this.morphTargetsRelative; for (let t = 0, r = s.count; t < r; t++)Kp.fromBufferAttribute(s, t), a && (Xp.fromBufferAttribute(e, t), Kp.add(Xp)), i = Math.max(i, n.distanceToSquared(Kp)) } this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const e = this.index, t = this.attributes; if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); const n = t.position, i = t.normal, r = t.uv; !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new kp(new Float32Array(4 * n.count), 4)); const s = this.getAttribute("tangent"), a = [], o = []; for (let e = 0; e < n.count; e++)a[e] = new pd, o[e] = new pd; const l = new pd, c = new pd, u = new pd, h = new kh, d = new kh, p = new kh, f = new pd, m = new pd; function g(e, t, i) { l.fromBufferAttribute(n, e), c.fromBufferAttribute(n, t), u.fromBufferAttribute(n, i), h.fromBufferAttribute(r, e), d.fromBufferAttribute(r, t), p.fromBufferAttribute(r, i), c.sub(l), u.sub(l), d.sub(h), p.sub(h); const s = 1 / (d.x * p.y - p.x * d.y); isFinite(s) && (f.copy(c).multiplyScalar(p.y).addScaledVector(u, -d.y).multiplyScalar(s), m.copy(u).multiplyScalar(d.x).addScaledVector(c, -p.x).multiplyScalar(s), a[e].add(f), a[t].add(f), a[i].add(f), o[e].add(m), o[t].add(m), o[i].add(m)) } let v = this.groups; 0 === v.length && (v = [{ start: 0, count: e.count }]); for (let t = 0, n = v.length; t < n; ++t) { const n = v[t], i = n.start; for (let t = i, r = i + n.count; t < r; t += 3)g(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2)) } const _ = new pd, y = new pd, x = new pd, b = new pd; function E(e) { x.fromBufferAttribute(i, e), b.copy(x); const t = a[e]; _.copy(t), _.sub(x.multiplyScalar(x.dot(t))).normalize(), y.crossVectors(b, t); const n = y.dot(o[e]) < 0 ? -1 : 1; s.setXYZW(e, _.x, _.y, _.z, n) } for (let t = 0, n = v.length; t < n; ++t) { const n = v[t], i = n.start; for (let t = i, r = i + n.count; t < r; t += 3)E(e.getX(t + 0)), E(e.getX(t + 1)), E(e.getX(t + 2)) } } computeVertexNormals() { const e = this.index, t = this.getAttribute("position"); if (void 0 !== t) { let n = this.getAttribute("normal"); if (void 0 === n) n = new kp(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n); else for (let e = 0, t = n.count; e < t; e++)n.setXYZ(e, 0, 0, 0); const i = new pd, r = new pd, s = new pd, a = new pd, o = new pd, l = new pd, c = new pd, u = new pd; if (e) for (let h = 0, d = e.count; h < d; h += 3) { const d = e.getX(h + 0), p = e.getX(h + 1), f = e.getX(h + 2); i.fromBufferAttribute(t, d), r.fromBufferAttribute(t, p), s.fromBufferAttribute(t, f), c.subVectors(s, r), u.subVectors(i, r), c.cross(u), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), a.add(c), o.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(f, l.x, l.y, l.z) } else for (let e = 0, a = t.count; e < a; e += 3)i.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), c.subVectors(s, r), u.subVectors(i, r), c.cross(u), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z); this.normalizeNormals(), n.needsUpdate = !0 } } normalizeNormals() { const e = this.attributes.normal; for (let t = 0, n = e.count; t < n; t++)Kp.fromBufferAttribute(e, t), Kp.normalize(), e.setXYZ(t, Kp.x, Kp.y, Kp.z) } toNonIndexed() { function e(e, t) { const n = e.array, i = e.itemSize, r = e.normalized, s = new n.constructor(t.length * i); let a = 0, o = 0; for (let r = 0, l = t.length; r < l; r++) { a = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i; for (let e = 0; e < i; e++)s[o++] = n[a++] } return new kp(s, i, r) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const t = new $p, n = this.index.array, i = this.attributes; for (const r in i) { const s = e(i[r], n); t.setAttribute(r, s) } const r = this.morphAttributes; for (const i in r) { const s = [], a = r[i]; for (let t = 0, i = a.length; t < i; t++) { const i = e(a[t], n); s.push(i) } t.morphAttributes[i] = s } t.morphTargetsRelative = this.morphTargetsRelative; const s = this.groups; for (let e = 0, n = s.length; e < n; e++) { const n = s[e]; t.addGroup(n.start, n.count, n.materialIndex) } return t } toJSON() { const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) { const t = this.parameters; for (const n in t) void 0 !== t[n] && (e[n] = t[n]); return e } e.data = { attributes: {} }; const t = this.index; null !== t && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const n = this.attributes; for (const t in n) { const i = n[t]; e.data.attributes[t] = i.toJSON(e.data) } const i = {}; let r = !1; for (const t in this.morphAttributes) { const n = this.morphAttributes[t], s = []; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; s.push(i.toJSON(e.data)) } s.length > 0 && (i[t] = s, r = !0) } r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative); const s = this.groups; s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s))); const a = this.boundingSphere; return null !== a && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e } clone() { return (new this.constructor).copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const n = e.index; null !== n && this.setIndex(n.clone(t)); const i = e.attributes; for (const e in i) { const n = i[e]; this.setAttribute(e, n.clone(t)) } const r = e.morphAttributes; for (const e in r) { const n = [], i = r[e]; for (let e = 0, r = i.length; e < r; e++)n.push(i[e].clone(t)); this.morphAttributes[e] = n } this.morphTargetsRelative = e.morphTargetsRelative; const s = e.groups; for (let e = 0, t = s.length; e < t; e++) { const t = s[e]; this.addGroup(t.start, t.count, t.materialIndex) } const a = e.boundingBox; null !== a && (this.boundingBox = a.clone()); const o = e.boundingSphere; return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const Zp = new Vd, Jp = new Gd, Qp = new Nd, ef = new pd, tf = new pd, nf = new pd, rf = new pd, sf = new pd, af = new pd, of = new kh, lf = new kh, cf = new kh, uf = new pd, hf = new pd, df = new pd, pf = new pd, ff = new pd; class mf extends gp { constructor(e = new $p, t = new Fp) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } updateMorphTargets() { const e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { const n = e[t[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = n.length; e < t; e++) { const t = n[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e } } } } getVertexPosition(e, t) { const n = this.geometry, i = n.attributes.position, r = n.morphAttributes.position, s = n.morphTargetsRelative; t.fromBufferAttribute(i, e); const a = this.morphTargetInfluences; if (r && a) { af.set(0, 0, 0); for (let n = 0, i = r.length; n < i; n++) { const i = a[n], o = r[n]; 0 !== i && (sf.fromBufferAttribute(o, e), s ? af.addScaledVector(sf, i) : af.addScaledVector(sf.sub(t), i)) } t.add(af) } return t } raycast(e, t) { const n = this.geometry, i = this.material, r = this.matrixWorld; if (void 0 !== i) { if (null === n.boundingSphere && n.computeBoundingSphere(), Qp.copy(n.boundingSphere), Qp.applyMatrix4(r), Jp.copy(e.ray).recast(e.near), !1 === Qp.containsPoint(Jp.origin)) { if (null === Jp.intersectSphere(Qp, ef)) return; if (Jp.origin.distanceToSquared(ef) > (e.far - e.near) ** 2) return } Zp.copy(r).invert(), Jp.copy(e.ray).applyMatrix4(Zp), null !== n.boundingBox && !1 === Jp.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, Jp) } } _computeIntersections(e, t, n) { let i; const r = this.geometry, s = this.material, a = r.index, o = r.attributes.position, l = r.attributes.uv, c = r.attributes.uv1, u = r.attributes.normal, h = r.groups, d = r.drawRange; if (null !== a) if (Array.isArray(s)) for (let r = 0, o = h.length; r < o; r++) { const o = h[r], p = s[o.materialIndex]; for (let r = Math.max(o.start, d.start), s = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count)); r < s; r += 3) { i = gf(this, p, e, n, l, c, u, a.getX(r), a.getX(r + 1), a.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = o.materialIndex, t.push(i)) } } else { for (let r = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count); r < o; r += 3) { i = gf(this, s, e, n, l, c, u, a.getX(r), a.getX(r + 1), a.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), t.push(i)) } } else if (void 0 !== o) if (Array.isArray(s)) for (let r = 0, a = h.length; r < a; r++) { const a = h[r], p = s[a.materialIndex]; for (let r = Math.max(a.start, d.start), s = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count)); r < s; r += 3) { i = gf(this, p, e, n, l, c, u, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = a.materialIndex, t.push(i)) } } else { for (let r = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count); r < a; r += 3) { i = gf(this, s, e, n, l, c, u, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), t.push(i)) } } } } function gf(e, t, n, i, r, s, a, o, l, c) { e.getVertexPosition(o, tf), e.getVertexPosition(l, nf), e.getVertexPosition(c, rf); const u = function (e, t, n, i, r, s, a, o) { let l; if (l = t.side === mu ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, t.side === fu, o), null === l) return null; ff.copy(o), ff.applyMatrix4(e.matrixWorld); const c = n.ray.origin.distanceTo(ff); return c < n.near || c > n.far ? null : { distance: c, point: ff.clone(), object: e } }(e, t, n, i, tf, nf, rf, pf); if (u) { r && (of.fromBufferAttribute(r, o), lf.fromBufferAttribute(r, l), cf.fromBufferAttribute(r, c), u.uv = Ap.getInterpolation(pf, tf, nf, rf, of, lf, cf, new kh)), s && (of.fromBufferAttribute(s, o), lf.fromBufferAttribute(s, l), cf.fromBufferAttribute(s, c), u.uv1 = Ap.getInterpolation(pf, tf, nf, rf, of, lf, cf, new kh)), a && (uf.fromBufferAttribute(a, o), hf.fromBufferAttribute(a, l), df.fromBufferAttribute(a, c), u.normal = Ap.getInterpolation(pf, tf, nf, rf, uf, hf, df, new pd), u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1)); const e = { a: o, b: l, c, normal: new pd, materialIndex: 0 }; Ap.getNormal(tf, nf, rf, e.normal), u.face = e } return u } class vf extends $p { constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: n, widthSegments: i, heightSegments: r, depthSegments: s }; const a = this; i = Math.floor(i), r = Math.floor(r), s = Math.floor(s); const o = [], l = [], c = [], u = []; let h = 0, d = 0; function p(e, t, n, i, r, s, p, f, m, g, v) { const _ = s / m, y = p / g, x = s / 2, b = p / 2, E = f / 2, T = m + 1, S = g + 1; let M = 0, w = 0; const A = new pd; for (let s = 0; s < S; s++) { const a = s * y - b; for (let o = 0; o < T; o++) { const h = o * _ - x; A[e] = h * i, A[t] = a * r, A[n] = E, l.push(A.x, A.y, A.z), A[e] = 0, A[t] = 0, A[n] = f > 0 ? 1 : -1, c.push(A.x, A.y, A.z), u.push(o / m), u.push(1 - s / g), M += 1 } } for (let e = 0; e < g; e++)for (let t = 0; t < m; t++) { const n = h + t + T * e, i = h + t + T * (e + 1), r = h + (t + 1) + T * (e + 1), s = h + (t + 1) + T * e; o.push(n, i, s), o.push(i, r, s), w += 6 } a.addGroup(d, w, v), d += w, h += M } p("z", "y", "x", -1, -1, n, t, e, s, r, 0), p("z", "y", "x", 1, -1, n, t, -e, s, r, 1), p("x", "z", "y", 1, 1, e, n, t, i, s, 2), p("x", "z", "y", 1, -1, e, n, -t, i, s, 3), p("x", "y", "z", 1, -1, e, t, n, i, r, 4), p("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new Gp(l, 3)), this.setAttribute("normal", new Gp(c, 3)), this.setAttribute("uv", new Gp(u, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new vf(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function _f(e) { const t = {}; for (const n in e) { t[n] = {}; for (const i in e[n]) { const r = e[n][i]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[n][i] = null) : t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r } } return t } function yf(e) { const t = {}; for (let n = 0; n < e.length; n++) { const i = _f(e[n]); for (const e in i) t[e] = i[e] } return t } function xf(e) { return null === e.getRenderTarget() ? e.outputColorSpace : Zh.workingColorSpace } const bf = { clone: _f, merge: yf }; class Ef extends Op { constructor(e) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1, clipCullDistance: !1, multiDraw: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && this.setValues(e) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = _f(e.uniforms), this.uniformsGroups = function (e) { const t = []; for (let n = 0; n < e.length; n++)t.push(e[n].clone()); return t }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const n in this.uniforms) { const i = this.uniforms[n].value; i && i.isTexture ? t.uniforms[n] = { type: "t", value: i.toJSON(e).uuid } : i && i.isColor ? t.uniforms[n] = { type: "c", value: i.getHex() } : i && i.isVector2 ? t.uniforms[n] = { type: "v2", value: i.toArray() } : i && i.isVector3 ? t.uniforms[n] = { type: "v3", value: i.toArray() } : i && i.isVector4 ? t.uniforms[n] = { type: "v4", value: i.toArray() } : i && i.isMatrix3 ? t.uniforms[n] = { type: "m3", value: i.toArray() } : i && i.isMatrix4 ? t.uniforms[n] = { type: "m4", value: i.toArray() } : t.uniforms[n] = { value: i } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping; const n = {}; for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0); return Object.keys(n).length > 0 && (t.extensions = n), t } } class Tf extends gp { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Vd, this.projectionMatrix = new Vd, this.projectionMatrixInverse = new Vd, this.coordinateSystem = Th } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this } getWorldDirection(e) { return super.getWorldDirection(e).negate() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return (new this.constructor).copy(this) } } const Sf = new pd, Mf = new kh, wf = new kh; class Af extends Tf { constructor(e = 50, t = 1, n = .1, i = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const t = .5 * this.getFilmHeight() / e; this.fov = 2 * Ch * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(.5 * Dh * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return 2 * Ch * Math.atan(Math.tan(.5 * Dh * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } getViewBounds(e, t, n) { Sf.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(Sf.x, Sf.y).multiplyScalar(-e / Sf.z), Sf.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(Sf.x, Sf.y).multiplyScalar(-e / Sf.z) } getViewSize(e, t) { return this.getViewBounds(e, Mf, wf), t.subVectors(wf, Mf) } setViewOffset(e, t, n, i, r, s) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(.5 * Dh * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, r = -.5 * i; const s = this.view; if (null !== this.view && this.view.enabled) { const e = s.fullWidth, a = s.fullHeight; r += s.offsetX * i / e, t -= s.offsetY * n / a, i *= s.width / e, n *= s.height / a } const a = this.filmOffset; 0 !== a && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } const Df = -90; class Cf extends gp { constructor(e, t, n) { super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0; const i = new Af(Df, 1, e, t); i.layers = this.layers, this.add(i); const r = new Af(Df, 1, e, t); r.layers = this.layers, this.add(r); const s = new Af(Df, 1, e, t); s.layers = this.layers, this.add(s); const a = new Af(Df, 1, e, t); a.layers = this.layers, this.add(a); const o = new Af(Df, 1, e, t); o.layers = this.layers, this.add(o); const l = new Af(Df, 1, e, t); l.layers = this.layers, this.add(l) } updateCoordinateSystem() { const e = this.coordinateSystem, t = this.children.concat(), [n, i, r, s, a, o] = t; for (const e of t) this.remove(e); if (e === Th) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), s.up.set(0, 0, 1), s.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(0, 0, -1); else { if (e !== Sh) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e); n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), s.up.set(0, 0, -1), s.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), o.up.set(0, -1, 0), o.lookAt(0, 0, -1) } for (const e of t) this.add(e), e.updateMatrixWorld() } update(e, t) { null === this.parent && this.updateMatrixWorld(); const { renderTarget: n, activeMipmapLevel: i } = this; this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem()); const [r, s, a, o, l, c] = this.children, u = e.getRenderTarget(), h = e.getActiveCubeFace(), d = e.getActiveMipmapLevel(), p = e.xr.enabled; e.xr.enabled = !1; const f = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, r), e.setRenderTarget(n, 1, i), e.render(t, s), e.setRenderTarget(n, 2, i), e.render(t, a), e.setRenderTarget(n, 3, i), e.render(t, o), e.setRenderTarget(n, 4, i), e.render(t, l), n.texture.generateMipmaps = f, e.setRenderTarget(n, 5, i), e.render(t, c), e.setRenderTarget(u, h, d), e.xr.enabled = p, n.texture.needsPMREMUpdate = !0 } } class Rf extends ad { constructor(e, t, n, i, r, s, a, o, l, c) { super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : Cu, n, i, r, s, a, o, l, c), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } class Lf extends cd { constructor(e = 1, t = {}) { super(e, e, t), this.isWebGLCubeRenderTarget = !0; const n = { width: e, height: e, depth: 1 }, i = [n, n, n, n, n, n]; this.texture = new Rf(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : zu } fromEquirectangularTexture(e, t) { this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const n = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t" }, i = new vf(5, 5, 5), r = new Ef({ name: "CubemapFromEquirect", uniforms: _f(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: mu, blending: 0 }); r.uniforms.tEquirect.value = t; const s = new mf(i, r), a = t.minFilter; t.minFilter === Gu && (t.minFilter = zu); return new Cf(1, 10, this).update(e, s), t.minFilter = a, s.geometry.dispose(), s.material.dispose(), this } clear(e, t, n, i) { const r = e.getRenderTarget(); for (let r = 0; r < 6; r++)e.setRenderTarget(this, r), e.clear(t, n, i); e.setRenderTarget(r) } } const Pf = new pd, If = new pd, Nf = new zh; class Of { constructor(e = new pd(1, 0, 0), t = 0) { this.isPlane = !0, this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, n, i) { return this.normal.set(e, t, n), this.constant = i, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, n) { const i = Pf.subVectors(n, t).cross(If.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(i, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e)) } intersectLine(e, t) { const n = e.delta(Pf), i = this.normal.dot(n); if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null; const r = -(e.start.dot(this.normal) + this.constant) / i; return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r) } intersectsLine(e) { const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end); return t < 0 && n > 0 || n < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const n = t || Nf.getNormalMatrix(e), i = this.coplanarPoint(Pf).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize(); return this.constant = -i.dot(r), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return (new this.constructor).copy(this) } } const Ff = new Nd, Uf = new pd; class Bf { constructor(e = new Of, t = new Of, n = new Of, i = new Of, r = new Of, s = new Of) { this.planes = [e, t, n, i, r, s] } set(e, t, n, i, r, s) { const a = this.planes; return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this } copy(e) { const t = this.planes; for (let n = 0; n < 6; n++)t[n].copy(e.planes[n]); return this } setFromProjectionMatrix(e, t = 2e3) { const n = this.planes, i = e.elements, r = i[0], s = i[1], a = i[2], o = i[3], l = i[4], c = i[5], u = i[6], h = i[7], d = i[8], p = i[9], f = i[10], m = i[11], g = i[12], v = i[13], _ = i[14], y = i[15]; if (n[0].setComponents(o - r, h - l, m - d, y - g).normalize(), n[1].setComponents(o + r, h + l, m + d, y + g).normalize(), n[2].setComponents(o + s, h + c, m + p, y + v).normalize(), n[3].setComponents(o - s, h - c, m - p, y - v).normalize(), n[4].setComponents(o - a, h - u, m - f, y - _).normalize(), t === Th) n[5].setComponents(o + a, h + u, m + f, y + _).normalize(); else { if (t !== Sh) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t); n[5].setComponents(a, u, f, _).normalize() } return this } intersectsObject(e) { if (void 0 !== e.boundingSphere) null === e.boundingSphere && e.computeBoundingSphere(), Ff.copy(e.boundingSphere).applyMatrix4(e.matrixWorld); else { const t = e.geometry; null === t.boundingSphere && t.computeBoundingSphere(), Ff.copy(t.boundingSphere).applyMatrix4(e.matrixWorld) } return this.intersectsSphere(Ff) } intersectsSprite(e) { return Ff.center.set(0, 0, 0), Ff.radius = .7071067811865476, Ff.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ff) } intersectsSphere(e) { const t = this.planes, n = e.center, i = -e.radius; for (let e = 0; e < 6; e++) { if (t[e].distanceToPoint(n) < i) return !1 } return !0 } intersectsBox(e) { const t = this.planes; for (let n = 0; n < 6; n++) { const i = t[n]; if (Uf.x = i.normal.x > 0 ? e.max.x : e.min.x, Uf.y = i.normal.y > 0 ? e.max.y : e.min.y, Uf.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Uf) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let n = 0; n < 6; n++)if (t[n].distanceToPoint(e) < 0) return !1; return !0 } clone() { return (new this.constructor).copy(this) } } function kf() { let e = null, t = !1, n = null, i = null; function r(t, s) { n(t, s), i = e.requestAnimationFrame(r) } return { start: function () { !0 !== t && null !== n && (i = e.requestAnimationFrame(r), t = !0) }, stop: function () { e.cancelAnimationFrame(i), t = !1 }, setAnimationLoop: function (e) { n = e }, setContext: function (t) { e = t } } } function zf(e, t) { const n = t.isWebGL2, i = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), i.get(e) }, remove: function (t) { t.isInterleavedBufferAttribute && (t = t.data); const n = i.get(t); n && (e.deleteBuffer(n.buffer), i.delete(t)) }, update: function (t, r) { if (t.isGLBufferAttribute) { const e = i.get(t); return void ((!e || e.version < t.version) && i.set(t, { buffer: t.buffer, type: t.type, bytesPerElement: t.elementSize, version: t.version })) } t.isInterleavedBufferAttribute && (t = t.data); const s = i.get(t); if (void 0 === s) i.set(t, function (t, i) { const r = t.array, s = t.usage, a = r.byteLength, o = e.createBuffer(); let l; if (e.bindBuffer(i, o), e.bufferData(i, r, s), t.onUploadCallback(), r instanceof Float32Array) l = e.FLOAT; else if (r instanceof Uint16Array) if (t.isFloat16BufferAttribute) { if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."); l = e.HALF_FLOAT } else l = e.UNSIGNED_SHORT; else if (r instanceof Int16Array) l = e.SHORT; else if (r instanceof Uint32Array) l = e.UNSIGNED_INT; else if (r instanceof Int32Array) l = e.INT; else if (r instanceof Int8Array) l = e.BYTE; else if (r instanceof Uint8Array) l = e.UNSIGNED_BYTE; else { if (!(r instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r); l = e.UNSIGNED_BYTE } return { buffer: o, type: l, bytesPerElement: r.BYTES_PER_ELEMENT, version: t.version, size: a } }(t, r)); else if (s.version < t.version) { if (s.size !== t.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."); !function (t, i, r) { const s = i.array, a = i._updateRange, o = i.updateRanges; if (e.bindBuffer(r, t), -1 === a.count && 0 === o.length && e.bufferSubData(r, 0, s), 0 !== o.length) { for (let t = 0, i = o.length; t < i; t++) { const i = o[t]; n ? e.bufferSubData(r, i.start * s.BYTES_PER_ELEMENT, s, i.start, i.count) : e.bufferSubData(r, i.start * s.BYTES_PER_ELEMENT, s.subarray(i.start, i.start + i.count)) } i.clearUpdateRanges() } -1 !== a.count && (n ? e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1), i.onUploadCallback() }(s.buffer, t, r), s.version = t.version } } } } class Hf extends $p { constructor(e = 1, t = 1, n = 1, i = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: i }; const r = e / 2, s = t / 2, a = Math.floor(n), o = Math.floor(i), l = a + 1, c = o + 1, u = e / a, h = t / o, d = [], p = [], f = [], m = []; for (let e = 0; e < c; e++) { const t = e * h - s; for (let n = 0; n < l; n++) { const i = n * u - r; p.push(i, -t, 0), f.push(0, 0, 1), m.push(n / a), m.push(1 - e / o) } } for (let e = 0; e < o; e++)for (let t = 0; t < a; t++) { const n = t + l * e, i = t + l * (e + 1), r = t + 1 + l * (e + 1), s = t + 1 + l * e; d.push(n, i, s), d.push(i, r, s) } this.setIndex(d), this.setAttribute("position", new Gp(p, 3)), this.setAttribute("normal", new Gp(f, 3)), this.setAttribute("uv", new Gp(m, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Hf(e.width, e.height, e.widthSegments, e.heightSegments) } } const Gf = { alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif", alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif", alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", batching_pars_vertex: "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif", batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif", begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated", iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;", lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t#endif\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\t#ifndef USE_INSTANCING_MORPH\n\t\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\t#endif\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;", normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif", iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif", opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tfloat startCompression = 0.8 - 0.04;\n\tfloat desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min(color.r, min(color.g, color.b));\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max(color.r, max(color.g, color.b));\n\tif (peak < startCompression) return color;\n\tfloat d = 1. - startCompression;\n\tfloat newPeak = 1. - d * d / (peak + d - startCompression);\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n\treturn mix(color, vec3(1, 1, 1), g);\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif", uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif", uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif", uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}", backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}", depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}" }, Vf = { common: { diffuse: { value: new Pp(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new zh }, alphaMap: { value: null }, alphaMapTransform: { value: new zh }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new zh } }, envmap: { envMap: { value: null }, envMapRotation: { value: new zh }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new zh } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new zh } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new zh }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new zh }, normalScale: { value: new kh(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new zh }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new zh } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new zh } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new zh } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Pp(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Pp(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new zh }, alphaTest: { value: 0 }, uvTransform: { value: new zh } }, sprite: { diffuse: { value: new Pp(16777215) }, opacity: { value: 1 }, center: { value: new kh(.5, .5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new zh }, alphaMap: { value: null }, alphaMapTransform: { value: new zh }, alphaTest: { value: 0 } } }, Wf = { basic: { uniforms: yf([Vf.common, Vf.specularmap, Vf.envmap, Vf.aomap, Vf.lightmap, Vf.fog]), vertexShader: Gf.meshbasic_vert, fragmentShader: Gf.meshbasic_frag }, lambert: { uniforms: yf([Vf.common, Vf.specularmap, Vf.envmap, Vf.aomap, Vf.lightmap, Vf.emissivemap, Vf.bumpmap, Vf.normalmap, Vf.displacementmap, Vf.fog, Vf.lights, { emissive: { value: new Pp(0) } }]), vertexShader: Gf.meshlambert_vert, fragmentShader: Gf.meshlambert_frag }, phong: { uniforms: yf([Vf.common, Vf.specularmap, Vf.envmap, Vf.aomap, Vf.lightmap, Vf.emissivemap, Vf.bumpmap, Vf.normalmap, Vf.displacementmap, Vf.fog, Vf.lights, { emissive: { value: new Pp(0) }, specular: { value: new Pp(1118481) }, shininess: { value: 30 } }]), vertexShader: Gf.meshphong_vert, fragmentShader: Gf.meshphong_frag }, standard: { uniforms: yf([Vf.common, Vf.envmap, Vf.aomap, Vf.lightmap, Vf.emissivemap, Vf.bumpmap, Vf.normalmap, Vf.displacementmap, Vf.roughnessmap, Vf.metalnessmap, Vf.fog, Vf.lights, { emissive: { value: new Pp(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Gf.meshphysical_vert, fragmentShader: Gf.meshphysical_frag }, toon: { uniforms: yf([Vf.common, Vf.aomap, Vf.lightmap, Vf.emissivemap, Vf.bumpmap, Vf.normalmap, Vf.displacementmap, Vf.gradientmap, Vf.fog, Vf.lights, { emissive: { value: new Pp(0) } }]), vertexShader: Gf.meshtoon_vert, fragmentShader: Gf.meshtoon_frag }, matcap: { uniforms: yf([Vf.common, Vf.bumpmap, Vf.normalmap, Vf.displacementmap, Vf.fog, { matcap: { value: null } }]), vertexShader: Gf.meshmatcap_vert, fragmentShader: Gf.meshmatcap_frag }, points: { uniforms: yf([Vf.points, Vf.fog]), vertexShader: Gf.points_vert, fragmentShader: Gf.points_frag }, dashed: { uniforms: yf([Vf.common, Vf.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Gf.linedashed_vert, fragmentShader: Gf.linedashed_frag }, depth: { uniforms: yf([Vf.common, Vf.displacementmap]), vertexShader: Gf.depth_vert, fragmentShader: Gf.depth_frag }, normal: { uniforms: yf([Vf.common, Vf.bumpmap, Vf.normalmap, Vf.displacementmap, { opacity: { value: 1 } }]), vertexShader: Gf.meshnormal_vert, fragmentShader: Gf.meshnormal_frag }, sprite: { uniforms: yf([Vf.sprite, Vf.fog]), vertexShader: Gf.sprite_vert, fragmentShader: Gf.sprite_frag }, background: { uniforms: { uvTransform: { value: new zh }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: Gf.background_vert, fragmentShader: Gf.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: new zh } }, vertexShader: Gf.backgroundCube_vert, fragmentShader: Gf.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Gf.cube_vert, fragmentShader: Gf.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Gf.equirect_vert, fragmentShader: Gf.equirect_frag }, distanceRGBA: { uniforms: yf([Vf.common, Vf.displacementmap, { referencePosition: { value: new pd }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Gf.distanceRGBA_vert, fragmentShader: Gf.distanceRGBA_frag }, shadow: { uniforms: yf([Vf.lights, Vf.fog, { color: { value: new Pp(0) }, opacity: { value: 1 } }]), vertexShader: Gf.shadow_vert, fragmentShader: Gf.shadow_frag } }; Wf.physical = { uniforms: yf([Wf.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new zh }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new zh }, clearcoatNormalScale: { value: new kh(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new zh }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new zh }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new zh }, sheen: { value: 0 }, sheenColor: { value: new Pp(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new zh }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new zh }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new zh }, transmissionSamplerSize: { value: new kh }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new zh }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Pp(0) }, specularColor: { value: new Pp(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new zh }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new zh }, anisotropyVector: { value: new kh }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new zh } }]), vertexShader: Gf.meshphysical_vert, fragmentShader: Gf.meshphysical_frag }; const jf = { r: 0, b: 0, g: 0 }, Xf = new Qd, qf = new Vd; function Yf(e, t, n, i, r, s, a) { const o = new Pp(0); let l, c, u = !0 === s ? 0 : 1, h = null, d = 0, p = null; function f(t, n) { t.getRGB(jf, xf(e)), i.buffers.color.setClear(jf.r, jf.g, jf.b, n, a) } return { getClearColor: function () { return o }, setClearColor: function (e, t = 1) { o.set(e), u = t, f(o, u) }, getClearAlpha: function () { return u }, setClearAlpha: function (e) { u = e, f(o, u) }, render: function (s, m) { let g = !1, v = !0 === m.isScene ? m.background : null; if (v && v.isTexture) { v = (m.backgroundBlurriness > 0 ? n : t).get(v) } null === v ? f(o, u) : v && v.isColor && (f(v, 1), g = !0); const _ = e.xr.getEnvironmentBlendMode(); "additive" === _ ? i.buffers.color.setClear(0, 0, 0, 1, a) : "alpha-blend" === _ && i.buffers.color.setClear(0, 0, 0, 0, a), (e.autoClear || g) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), v && (v.isCubeTexture || v.mapping === Iu) ? (void 0 === c && (c = new mf(new vf(1, 1, 1), new Ef({ name: "BackgroundCubeMaterial", uniforms: _f(Wf.backgroundCube.uniforms), vertexShader: Wf.backgroundCube.vertexShader, fragmentShader: Wf.backgroundCube.fragmentShader, side: mu, depthTest: !1, depthWrite: !1, fog: !1 })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function (e, t, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(c.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(c)), Xf.copy(m.backgroundRotation), Xf.x *= -1, Xf.y *= -1, Xf.z *= -1, v.isCubeTexture && !1 === v.isRenderTargetTexture && (Xf.y *= -1, Xf.z *= -1), c.material.uniforms.envMap.value = v, c.material.uniforms.flipEnvMap.value = v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, c.material.uniforms.backgroundRotation.value.setFromMatrix4(qf.makeRotationFromEuler(Xf)), c.material.toneMapped = Zh.getTransfer(v.colorSpace) !== gh, h === v && d === v.version && p === e.toneMapping || (c.material.needsUpdate = !0, h = v, d = v.version, p = e.toneMapping), c.layers.enableAll(), s.unshift(c, c.geometry, c.material, 0, 0, null)) : v && v.isTexture && (void 0 === l && (l = new mf(new Hf(2, 2), new Ef({ name: "BackgroundMaterial", uniforms: _f(Wf.background.uniforms), vertexShader: Wf.background.vertexShader, fragmentShader: Wf.background.fragmentShader, side: fu, depthTest: !1, depthWrite: !1, fog: !1 })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(l)), l.material.uniforms.t2D.value = v, l.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, l.material.toneMapped = Zh.getTransfer(v.colorSpace) !== gh, !0 === v.matrixAutoUpdate && v.updateMatrix(), l.material.uniforms.uvTransform.value.copy(v.matrix), h === v && d === v.version && p === e.toneMapping || (l.material.needsUpdate = !0, h = v, d = v.version, p = e.toneMapping), l.layers.enableAll(), s.unshift(l, l.geometry, l.material, 0, 0, null)) } } } function Kf(e, t, n, i) { const r = e.getParameter(e.MAX_VERTEX_ATTRIBS), s = i.isWebGL2 ? null : t.get("OES_vertex_array_object"), a = i.isWebGL2 || null !== s, o = {}, l = p(null); let c = l, u = !1; function h(t) { return i.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t) } function d(t) { return i.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t) } function p(e) { const t = [], n = [], i = []; for (let e = 0; e < r; e++)t[e] = 0, n[e] = 0, i[e] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: t, enabledAttributes: n, attributeDivisors: i, object: e, attributes: {}, index: null } } function f() { const e = c.newAttributes; for (let t = 0, n = e.length; t < n; t++)e[t] = 0 } function m(e) { g(e, 0) } function g(n, r) { const s = c.newAttributes, a = c.enabledAttributes, o = c.attributeDivisors; if (s[n] = 1, 0 === a[n] && (e.enableVertexAttribArray(n), a[n] = 1), o[n] !== r) { (i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), o[n] = r } } function v() { const t = c.newAttributes, n = c.enabledAttributes; for (let i = 0, r = n.length; i < r; i++)n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0) } function _(t, n, i, r, s, a, o) { !0 === o ? e.vertexAttribIPointer(t, n, i, s, a) : e.vertexAttribPointer(t, n, i, r, s, a) } function y() { x(), u = !0, c !== l && (c = l, h(c.object)) } function x() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: function (r, l, d, y, x) { let b = !1; if (a) { const t = function (t, n, r) { const a = !0 === r.wireframe; let l = o[t.id]; void 0 === l && (l = {}, o[t.id] = l); let c = l[n.id]; void 0 === c && (c = {}, l[n.id] = c); let u = c[a]; void 0 === u && (u = p(i.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()), c[a] = u); return u }(y, d, l); c !== t && (c = t, h(c.object)), b = function (e, t, n, i) { const r = c.attributes, s = t.attributes; let a = 0; const o = n.getAttributes(); for (const t in o) { if (o[t].location >= 0) { const n = r[t]; let i = s[t]; if (void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (i = e.instanceColor)), void 0 === n) return !0; if (n.attribute !== i) return !0; if (i && n.data !== i.data) return !0; a++ } } return c.attributesNum !== a || c.index !== i }(r, y, d, x), b && function (e, t, n, i) { const r = {}, s = t.attributes; let a = 0; const o = n.getAttributes(); for (const t in o) { if (o[t].location >= 0) { let n = s[t]; void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (n = e.instanceColor)); const i = {}; i.attribute = n, n && n.data && (i.data = n.data), r[t] = i, a++ } } c.attributes = r, c.attributesNum = a, c.index = i }(r, y, d, x) } else { const e = !0 === l.wireframe; c.geometry === y.id && c.program === d.id && c.wireframe === e || (c.geometry = y.id, c.program = d.id, c.wireframe = e, b = !0) } null !== x && n.update(x, e.ELEMENT_ARRAY_BUFFER), (b || u) && (u = !1, function (r, s, a, o) { if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return; f(); const l = o.attributes, c = a.getAttributes(), u = s.defaultAttributeValues; for (const t in c) { const s = c[t]; if (s.location >= 0) { let a = l[t]; if (void 0 === a && ("instanceMatrix" === t && r.instanceMatrix && (a = r.instanceMatrix), "instanceColor" === t && r.instanceColor && (a = r.instanceColor)), void 0 !== a) { const t = a.normalized, l = a.itemSize, c = n.get(a); if (void 0 === c) continue; const u = c.buffer, h = c.type, d = c.bytesPerElement, p = !0 === i.isWebGL2 && (h === e.INT || h === e.UNSIGNED_INT || a.gpuType === ju); if (a.isInterleavedBufferAttribute) { const n = a.data, i = n.stride, c = a.offset; if (n.isInstancedInterleavedBuffer) { for (let e = 0; e < s.locationSize; e++)g(s.location + e, n.meshPerAttribute); !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count) } else for (let e = 0; e < s.locationSize; e++)m(s.location + e); e.bindBuffer(e.ARRAY_BUFFER, u); for (let e = 0; e < s.locationSize; e++)_(s.location + e, l / s.locationSize, h, t, i * d, (c + l / s.locationSize * e) * d, p) } else { if (a.isInstancedBufferAttribute) { for (let e = 0; e < s.locationSize; e++)g(s.location + e, a.meshPerAttribute); !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = a.meshPerAttribute * a.count) } else for (let e = 0; e < s.locationSize; e++)m(s.location + e); e.bindBuffer(e.ARRAY_BUFFER, u); for (let e = 0; e < s.locationSize; e++)_(s.location + e, l / s.locationSize, h, t, l * d, l / s.locationSize * e * d, p) } } else if (void 0 !== u) { const n = u[t]; if (void 0 !== n) switch (n.length) { case 2: e.vertexAttrib2fv(s.location, n); break; case 3: e.vertexAttrib3fv(s.location, n); break; case 4: e.vertexAttrib4fv(s.location, n); break; default: e.vertexAttrib1fv(s.location, n) } } } } v() }(r, l, d, y), null !== x && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n.get(x).buffer)) }, reset: y, resetDefaultState: x, dispose: function () { y(); for (const e in o) { const t = o[e]; for (const e in t) { const n = t[e]; for (const e in n) d(n[e].object), delete n[e]; delete t[e] } delete o[e] } }, releaseStatesOfGeometry: function (e) { if (void 0 === o[e.id]) return; const t = o[e.id]; for (const e in t) { const n = t[e]; for (const e in n) d(n[e].object), delete n[e]; delete t[e] } delete o[e.id] }, releaseStatesOfProgram: function (e) { for (const t in o) { const n = o[t]; if (void 0 === n[e.id]) continue; const i = n[e.id]; for (const e in i) d(i[e].object), delete i[e]; delete n[e.id] } }, initAttributes: f, enableAttribute: m, disableUnusedAttributes: v } } function $f(e, t, n, i) { const r = i.isWebGL2; let s; this.setMode = function (e) { s = e }, this.render = function (t, i) { e.drawArrays(s, t, i), n.update(i, s, 1) }, this.renderInstances = function (i, a, o) { if (0 === o) return; let l, c; if (r) l = e, c = "drawArraysInstanced"; else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[c](s, i, a, o), n.update(a, s, o) }, this.renderMultiDraw = function (e, i, r) { if (0 === r) return; const a = t.get("WEBGL_multi_draw"); if (null === a) for (let t = 0; t < r; t++)this.render(e[t], i[t]); else { a.multiDrawArraysWEBGL(s, e, 0, i, 0, r); let t = 0; for (let e = 0; e < r; e++)t += i[e]; n.update(t, s, 1) } } } function Zf(e, t, n) { let i; function r(t) { if ("highp" === t) { if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp"; t = "mediump" } return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } const s = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === e.constructor.name; let a = void 0 !== n.precision ? n.precision : "highp"; const o = r(a); o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o); const l = s || t.has("WEBGL_draw_buffers"), c = !0 === n.logarithmicDepthBuffer, u = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), h = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS), d = e.getParameter(e.MAX_TEXTURE_SIZE), p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE), f = e.getParameter(e.MAX_VERTEX_ATTRIBS), m = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS), g = e.getParameter(e.MAX_VARYING_VECTORS), v = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS), _ = h > 0, y = s || t.has("OES_texture_float"); return { isWebGL2: s, drawBuffers: l, getMaxAnisotropy: function () { if (void 0 !== i) return i; if (!0 === t.has("EXT_texture_filter_anisotropic")) { const n = t.get("EXT_texture_filter_anisotropic"); i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else i = 0; return i }, getMaxPrecision: r, precision: a, logarithmicDepthBuffer: c, maxTextures: u, maxVertexTextures: h, maxTextureSize: d, maxCubemapSize: p, maxAttributes: f, maxVertexUniforms: m, maxVaryings: g, maxFragmentUniforms: v, vertexTextures: _, floatFragmentTextures: y, floatVertexTextures: _ && y, maxSamples: s ? e.getParameter(e.MAX_SAMPLES) : 0 } } function Jf(e) { const t = this; let n = null, i = 0, r = !1, s = !1; const a = new Of, o = new zh, l = { value: null, needsUpdate: !1 }; function c(e, n, i, r) { const s = null !== e ? e.length : 0; let c = null; if (0 !== s) { if (c = l.value, !0 !== r || null === c) { const t = i + 4 * s, r = n.matrixWorldInverse; o.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t)); for (let t = 0, n = i; t !== s; ++t, n += 4)a.copy(e[t]).applyMatrix4(r, o), a.normal.toArray(c, n), c[n + 3] = a.constant } l.value = c, l.needsUpdate = !0 } return t.numPlanes = s, t.numIntersection = 0, c } this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t) { const n = 0 !== e.length || t || 0 !== i || r; return r = t, i = e.length, n }, this.beginShadows = function () { s = !0, c(null) }, this.endShadows = function () { s = !1 }, this.setGlobalState = function (e, t) { n = c(e, t, 0) }, this.setState = function (a, o, u) { const h = a.clippingPlanes, d = a.clipIntersection, p = a.clipShadows, f = e.get(a); if (!r || null === h || 0 === h.length || s && !p) s ? c(null) : function () { l.value !== n && (l.value = n, l.needsUpdate = i > 0); t.numPlanes = i, t.numIntersection = 0 }(); else { const e = s ? 0 : i, t = 4 * e; let r = f.clippingState || null; l.value = r, r = c(h, o, t, u); for (let e = 0; e !== t; ++e)r[e] = n[e]; f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e } } } function Qf(e) { let t = new WeakMap; function n(e, t) { return t === Lu ? e.mapping = Cu : t === Pu && (e.mapping = Ru), e } function i(e) { const n = e.target; n.removeEventListener("dispose", i); const r = t.get(n); void 0 !== r && (t.delete(n), r.dispose()) } return { get: function (r) { if (r && r.isTexture) { const s = r.mapping; if (s === Lu || s === Pu) { if (t.has(r)) { return n(t.get(r).texture, r.mapping) } { const s = r.image; if (s && s.height > 0) { const a = new Lf(s.height); return a.fromEquirectangularTexture(e, r), t.set(r, a), r.addEventListener("dispose", i), n(a.texture, r.mapping) } return null } } } return r }, dispose: function () { t = new WeakMap } } } class em extends Tf { constructor(e = -1, t = 1, n = 1, i = -1, r = .1, s = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this } setViewOffset(e, t, n, i, r, s) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2; let r = n - e, s = n + e, a = i + t, o = i - t; if (null !== this.view && this.view.enabled) { const e = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom; r += e * this.view.offsetX, s = r + e * this.view.width, a -= t * this.view.offsetY, o = a - t * this.view.height } this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } } const tm = [.125, .215, .35, .446, .526, .582], nm = 20, im = new em, rm = new Pp; let sm = null, am = 0, om = 0; const lm = (1 + Math.sqrt(5)) / 2, cm = 1 / lm, um = [new pd(1, 1, 1), new pd(-1, 1, 1), new pd(1, 1, -1), new pd(-1, 1, -1), new pd(0, lm, cm), new pd(0, lm, -cm), new pd(cm, 0, lm), new pd(-cm, 0, lm), new pd(lm, cm, 0), new pd(-lm, cm, 0)]; class hm { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, n = .1, i = 100) { sm = this._renderer.getRenderTarget(), am = this._renderer.getActiveCubeFace(), om = this._renderer.getActiveMipmapLevel(), this._setSize(256); const r = this._allocateTargets(); return r.depthBuffer = !0, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r } fromEquirectangular(e, t = null) { return this._fromTexture(e, t) } fromCubemap(e, t = null) { return this._fromTexture(e, t) } compileCubemapShader() { null === this._cubemapMaterial && (this._cubemapMaterial = mm(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { null === this._equirectMaterial && (this._equirectMaterial = fm(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget(sm, am, om), e.scissorTest = !1, pm(e, 0, 0, e.width, e.height) } _fromTexture(e, t) { e.mapping === Cu || e.mapping === Ru ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), sm = this._renderer.getRenderTarget(), am = this._renderer.getActiveCubeFace(), om = this._renderer.getActiveMipmapLevel(); const n = t || this._allocateTargets(); return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n } _allocateTargets() { const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = { magFilter: zu, minFilter: zu, generateMipmaps: !1, type: Yu, format: $u, colorSpace: dh, depthBuffer: !1 }, i = dm(e, t, n); if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) { null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = dm(e, t, n); const { _lodMax: i } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function (e) { const t = [], n = [], i = []; let r = e; const s = e - 4 + 1 + tm.length; for (let a = 0; a < s; a++) { const s = Math.pow(2, r); n.push(s); let o = 1 / s; a > e - 4 ? o = tm[a - e + 4 - 1] : 0 === a && (o = 0), i.push(o); const l = 1 / (s - 2), c = -l, u = 1 + l, h = [c, c, u, c, u, u, c, c, u, u, c, u], d = 6, p = 6, f = 3, m = 2, g = 1, v = new Float32Array(f * p * d), _ = new Float32Array(m * p * d), y = new Float32Array(g * p * d); for (let e = 0; e < d; e++) { const t = e % 3 * 2 / 3 - 1, n = e > 2 ? 0 : -1, i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0]; v.set(i, f * p * e), _.set(h, m * p * e); const r = [e, e, e, e, e, e]; y.set(r, g * p * e) } const x = new $p; x.setAttribute("position", new kp(v, f)), x.setAttribute("uv", new kp(_, m)), x.setAttribute("faceIndex", new kp(y, g)), t.push(x), r > 4 && r-- } return { lodPlanes: t, sizeLods: n, sigmas: i } }(i)), this._blurMaterial = function (e, t, n) { const i = new Float32Array(nm), r = new pd(0, 1, 0), s = new Ef({ name: "SphericalGaussianBlur", defines: { n: nm, CUBEUV_TEXEL_WIDTH: 1 / t, CUBEUV_TEXEL_HEIGHT: 1 / n, CUBEUV_MAX_MIP: `${e}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: i }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r } }, vertexShader: gm(), fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }); return s }(i, e, t) } return i } _compileMaterial(e) { const t = new mf(this._lodPlanes[0], e); this._renderer.compile(t, im) } _sceneToCubeUV(e, t, n, i) { const r = new Af(90, 1, t, n), s = [1, -1, 1, 1, 1, 1], a = [1, 1, 1, -1, -1, -1], o = this._renderer, l = o.autoClear, c = o.toneMapping; o.getClearColor(rm), o.toneMapping = xu, o.autoClear = !1; const u = new Fp({ name: "PMREM.Background", side: mu, depthWrite: !1, depthTest: !1 }), h = new mf(new vf, u); let d = !1; const p = e.background; p ? p.isColor && (u.color.copy(p), e.background = null, d = !0) : (u.color.copy(rm), d = !0); for (let t = 0; t < 6; t++) { const n = t % 3; 0 === n ? (r.up.set(0, s[t], 0), r.lookAt(a[t], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[t]), r.lookAt(0, a[t], 0)) : (r.up.set(0, s[t], 0), r.lookAt(0, 0, a[t])); const l = this._cubeSize; pm(i, n * l, t > 2 ? l : 0, l, l), o.setRenderTarget(i), d && o.render(h, r), o.render(e, r) } h.geometry.dispose(), h.material.dispose(), o.toneMapping = c, o.autoClear = l, e.background = p } _textureToCubeUV(e, t) { const n = this._renderer, i = e.mapping === Cu || e.mapping === Ru; i ? (null === this._cubemapMaterial && (this._cubemapMaterial = mm()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = fm()); const r = i ? this._cubemapMaterial : this._equirectMaterial, s = new mf(this._lodPlanes[0], r); r.uniforms.envMap.value = e; const a = this._cubeSize; pm(t, 0, 0, 3 * a, 2 * a), n.setRenderTarget(t), n.render(s, im) } _applyPMREM(e) { const t = this._renderer, n = t.autoClear; t.autoClear = !1; for (let t = 1; t < this._lodPlanes.length; t++) { const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]), i = um[(t - 1) % um.length]; this._blur(e, t - 1, t, n, i) } t.autoClear = n } _blur(e, t, n, i, r) { const s = this._pingPongRenderTarget; this._halfBlur(e, s, t, n, i, "latitudinal", r), this._halfBlur(s, e, n, n, i, "longitudinal", r) } _halfBlur(e, t, n, i, r, s, a) { const o = this._renderer, l = this._blurMaterial; "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!"); const c = new mf(this._lodPlanes[i], l), u = l.uniforms, h = this._sizeLods[n] - 1, d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39, p = r / d, f = isFinite(r) ? 1 + Math.floor(3 * p) : nm; f > nm && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`); const m = []; let g = 0; for (let e = 0; e < nm; ++e) { const t = e / p, n = Math.exp(-t * t / 2); m.push(n), 0 === e ? g += n : e < f && (g += 2 * n) } for (let e = 0; e < m.length; e++)m[e] = m[e] / g; u.envMap.value = e.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === s, a && (u.poleAxis.value = a); const { _lodMax: v } = this; u.dTheta.value = d, u.mipInt.value = v - n; const _ = this._sizeLods[i]; pm(t, 3 * _ * (i > v - 4 ? i - v + 4 : 0), 4 * (this._cubeSize - _), 3 * _, 2 * _), o.setRenderTarget(t), o.render(c, im) } } function dm(e, t, n) { const i = new cd(e, t, n); return i.texture.mapping = Iu, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i } function pm(e, t, n, i, r) { e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r) } function fm() { return new Ef({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: gm(), fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }) } function mm() { return new Ef({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: gm(), fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }) } function gm() { return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t" } function vm(e) { let t = new WeakMap, n = null; function i(e) { const n = e.target; n.removeEventListener("dispose", i); const r = t.get(n); void 0 !== r && (t.delete(n), r.dispose()) } return { get: function (r) { if (r && r.isTexture) { const s = r.mapping, a = s === Lu || s === Pu, o = s === Cu || s === Ru; if (a || o) { if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) { r.needsPMREMUpdate = !1; let i = t.get(r); return null === n && (n = new hm(e)), i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), t.set(r, i), i.texture } if (t.has(r)) return t.get(r).texture; { const s = r.image; if (a && s && s.height > 0 || o && s && function (e) { let t = 0; const n = 6; for (let i = 0; i < n; i++)void 0 !== e[i] && t++; return t === n }(s)) { null === n && (n = new hm(e)); const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r); return t.set(r, s), r.addEventListener("dispose", i), s.texture } return null } } } return r }, dispose: function () { t = new WeakMap, null !== n && (n.dispose(), n = null) } } } function _m(e) { const t = {}; function n(n) { if (void 0 !== t[n]) return t[n]; let i; switch (n) { case "WEBGL_depth_texture": i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = e.getExtension(n) }return t[n] = i, i } return { has: function (e) { return null !== n(e) }, init: function (e) { e.isWebGL2 ? (n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance")) : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture") }, get: function (e) { const t = n(e); return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t } } } function ym(e, t, n, i) { const r = {}, s = new WeakMap; function a(e) { const o = e.target; null !== o.index && t.remove(o.index); for (const e in o.attributes) t.remove(o.attributes[e]); for (const e in o.morphAttributes) { const n = o.morphAttributes[e]; for (let e = 0, i = n.length; e < i; e++)t.remove(n[e]) } o.removeEventListener("dispose", a), delete r[o.id]; const l = s.get(o); l && (t.remove(l), s.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries-- } function o(e) { const n = [], i = e.index, r = e.attributes.position; let a = 0; if (null !== i) { const e = i.array; a = i.version; for (let t = 0, i = e.length; t < i; t += 3) { const i = e[t + 0], r = e[t + 1], s = e[t + 2]; n.push(i, r, r, s, s, i) } } else { if (void 0 === r) return; { const e = r.array; a = r.version; for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) { const e = t + 0, i = t + 1, r = t + 2; n.push(e, i, i, r, r, e) } } } const o = new (Gh(n) ? Hp : zp)(n, 1); o.version = a; const l = s.get(e); l && t.remove(l), s.set(e, o) } return { get: function (e, t) { return !0 === r[t.id] || (t.addEventListener("dispose", a), r[t.id] = !0, n.memory.geometries++), t }, update: function (n) { const i = n.attributes; for (const n in i) t.update(i[n], e.ARRAY_BUFFER); const r = n.morphAttributes; for (const n in r) { const i = r[n]; for (let n = 0, r = i.length; n < r; n++)t.update(i[n], e.ARRAY_BUFFER) } }, getWireframeAttribute: function (e) { const t = s.get(e); if (t) { const n = e.index; null !== n && t.version < n.version && o(e) } else o(e); return s.get(e) } } } function xm(e, t, n, i) { const r = i.isWebGL2; let s, a, o; this.setMode = function (e) { s = e }, this.setIndex = function (e) { a = e.type, o = e.bytesPerElement }, this.render = function (t, i) { e.drawElements(s, i, a, t * o), n.update(i, s, 1) }, this.renderInstances = function (i, l, c) { if (0 === c) return; let u, h; if (r) u = e, h = "drawElementsInstanced"; else if (u = t.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); u[h](s, l, a, i * o, c), n.update(l, s, c) }, this.renderMultiDraw = function (e, i, r) { if (0 === r) return; const l = t.get("WEBGL_multi_draw"); if (null === l) for (let t = 0; t < r; t++)this.render(e[t] / o, i[t]); else { l.multiDrawElementsWEBGL(s, i, 0, a, e, 0, r); let t = 0; for (let e = 0; e < r; e++)t += i[e]; n.update(t, s, 1) } } } function bm(e) { const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: !0, reset: function () { t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 }, update: function (n, i, r) { switch (t.calls++, i) { case e.TRIANGLES: t.triangles += r * (n / 3); break; case e.LINES: t.lines += r * (n / 2); break; case e.LINE_STRIP: t.lines += r * (n - 1); break; case e.LINE_LOOP: t.lines += r * n; break; case e.POINTS: t.points += r * n; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", i) } } } } function Em(e, t) { return e[0] - t[0] } function Tm(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) } function Sm(e, t, n) { const i = {}, r = new Float32Array(8), s = new WeakMap, a = new od, o = []; for (let e = 0; e < 8; e++)o[e] = [e, 0]; return { update: function (l, c, u) { const h = l.morphTargetInfluences; if (!0 === t.isWebGL2) { const d = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color, p = void 0 !== d ? d.length : 0; let f = s.get(c); if (void 0 === f || f.count !== p) { void 0 !== f && f.texture.dispose(); const m = void 0 !== c.morphAttributes.position, g = void 0 !== c.morphAttributes.normal, v = void 0 !== c.morphAttributes.color, _ = c.morphAttributes.position || [], y = c.morphAttributes.normal || [], x = c.morphAttributes.color || []; let b = 0; !0 === m && (b = 1), !0 === g && (b = 2), !0 === v && (b = 3); let E = c.attributes.position.count * b, T = 1; E > t.maxTextureSize && (T = Math.ceil(E / t.maxTextureSize), E = t.maxTextureSize); const S = new Float32Array(E * T * 4 * p), M = new ud(S, E, T, p); M.type = qu, M.needsUpdate = !0; const w = 4 * b; for (let D = 0; D < p; D++) { const C = _[D], R = y[D], L = x[D], P = E * T * 4 * D; for (let I = 0; I < C.count; I++) { const N = I * w; !0 === m && (a.fromBufferAttribute(C, I), S[P + N + 0] = a.x, S[P + N + 1] = a.y, S[P + N + 2] = a.z, S[P + N + 3] = 0), !0 === g && (a.fromBufferAttribute(R, I), S[P + N + 4] = a.x, S[P + N + 5] = a.y, S[P + N + 6] = a.z, S[P + N + 7] = 0), !0 === v && (a.fromBufferAttribute(L, I), S[P + N + 8] = a.x, S[P + N + 9] = a.y, S[P + N + 10] = a.z, S[P + N + 11] = 4 === L.itemSize ? a.w : 1) } } function A() { M.dispose(), s.delete(c), c.removeEventListener("dispose", A) } f = { count: p, texture: M, size: new kh(E, T) }, s.set(c, f), c.addEventListener("dispose", A) } if (!0 === l.isInstancedMesh && null !== l.morphTexture) u.getUniforms().setValue(e, "morphTexture", l.morphTexture, n); else { let O = 0; for (let U = 0; U < h.length; U++)O += h[U]; const F = c.morphTargetsRelative ? 1 : 1 - O; u.getUniforms().setValue(e, "morphTargetBaseInfluence", F), u.getUniforms().setValue(e, "morphTargetInfluences", h) } u.getUniforms().setValue(e, "morphTargetsTexture", f.texture, n), u.getUniforms().setValue(e, "morphTargetsTextureSize", f.size) } else { const B = void 0 === h ? 0 : h.length; let k = i[c.id]; if (void 0 === k || k.length !== B) { k = []; for (let W = 0; W < B; W++)k[W] = [W, 0]; i[c.id] = k } for (let j = 0; j < B; j++) { const X = k[j]; X[0] = j, X[1] = h[j] } k.sort(Tm); for (let q = 0; q < 8; q++)q < B && k[q][1] ? (o[q][0] = k[q][0], o[q][1] = k[q][1]) : (o[q][0] = Number.MAX_SAFE_INTEGER, o[q][1] = 0); o.sort(Em); const z = c.morphAttributes.position, H = c.morphAttributes.normal; let G = 0; for (let Y = 0; Y < 8; Y++) { const K = o[Y], $ = K[0], Z = K[1]; $ !== Number.MAX_SAFE_INTEGER && Z ? (z && c.getAttribute("morphTarget" + Y) !== z[$] && c.setAttribute("morphTarget" + Y, z[$]), H && c.getAttribute("morphNormal" + Y) !== H[$] && c.setAttribute("morphNormal" + Y, H[$]), r[Y] = Z, G += Z) : (z && !0 === c.hasAttribute("morphTarget" + Y) && c.deleteAttribute("morphTarget" + Y), H && !0 === c.hasAttribute("morphNormal" + Y) && c.deleteAttribute("morphNormal" + Y), r[Y] = 0) } const V = c.morphTargetsRelative ? 1 : 1 - G; u.getUniforms().setValue(e, "morphTargetBaseInfluence", V), u.getUniforms().setValue(e, "morphTargetInfluences", r) } } } } function Mm(e, t, n, i) { let r = new WeakMap; function s(e) { const t = e.target; t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor) } return { update: function (a) { const o = i.render.frame, l = a.geometry, c = t.get(a, l); if (r.get(c) !== o && (t.update(c), r.set(c, o)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s), r.get(a) !== o && (n.update(a.instanceMatrix, e.ARRAY_BUFFER), null !== a.instanceColor && n.update(a.instanceColor, e.ARRAY_BUFFER), r.set(a, o))), a.isSkinnedMesh) { const e = a.skeleton; r.get(e) !== o && (e.update(), r.set(e, o)) } return c }, dispose: function () { r = new WeakMap } } } class wm extends ad { constructor(e, t, n, i, r, s, a, o, l, c) { if ((c = void 0 !== c ? c : Zu) !== Zu && c !== Ju) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && c === Zu && (n = Xu), void 0 === n && c === Ju && (n = Ku), super(null, i, r, s, a, o, c, n, l), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = void 0 !== a ? a : Uu, this.minFilter = void 0 !== o ? o : Uu, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null } copy(e) { return super.copy(e), this.compareFunction = e.compareFunction, this } toJSON(e) { const t = super.toJSON(e); return null !== this.compareFunction && (t.compareFunction = this.compareFunction), t } } const Am = new ad, Dm = new wm(1, 1); Dm.compareFunction = 515; const Cm = new ud, Rm = new hd, Lm = new Rf, Pm = [], Im = [], Nm = new Float32Array(16), Om = new Float32Array(9), Fm = new Float32Array(4); function Um(e, t, n) { const i = e[0]; if (i <= 0 || i > 0) return e; const r = t * n; let s = Pm[r]; if (void 0 === s && (s = new Float32Array(r), Pm[r] = s), 0 !== t) { i.toArray(s, 0); for (let i = 1, r = 0; i !== t; ++i)r += n, e[i].toArray(s, r) } return s } function Bm(e, t) { if (e.length !== t.length) return !1; for (let n = 0, i = e.length; n < i; n++)if (e[n] !== t[n]) return !1; return !0 } function km(e, t) { for (let n = 0, i = t.length; n < i; n++)e[n] = t[n] } function zm(e, t) { let n = Im[t]; void 0 === n && (n = new Int32Array(t), Im[t] = n); for (let i = 0; i !== t; ++i)n[i] = e.allocateTextureUnit(); return n } function Hm(e, t) { const n = this.cache; n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t) } function Gm(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y); else { if (Bm(n, t)) return; e.uniform2fv(this.addr, t), km(n, t) } } function Vm(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z); else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b); else { if (Bm(n, t)) return; e.uniform3fv(this.addr, t), km(n, t) } } function Wm(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w); else { if (Bm(n, t)) return; e.uniform4fv(this.addr, t), km(n, t) } } function jm(e, t) { const n = this.cache, i = t.elements; if (void 0 === i) { if (Bm(n, t)) return; e.uniformMatrix2fv(this.addr, !1, t), km(n, t) } else { if (Bm(n, i)) return; Fm.set(i), e.uniformMatrix2fv(this.addr, !1, Fm), km(n, i) } } function Xm(e, t) { const n = this.cache, i = t.elements; if (void 0 === i) { if (Bm(n, t)) return; e.uniformMatrix3fv(this.addr, !1, t), km(n, t) } else { if (Bm(n, i)) return; Om.set(i), e.uniformMatrix3fv(this.addr, !1, Om), km(n, i) } } function qm(e, t) { const n = this.cache, i = t.elements; if (void 0 === i) { if (Bm(n, t)) return; e.uniformMatrix4fv(this.addr, !1, t), km(n, t) } else { if (Bm(n, i)) return; Nm.set(i), e.uniformMatrix4fv(this.addr, !1, Nm), km(n, i) } } function Ym(e, t) { const n = this.cache; n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t) } function Km(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y); else { if (Bm(n, t)) return; e.uniform2iv(this.addr, t), km(n, t) } } function $m(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z); else { if (Bm(n, t)) return; e.uniform3iv(this.addr, t), km(n, t) } } function Zm(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w); else { if (Bm(n, t)) return; e.uniform4iv(this.addr, t), km(n, t) } } function Jm(e, t) { const n = this.cache; n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t) } function Qm(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y); else { if (Bm(n, t)) return; e.uniform2uiv(this.addr, t), km(n, t) } } function eg(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z); else { if (Bm(n, t)) return; e.uniform3uiv(this.addr, t), km(n, t) } } function tg(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w); else { if (Bm(n, t)) return; e.uniform4uiv(this.addr, t), km(n, t) } } function ng(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r); const s = this.type === e.SAMPLER_2D_SHADOW ? Dm : Am; n.setTexture2D(t || s, r) } function ig(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || Rm, r) } function rg(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(t || Lm, r) } function sg(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || Cm, r) } function ag(e, t) { e.uniform1fv(this.addr, t) } function og(e, t) { const n = Um(t, this.size, 2); e.uniform2fv(this.addr, n) } function lg(e, t) { const n = Um(t, this.size, 3); e.uniform3fv(this.addr, n) } function cg(e, t) { const n = Um(t, this.size, 4); e.uniform4fv(this.addr, n) } function ug(e, t) { const n = Um(t, this.size, 4); e.uniformMatrix2fv(this.addr, !1, n) } function hg(e, t) { const n = Um(t, this.size, 9); e.uniformMatrix3fv(this.addr, !1, n) } function dg(e, t) { const n = Um(t, this.size, 16); e.uniformMatrix4fv(this.addr, !1, n) } function pg(e, t) { e.uniform1iv(this.addr, t) } function fg(e, t) { e.uniform2iv(this.addr, t) } function mg(e, t) { e.uniform3iv(this.addr, t) } function gg(e, t) { e.uniform4iv(this.addr, t) } function vg(e, t) { e.uniform1uiv(this.addr, t) } function _g(e, t) { e.uniform2uiv(this.addr, t) } function yg(e, t) { e.uniform3uiv(this.addr, t) } function xg(e, t) { e.uniform4uiv(this.addr, t) } function bg(e, t, n) { const i = this.cache, r = t.length, s = zm(n, r); Bm(i, s) || (e.uniform1iv(this.addr, s), km(i, s)); for (let e = 0; e !== r; ++e)n.setTexture2D(t[e] || Am, s[e]) } function Eg(e, t, n) { const i = this.cache, r = t.length, s = zm(n, r); Bm(i, s) || (e.uniform1iv(this.addr, s), km(i, s)); for (let e = 0; e !== r; ++e)n.setTexture3D(t[e] || Rm, s[e]) } function Tg(e, t, n) { const i = this.cache, r = t.length, s = zm(n, r); Bm(i, s) || (e.uniform1iv(this.addr, s), km(i, s)); for (let e = 0; e !== r; ++e)n.setTextureCube(t[e] || Lm, s[e]) } function Sg(e, t, n) { const i = this.cache, r = t.length, s = zm(n, r); Bm(i, s) || (e.uniform1iv(this.addr, s), km(i, s)); for (let e = 0; e !== r; ++e)n.setTexture2DArray(t[e] || Cm, s[e]) } class Mg { constructor(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = function (e) { switch (e) { case 5126: return Hm; case 35664: return Gm; case 35665: return Vm; case 35666: return Wm; case 35674: return jm; case 35675: return Xm; case 35676: return qm; case 5124: case 35670: return Ym; case 35667: case 35671: return Km; case 35668: case 35672: return $m; case 35669: case 35673: return Zm; case 5125: return Jm; case 36294: return Qm; case 36295: return eg; case 36296: return tg; case 35678: case 36198: case 36298: case 36306: case 35682: return ng; case 35679: case 36299: case 36307: return ig; case 35680: case 36300: case 36308: case 36293: return rg; case 36289: case 36303: case 36311: case 36292: return sg } }(t.type) } } class wg { constructor(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = function (e) { switch (e) { case 5126: return ag; case 35664: return og; case 35665: return lg; case 35666: return cg; case 35674: return ug; case 35675: return hg; case 35676: return dg; case 5124: case 35670: return pg; case 35667: case 35671: return fg; case 35668: case 35672: return mg; case 35669: case 35673: return gg; case 5125: return vg; case 36294: return _g; case 36295: return yg; case 36296: return xg; case 35678: case 36198: case 36298: case 36306: case 35682: return bg; case 35679: case 36299: case 36307: return Eg; case 35680: case 36300: case 36308: case 36293: return Tg; case 36289: case 36303: case 36311: case 36292: return Sg } }(t.type) } } class Ag { constructor(e) { this.id = e, this.seq = [], this.map = {} } setValue(e, t, n) { const i = this.seq; for (let r = 0, s = i.length; r !== s; ++r) { const s = i[r]; s.setValue(e, t[s.id], n) } } } const Dg = /(\w+)(\])?(\[|\.)?/g; function Cg(e, t) { e.seq.push(t), e.map[t.id] = t } function Rg(e, t, n) { const i = e.name, r = i.length; for (Dg.lastIndex = 0; ;) { const s = Dg.exec(i), a = Dg.lastIndex; let o = s[1]; const l = "]" === s[2], c = s[3]; if (l && (o |= 0), void 0 === c || "[" === c && a + 2 === r) { Cg(n, void 0 === c ? new Mg(o, e, t) : new wg(o, e, t)); break } { let e = n.map[o]; void 0 === e && (e = new Ag(o), Cg(n, e)), n = e } } } class Lg { constructor(e, t) { this.seq = [], this.map = {}; const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS); for (let i = 0; i < n; ++i) { const n = e.getActiveUniform(t, i); Rg(n, e.getUniformLocation(t, n.name), this) } } setValue(e, t, n, i) { const r = this.map[t]; void 0 !== r && r.setValue(e, n, i) } setOptional(e, t, n) { const i = t[n]; void 0 !== i && this.setValue(e, n, i) } static upload(e, t, n, i) { for (let r = 0, s = t.length; r !== s; ++r) { const s = t[r], a = n[s.id]; !1 !== a.needsUpdate && s.setValue(e, a.value, i) } } static seqWithValue(e, t) { const n = []; for (let i = 0, r = e.length; i !== r; ++i) { const r = e[i]; r.id in t && n.push(r) } return n } } function Pg(e, t, n) { const i = e.createShader(t); return e.shaderSource(i, n), e.compileShader(i), i } const Ig = 37297; let Ng = 0; function Og(e, t, n) { const i = e.getShaderParameter(t, e.COMPILE_STATUS), r = e.getShaderInfoLog(t).trim(); if (i && "" === r) return ""; const s = /ERROR: 0:(\d+)/.exec(r); if (s) { const i = parseInt(s[1]); return n.toUpperCase() + "\n\n" + r + "\n\n" + function (e, t) { const n = e.split("\n"), i = [], r = Math.max(t - 6, 0), s = Math.min(t + 6, n.length); for (let e = r; e < s; e++) { const r = e + 1; i.push(`${r === t ? ">" : " "} ${r}: ${n[e]}`) } return i.join("\n") }(e.getShaderSource(t), i) } return r } function Fg(e, t) { const n = function (e) { const t = Zh.getPrimaries(Zh.workingColorSpace), n = Zh.getPrimaries(e); let i; switch (t === n ? i = "" : t === _h && n === vh ? i = "LinearDisplayP3ToLinearSRGB" : t === vh && n === _h && (i = "LinearSRGBToLinearDisplayP3"), e) { case dh: case fh: return [i, "LinearTransferOETF"]; case hh: case ph: return [i, "sRGBTransferOETF"]; default: return console.warn("THREE.WebGLProgram: Unsupported color space:", e), [i, "LinearTransferOETF"] } }(t); return `vec4 ${e}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }` } function Ug(e, t) { let n; switch (t) { case bu: n = "Linear"; break; case Eu: n = "Reinhard"; break; case Tu: n = "OptimizedCineon"; break; case Su: n = "ACESFilmic"; break; case wu: n = "AgX"; break; case Au: n = "Neutral"; break; case Mu: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear" }return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } function Bg(e) { return "" !== e } function kg(e, t) { const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps; return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function zg(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } const Hg = /^[ \t]*#include +<([\w\d./]+)>/gm; function Gg(e) { return e.replace(Hg, Wg) } const Vg = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]); function Wg(e, t) { let n = Gf[t]; if (void 0 === n) { const e = Vg.get(t); if (void 0 === e) throw new Error("Can not resolve #include <" + t + ">"); n = Gf[e], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e) } return Gg(n) } const jg = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function Xg(e) { return e.replace(jg, qg) } function qg(e, t, n, i) { let r = ""; for (let e = parseInt(t); e < parseInt(n); e++)r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e); return r } function Yg(e) { let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\t`; return e.isWebGL2 && (t += `precision ${e.precision} sampler3D;\n\t\tprecision ${e.precision} sampler2DArray;\n\t\tprecision ${e.precision} sampler2DShadow;\n\t\tprecision ${e.precision} samplerCubeShadow;\n\t\tprecision ${e.precision} sampler2DArrayShadow;\n\t\tprecision ${e.precision} isampler2D;\n\t\tprecision ${e.precision} isampler3D;\n\t\tprecision ${e.precision} isamplerCube;\n\t\tprecision ${e.precision} isampler2DArray;\n\t\tprecision ${e.precision} usampler2D;\n\t\tprecision ${e.precision} usampler3D;\n\t\tprecision ${e.precision} usamplerCube;\n\t\tprecision ${e.precision} usampler2DArray;\n\t\t`), "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t } function Kg(e, t, n, i) { const r = e.getContext(), s = n.defines; let a = n.vertexShader, o = n.fragmentShader; const l = function (e) { let t = "SHADOWMAP_TYPE_BASIC"; return e.shadowMapType === hu ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === du ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === pu && (t = "SHADOWMAP_TYPE_VSM"), t }(n), c = function (e) { let t = "ENVMAP_TYPE_CUBE"; if (e.envMap) switch (e.envMapMode) { case Cu: case Ru: t = "ENVMAP_TYPE_CUBE"; break; case Iu: t = "ENVMAP_TYPE_CUBE_UV" }return t }(n), u = function (e) { let t = "ENVMAP_MODE_REFLECTION"; e.envMap && e.envMapMode === Ru && (t = "ENVMAP_MODE_REFRACTION"); return t }(n), h = function (e) { let t = "ENVMAP_BLENDING_NONE"; if (e.envMap) switch (e.combine) { case vu: t = "ENVMAP_BLENDING_MULTIPLY"; break; case _u: t = "ENVMAP_BLENDING_MIX"; break; case yu: t = "ENVMAP_BLENDING_ADD" }return t }(n), d = function (e) { const t = e.envMapCubeUVHeight; if (null === t) return null; const n = Math.log2(t) - 2, i = 1 / t; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)), texelHeight: i, maxMip: n } }(n), p = n.isWebGL2 ? "" : function (e) { return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.normalMapTangentSpace || e.clearcoatNormalMap || e.flatShading || e.alphaToCoverage || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Bg).join("\n") }(n), f = function (e) { return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Bg).join("\n") }(n), m = function (e) { const t = []; for (const n in e) { const i = e[n]; !1 !== i && t.push("#define " + n + " " + i) } return t.join("\n") }(s), g = r.createProgram(); let v, _, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : ""; n.isRawShaderMaterial ? (v = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(Bg).join("\n"), v.length > 0 && (v += "\n"), _ = [p, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(Bg).join("\n"), _.length > 0 && (_ += "\n")) : (v = [Yg(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Bg).join("\n"), _ = [p, Yg(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== xu ? "#define TONE_MAPPING" : "", n.toneMapping !== xu ? Gf.tonemapping_pars_fragment : "", n.toneMapping !== xu ? Ug("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Gf.colorspace_pars_fragment, Fg("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Bg).join("\n")), a = Gg(a), a = kg(a, n), a = zg(a, n), o = Gg(o), o = kg(o, n), o = zg(o, n), a = Xg(a), o = Xg(o), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", v = [f, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + v, _ = ["precision mediump sampler2DArray;", "#define varying in", n.glslVersion === bh ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === bh ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _); const x = y + v + a, b = y + _ + o, E = Pg(r, r.VERTEX_SHADER, x), T = Pg(r, r.FRAGMENT_SHADER, b); function S(t) { if (e.debug.checkShaderErrors) { const n = r.getProgramInfoLog(g).trim(), i = r.getShaderInfoLog(E).trim(), s = r.getShaderInfoLog(T).trim(); let a = !0, o = !0; if (!1 === r.getProgramParameter(g, r.LINK_STATUS)) if (a = !1, "function" == typeof e.debug.onShaderError) e.debug.onShaderError(r, g, E, T); else { const e = Og(r, E, "vertex"), i = Og(r, T, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(g, r.VALIDATE_STATUS) + "\n\nMaterial Name: " + t.name + "\nMaterial Type: " + t.type + "\n\nProgram Info Log: " + n + "\n" + e + "\n" + i) } else "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== i && "" !== s || (o = !1); o && (t.diagnostics = { runnable: a, programLog: n, vertexShader: { log: i, prefix: v }, fragmentShader: { log: s, prefix: _ } }) } r.deleteShader(E), r.deleteShader(T), M = new Lg(r, g), w = function (e, t) { const n = {}, i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES); for (let r = 0; r < i; r++) { const i = e.getActiveAttrib(t, r), s = i.name; let a = 1; i.type === e.FLOAT_MAT2 && (a = 2), i.type === e.FLOAT_MAT3 && (a = 3), i.type === e.FLOAT_MAT4 && (a = 4), n[s] = { type: i.type, location: e.getAttribLocation(t, s), locationSize: a } } return n }(r, g) } let M, w; r.attachShader(g, E), r.attachShader(g, T), void 0 !== n.index0AttributeName ? r.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(g, 0, "position"), r.linkProgram(g), this.getUniforms = function () { return void 0 === M && S(this), M }, this.getAttributes = function () { return void 0 === w && S(this), w }; let A = !1 === n.rendererExtensionParallelShaderCompile; return this.isReady = function () { return !1 === A && (A = r.getProgramParameter(g, Ig)), A }, this.destroy = function () { i.releaseStatesOfProgram(this), r.deleteProgram(g), this.program = void 0 }, this.type = n.shaderType, this.name = n.shaderName, this.id = Ng++, this.cacheKey = t, this.usedTimes = 1, this.program = g, this.vertexShader = E, this.fragmentShader = T, this } let $g = 0; class Zg { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), r = this._getShaderStage(n), s = this._getShaderCacheForMaterial(e); return !1 === s.has(i) && (s.add(i), i.usedTimes++), !1 === s.has(r) && (s.add(r), r.usedTimes++), this } remove(e) { const t = this.materialCache.get(e); for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { const t = this.materialCache; let n = t.get(e); return void 0 === n && (n = new Set, t.set(e, n)), n } _getShaderStage(e) { const t = this.shaderCache; let n = t.get(e); return void 0 === n && (n = new Jg(e), t.set(e, n)), n } } class Jg { constructor(e) { this.id = $g++, this.code = e, this.usedTimes = 0 } } function Qg(e, t, n, i, r, s, a) { const o = new ep, l = new Zg, c = new Set, u = [], h = r.isWebGL2, d = r.logarithmicDepthBuffer, p = r.vertexTextures; let f = r.precision; const m = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function g(e) { return c.add(e), 0 === e ? "uv" : `uv${e}` } return { getParameters: function (s, o, u, v, _) { const y = v.fog, x = _.geometry, b = s.isMeshStandardMaterial ? v.environment : null, E = (s.isMeshStandardMaterial ? n : t).get(s.envMap || b), T = E && E.mapping === Iu ? E.image.height : null, S = m[s.type]; null !== s.precision && (f = r.getMaxPrecision(s.precision), f !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", f, "instead.")); const M = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color, w = void 0 !== M ? M.length : 0; let A, D, C, R, L = 0; if (void 0 !== x.morphAttributes.position && (L = 1), void 0 !== x.morphAttributes.normal && (L = 2), void 0 !== x.morphAttributes.color && (L = 3), S) { const e = Wf[S]; A = e.vertexShader, D = e.fragmentShader } else A = s.vertexShader, D = s.fragmentShader, l.update(s), C = l.getVertexShaderID(s), R = l.getFragmentShaderID(s); const P = e.getRenderTarget(), I = !0 === _.isInstancedMesh, N = !0 === _.isBatchedMesh, O = !!s.map, F = !!s.matcap, U = !!E, B = !!s.aoMap, k = !!s.lightMap, z = !!s.bumpMap, H = !!s.normalMap, G = !!s.displacementMap, V = !!s.emissiveMap, W = !!s.metalnessMap, j = !!s.roughnessMap, X = s.anisotropy > 0, q = s.clearcoat > 0, Y = s.iridescence > 0, K = s.sheen > 0, $ = s.transmission > 0, Z = X && !!s.anisotropyMap, J = q && !!s.clearcoatMap, Q = q && !!s.clearcoatNormalMap, ee = q && !!s.clearcoatRoughnessMap, te = Y && !!s.iridescenceMap, ne = Y && !!s.iridescenceThicknessMap, ie = K && !!s.sheenColorMap, re = K && !!s.sheenRoughnessMap, se = !!s.specularMap, ae = !!s.specularColorMap, oe = !!s.specularIntensityMap, le = $ && !!s.transmissionMap, ce = $ && !!s.thicknessMap, ue = !!s.gradientMap, he = !!s.alphaMap, de = s.alphaTest > 0, pe = !!s.alphaHash, fe = !!s.extensions; let me = xu; s.toneMapped && (null !== P && !0 !== P.isXRRenderTarget || (me = e.toneMapping)); const ge = { isWebGL2: h, shaderID: S, shaderType: s.type, shaderName: s.name, vertexShader: A, fragmentShader: D, defines: s.defines, customVertexShaderID: C, customFragmentShaderID: R, isRawShaderMaterial: !0 === s.isRawShaderMaterial, glslVersion: s.glslVersion, precision: f, batching: N, instancing: I, instancingColor: I && null !== _.instanceColor, instancingMorph: I && null !== _.morphTexture, supportsVertexTextures: p, outputColorSpace: null === P ? e.outputColorSpace : !0 === P.isXRRenderTarget ? P.texture.colorSpace : dh, alphaToCoverage: !!s.alphaToCoverage, map: O, matcap: F, envMap: U, envMapMode: U && E.mapping, envMapCubeUVHeight: T, aoMap: B, lightMap: k, bumpMap: z, normalMap: H, displacementMap: p && G, emissiveMap: V, normalMapObjectSpace: H && 1 === s.normalMapType, normalMapTangentSpace: H && 0 === s.normalMapType, metalnessMap: W, roughnessMap: j, anisotropy: X, anisotropyMap: Z, clearcoat: q, clearcoatMap: J, clearcoatNormalMap: Q, clearcoatRoughnessMap: ee, iridescence: Y, iridescenceMap: te, iridescenceThicknessMap: ne, sheen: K, sheenColorMap: ie, sheenRoughnessMap: re, specularMap: se, specularColorMap: ae, specularIntensityMap: oe, transmission: $, transmissionMap: le, thicknessMap: ce, gradientMap: ue, opaque: !1 === s.transparent && 1 === s.blending && !1 === s.alphaToCoverage, alphaMap: he, alphaTest: de, alphaHash: pe, combine: s.combine, mapUv: O && g(s.map.channel), aoMapUv: B && g(s.aoMap.channel), lightMapUv: k && g(s.lightMap.channel), bumpMapUv: z && g(s.bumpMap.channel), normalMapUv: H && g(s.normalMap.channel), displacementMapUv: G && g(s.displacementMap.channel), emissiveMapUv: V && g(s.emissiveMap.channel), metalnessMapUv: W && g(s.metalnessMap.channel), roughnessMapUv: j && g(s.roughnessMap.channel), anisotropyMapUv: Z && g(s.anisotropyMap.channel), clearcoatMapUv: J && g(s.clearcoatMap.channel), clearcoatNormalMapUv: Q && g(s.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: ee && g(s.clearcoatRoughnessMap.channel), iridescenceMapUv: te && g(s.iridescenceMap.channel), iridescenceThicknessMapUv: ne && g(s.iridescenceThicknessMap.channel), sheenColorMapUv: ie && g(s.sheenColorMap.channel), sheenRoughnessMapUv: re && g(s.sheenRoughnessMap.channel), specularMapUv: se && g(s.specularMap.channel), specularColorMapUv: ae && g(s.specularColorMap.channel), specularIntensityMapUv: oe && g(s.specularIntensityMap.channel), transmissionMapUv: le && g(s.transmissionMap.channel), thicknessMapUv: ce && g(s.thicknessMap.channel), alphaMapUv: he && g(s.alphaMap.channel), vertexTangents: !!x.attributes.tangent && (H || X), vertexColors: s.vertexColors, vertexAlphas: !0 === s.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize, pointsUvs: !0 === _.isPoints && !!x.attributes.uv && (O || he), fog: !!y, useFog: !0 === s.fog, fogExp2: !!y && y.isFogExp2, flatShading: !0 === s.flatShading, sizeAttenuation: !0 === s.sizeAttenuation, logarithmicDepthBuffer: d, skinning: !0 === _.isSkinnedMesh, morphTargets: void 0 !== x.morphAttributes.position, morphNormals: void 0 !== x.morphAttributes.normal, morphColors: void 0 !== x.morphAttributes.color, morphTargetsCount: w, morphTextureStride: L, numDirLights: o.directional.length, numPointLights: o.point.length, numSpotLights: o.spot.length, numSpotLightMaps: o.spotLightMap.length, numRectAreaLights: o.rectArea.length, numHemiLights: o.hemi.length, numDirLightShadows: o.directionalShadowMap.length, numPointLightShadows: o.pointShadowMap.length, numSpotLightShadows: o.spotShadowMap.length, numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps, numLightProbes: o.numLightProbes, numClippingPlanes: a.numPlanes, numClipIntersection: a.numIntersection, dithering: s.dithering, shadowMapEnabled: e.shadowMap.enabled && u.length > 0, shadowMapType: e.shadowMap.type, toneMapping: me, useLegacyLights: e._useLegacyLights, decodeVideoTexture: O && !0 === s.map.isVideoTexture && Zh.getTransfer(s.map.colorSpace) === gh, premultipliedAlpha: s.premultipliedAlpha, doubleSided: 2 === s.side, flipSided: s.side === mu, useDepthPacking: s.depthPacking >= 0, depthPacking: s.depthPacking || 0, index0AttributeName: s.index0AttributeName, extensionDerivatives: fe && !0 === s.extensions.derivatives, extensionFragDepth: fe && !0 === s.extensions.fragDepth, extensionDrawBuffers: fe && !0 === s.extensions.drawBuffers, extensionShaderTextureLOD: fe && !0 === s.extensions.shaderTextureLOD, extensionClipCullDistance: fe && !0 === s.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"), extensionMultiDraw: fe && !0 === s.extensions.multiDraw && i.has("WEBGL_multi_draw"), rendererExtensionFragDepth: h || i.has("EXT_frag_depth"), rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"), rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"), customProgramCacheKey: s.customProgramCacheKey() }; return ge.vertexUv1s = c.has(1), ge.vertexUv2s = c.has(2), ge.vertexUv3s = c.has(3), c.clear(), ge }, getProgramCacheKey: function (t) { const n = []; if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines) for (const e in t.defines) n.push(e), n.push(t.defines[e]); return !1 === t.isRawShaderMaterial && (!function (e, t) { e.push(t.precision), e.push(t.outputColorSpace), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.mapUv), e.push(t.alphaMapUv), e.push(t.lightMapUv), e.push(t.aoMapUv), e.push(t.bumpMapUv), e.push(t.normalMapUv), e.push(t.displacementMapUv), e.push(t.emissiveMapUv), e.push(t.metalnessMapUv), e.push(t.roughnessMapUv), e.push(t.anisotropyMapUv), e.push(t.clearcoatMapUv), e.push(t.clearcoatNormalMapUv), e.push(t.clearcoatRoughnessMapUv), e.push(t.iridescenceMapUv), e.push(t.iridescenceThicknessMapUv), e.push(t.sheenColorMapUv), e.push(t.sheenRoughnessMapUv), e.push(t.specularMapUv), e.push(t.specularColorMapUv), e.push(t.specularIntensityMapUv), e.push(t.transmissionMapUv), e.push(t.thicknessMapUv), e.push(t.combine), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numSpotLightMaps), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.numSpotLightShadowsWithMaps), e.push(t.numLightProbes), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.depthPacking) }(n, t), function (e, t) { o.disableAll(), t.isWebGL2 && o.enable(0); t.supportsVertexTextures && o.enable(1); t.instancing && o.enable(2); t.instancingColor && o.enable(3); t.instancingMorph && o.enable(4); t.matcap && o.enable(5); t.envMap && o.enable(6); t.normalMapObjectSpace && o.enable(7); t.normalMapTangentSpace && o.enable(8); t.clearcoat && o.enable(9); t.iridescence && o.enable(10); t.alphaTest && o.enable(11); t.vertexColors && o.enable(12); t.vertexAlphas && o.enable(13); t.vertexUv1s && o.enable(14); t.vertexUv2s && o.enable(15); t.vertexUv3s && o.enable(16); t.vertexTangents && o.enable(17); t.anisotropy && o.enable(18); t.alphaHash && o.enable(19); t.batching && o.enable(20); e.push(o.mask), o.disableAll(), t.fog && o.enable(0); t.useFog && o.enable(1); t.flatShading && o.enable(2); t.logarithmicDepthBuffer && o.enable(3); t.skinning && o.enable(4); t.morphTargets && o.enable(5); t.morphNormals && o.enable(6); t.morphColors && o.enable(7); t.premultipliedAlpha && o.enable(8); t.shadowMapEnabled && o.enable(9); t.useLegacyLights && o.enable(10); t.doubleSided && o.enable(11); t.flipSided && o.enable(12); t.useDepthPacking && o.enable(13); t.dithering && o.enable(14); t.transmission && o.enable(15); t.sheen && o.enable(16); t.opaque && o.enable(17); t.pointsUvs && o.enable(18); t.decodeVideoTexture && o.enable(19); t.alphaToCoverage && o.enable(20); e.push(o.mask) }(n, t), n.push(e.outputColorSpace)), n.push(t.customProgramCacheKey), n.join() }, getUniforms: function (e) { const t = m[e.type]; let n; if (t) { const e = Wf[t]; n = bf.clone(e.uniforms) } else n = e.uniforms; return n }, acquireProgram: function (t, n) { let i; for (let e = 0, t = u.length; e < t; e++) { const t = u[e]; if (t.cacheKey === n) { i = t, ++i.usedTimes; break } } return void 0 === i && (i = new Kg(e, n, t, s), u.push(i)), i }, releaseProgram: function (e) { if (0 == --e.usedTimes) { const t = u.indexOf(e); u[t] = u[u.length - 1], u.pop(), e.destroy() } }, releaseShaderCache: function (e) { l.remove(e) }, programs: u, dispose: function () { l.dispose() } } } function ev() { let e = new WeakMap; return { get: function (t) { let n = e.get(t); return void 0 === n && (n = {}, e.set(t, n)), n }, remove: function (t) { e.delete(t) }, update: function (t, n, i) { e.get(t)[n] = i }, dispose: function () { e = new WeakMap } } } function tv(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id } function nv(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id } function iv() { const e = []; let t = 0; const n = [], i = [], r = []; function s(n, i, r, s, a, o) { let l = e[t]; return void 0 === l ? (l = { id: n.id, object: n, geometry: i, material: r, groupOrder: s, renderOrder: n.renderOrder, z: a, group: o }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = a, l.group = o), t++, l } return { opaque: n, transmissive: i, transparent: r, init: function () { t = 0, n.length = 0, i.length = 0, r.length = 0 }, push: function (e, t, a, o, l, c) { const u = s(e, t, a, o, l, c); a.transmission > 0 ? i.push(u) : !0 === a.transparent ? r.push(u) : n.push(u) }, unshift: function (e, t, a, o, l, c) { const u = s(e, t, a, o, l, c); a.transmission > 0 ? i.unshift(u) : !0 === a.transparent ? r.unshift(u) : n.unshift(u) }, finish: function () { for (let n = t, i = e.length; n < i; n++) { const t = e[n]; if (null === t.id) break; t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null } }, sort: function (e, t) { n.length > 1 && n.sort(e || tv), i.length > 1 && i.sort(t || nv), r.length > 1 && r.sort(t || nv) } } } function rv() { let e = new WeakMap; return { get: function (t, n) { const i = e.get(t); let r; return void 0 === i ? (r = new iv, e.set(t, [r])) : n >= i.length ? (r = new iv, i.push(r)) : r = i[n], r }, dispose: function () { e = new WeakMap } } } function sv() { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let n; switch (t.type) { case "DirectionalLight": n = { direction: new pd, color: new Pp }; break; case "SpotLight": n = { position: new pd, direction: new pd, color: new Pp, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new pd, color: new Pp, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new pd, skyColor: new Pp, groundColor: new Pp }; break; case "RectAreaLight": n = { color: new Pp, position: new pd, halfWidth: new pd, halfHeight: new pd } }return e[t.id] = n, n } } } let av = 0; function ov(e, t) { return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0) } function lv(e, t) { const n = new sv, i = function () { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let n; switch (t.type) { case "DirectionalLight": case "SpotLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new kh }; break; case "PointLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new kh, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return e[t.id] = n, n } } }(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 }; for (let e = 0; e < 9; e++)r.probe.push(new pd); const s = new pd, a = new Vd, o = new Vd; return { setup: function (s, a) { let o = 0, l = 0, c = 0; for (let e = 0; e < 9; e++)r.probe[e].set(0, 0, 0); let u = 0, h = 0, d = 0, p = 0, f = 0, m = 0, g = 0, v = 0, _ = 0, y = 0, x = 0; s.sort(ov); const b = !0 === a ? Math.PI : 1; for (let e = 0, t = s.length; e < t; e++) { const t = s[e], a = t.color, E = t.intensity, T = t.distance, S = t.shadow && t.shadow.map ? t.shadow.map.texture : null; if (t.isAmbientLight) o += a.r * E * b, l += a.g * E * b, c += a.b * E * b; else if (t.isLightProbe) { for (let e = 0; e < 9; e++)r.probe[e].addScaledVector(t.sh.coefficients[e], E); x++ } else if (t.isDirectionalLight) { const e = n.get(t); if (e.color.copy(t.color).multiplyScalar(t.intensity * b), t.castShadow) { const e = t.shadow, n = i.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.directionalShadow[u] = n, r.directionalShadowMap[u] = S, r.directionalShadowMatrix[u] = t.shadow.matrix, m++ } r.directional[u] = e, u++ } else if (t.isSpotLight) { const e = n.get(t); e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(a).multiplyScalar(E * b), e.distance = T, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, r.spot[d] = e; const s = t.shadow; if (t.map && (r.spotLightMap[_] = t.map, _++, s.updateMatrices(t), t.castShadow && y++), r.spotLightMatrix[d] = s.matrix, t.castShadow) { const e = i.get(t); e.shadowBias = s.bias, e.shadowNormalBias = s.normalBias, e.shadowRadius = s.radius, e.shadowMapSize = s.mapSize, r.spotShadow[d] = e, r.spotShadowMap[d] = S, v++ } d++ } else if (t.isRectAreaLight) { const e = n.get(t); e.color.copy(a).multiplyScalar(E), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), r.rectArea[p] = e, p++ } else if (t.isPointLight) { const e = n.get(t); if (e.color.copy(t.color).multiplyScalar(t.intensity * b), e.distance = t.distance, e.decay = t.decay, t.castShadow) { const e = t.shadow, n = i.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, r.pointShadow[h] = n, r.pointShadowMap[h] = S, r.pointShadowMatrix[h] = t.shadow.matrix, g++ } r.point[h] = e, h++ } else if (t.isHemisphereLight) { const e = n.get(t); e.skyColor.copy(t.color).multiplyScalar(E * b), e.groundColor.copy(t.groundColor).multiplyScalar(E * b), r.hemi[f] = e, f++ } } p > 0 && (t.isWebGL2 ? !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Vf.LTC_FLOAT_1, r.rectAreaLTC2 = Vf.LTC_FLOAT_2) : (r.rectAreaLTC1 = Vf.LTC_HALF_1, r.rectAreaLTC2 = Vf.LTC_HALF_2) : !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Vf.LTC_FLOAT_1, r.rectAreaLTC2 = Vf.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Vf.LTC_HALF_1, r.rectAreaLTC2 = Vf.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c; const E = r.hash; E.directionalLength === u && E.pointLength === h && E.spotLength === d && E.rectAreaLength === p && E.hemiLength === f && E.numDirectionalShadows === m && E.numPointShadows === g && E.numSpotShadows === v && E.numSpotMaps === _ && E.numLightProbes === x || (r.directional.length = u, r.spot.length = d, r.rectArea.length = p, r.point.length = h, r.hemi.length = f, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotLightMatrix.length = v + _ - y, r.spotLightMap.length = _, r.numSpotLightShadowsWithMaps = y, r.numLightProbes = x, E.directionalLength = u, E.pointLength = h, E.spotLength = d, E.rectAreaLength = p, E.hemiLength = f, E.numDirectionalShadows = m, E.numPointShadows = g, E.numSpotShadows = v, E.numSpotMaps = _, E.numLightProbes = x, r.version = av++) }, setupView: function (e, t) { let n = 0, i = 0, l = 0, c = 0, u = 0; const h = t.matrixWorldInverse; for (let t = 0, d = e.length; t < d; t++) { const d = e[t]; if (d.isDirectionalLight) { const e = r.directional[n]; e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(h), n++ } else if (d.isSpotLight) { const e = r.spot[l]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(h), l++ } else if (d.isRectAreaLight) { const e = r.rectArea[c]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), o.identity(), a.copy(d.matrixWorld), a.premultiply(h), o.extractRotation(a), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), c++ } else if (d.isPointLight) { const e = r.point[i]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), i++ } else if (d.isHemisphereLight) { const e = r.hemi[u]; e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(h), u++ } } }, state: r } } function cv(e, t) { const n = new lv(e, t), i = [], r = []; return { init: function () { i.length = 0, r.length = 0 }, state: { lightsArray: i, shadowsArray: r, lights: n }, setupLights: function (e) { n.setup(i, e) }, setupLightsView: function (e) { n.setupView(i, e) }, pushLight: function (e) { i.push(e) }, pushShadow: function (e) { r.push(e) } } } function uv(e, t) { let n = new WeakMap; return { get: function (i, r = 0) { const s = n.get(i); let a; return void 0 === s ? (a = new cv(e, t), n.set(i, [a])) : r >= s.length ? (a = new cv(e, t), s.push(a)) : a = s[r], a }, dispose: function () { n = new WeakMap } } } class hv extends Op { constructor(e) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } class dv extends Op { constructor(e) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e) } copy(e) { return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } function pv(e, t, n) { let i = new Bf; const r = new kh, s = new kh, a = new od, o = new hv({ depthPacking: 3201 }), l = new dv, c = {}, u = n.maxTextureSize, h = { [fu]: mu, [mu]: fu, 2: 2 }, d = new Ef({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new kh }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), p = d.clone(); p.defines.HORIZONTAL_PASS = 1; const f = new $p; f.setAttribute("position", new kp(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const m = new mf(f, d), g = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = hu; let v = this.type; function _(n, i) { const s = t.update(m); d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), null === n.mapPass && (n.mapPass = new cd(r.x, r.y)), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, s, d, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, s, p, m, null) } function y(t, n, i, r) { let s = null; const a = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial; if (void 0 !== a) s = a; else if (s = !0 === i.isPointLight ? l : o, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) { const e = s.uuid, t = n.uuid; let i = c[e]; void 0 === i && (i = {}, c[e] = i); let r = i[t]; void 0 === r && (r = s.clone(), i[t] = r, n.addEventListener("dispose", b)), s = r } if (s.visible = n.visible, s.wireframe = n.wireframe, s.side = r === pu ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : h[n.side], s.alphaMap = n.alphaMap, s.alphaTest = n.alphaTest, s.map = n.map, s.clipShadows = n.clipShadows, s.clippingPlanes = n.clippingPlanes, s.clipIntersection = n.clipIntersection, s.displacementMap = n.displacementMap, s.displacementScale = n.displacementScale, s.displacementBias = n.displacementBias, s.wireframeLinewidth = n.wireframeLinewidth, s.linewidth = n.linewidth, !0 === i.isPointLight && !0 === s.isMeshDistanceMaterial) { e.properties.get(s).light = i } return s } function x(n, r, s, a, o) { if (!1 === n.visible) return; if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && o === pu) && (!n.frustumCulled || i.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld); const i = t.update(n), l = n.material; if (Array.isArray(l)) { const t = i.groups; for (let c = 0, u = t.length; c < u; c++) { const u = t[c], h = l[u.materialIndex]; if (h && h.visible) { const t = y(n, h, a, o); n.onBeforeShadow(e, n, r, s, i, t, u), e.renderBufferDirect(s, null, i, t, n, u), n.onAfterShadow(e, n, r, s, i, t, u) } } } else if (l.visible) { const t = y(n, l, a, o); n.onBeforeShadow(e, n, r, s, i, t, null), e.renderBufferDirect(s, null, i, t, n, null), n.onAfterShadow(e, n, r, s, i, t, null) } } const l = n.children; for (let e = 0, t = l.length; e < t; e++)x(l[e], r, s, a, o) } function b(e) { e.target.removeEventListener("dispose", b); for (const t in c) { const n = c[t], i = e.target.uuid; if (i in n) { n[i].dispose(), delete n[i] } } } this.render = function (t, n, o) { if (!1 === g.enabled) return; if (!1 === g.autoUpdate && !1 === g.needsUpdate) return; if (0 === t.length) return; const l = e.getRenderTarget(), c = e.getActiveCubeFace(), h = e.getActiveMipmapLevel(), d = e.state; d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1); const p = v !== pu && this.type === pu, f = v === pu && this.type !== pu; for (let l = 0, c = t.length; l < c; l++) { const c = t[l], h = c.shadow; if (void 0 === h) { console.warn("THREE.WebGLShadowMap:", c, "has no shadow."); continue } if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue; r.copy(h.mapSize); const m = h.getFrameExtents(); if (r.multiply(m), s.copy(h.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / m.x), r.x = s.x * m.x, h.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / m.y), r.y = s.y * m.y, h.mapSize.y = s.y)), null === h.map || !0 === p || !0 === f) { const e = this.type !== pu ? { minFilter: Uu, magFilter: Uu } : {}; null !== h.map && h.map.dispose(), h.map = new cd(r.x, r.y, e), h.map.texture.name = c.name + ".shadowMap", h.camera.updateProjectionMatrix() } e.setRenderTarget(h.map), e.clear(); const g = h.getViewportCount(); for (let e = 0; e < g; e++) { const t = h.getViewport(e); a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), d.viewport(a), h.updateMatrices(c, e), i = h.getFrustum(), x(n, o, h.camera, c, this.type) } !0 !== h.isPointLightShadow && this.type === pu && _(h, o), h.needsUpdate = !1 } v = this.type, g.needsUpdate = !1, e.setRenderTarget(l, c, h) } } function fv(e, t, n) { const i = n.isWebGL2; const r = new function () { let t = !1; const n = new od; let i = null; const r = new od(0, 0, 0, 0); return { setMask: function (n) { i === n || t || (e.colorMask(n, n, n, n), i = n) }, setLocked: function (e) { t = e }, setClear: function (t, i, s, a, o) { !0 === o && (t *= a, i *= a, s *= a), n.set(t, i, s, a), !1 === r.equals(n) && (e.clearColor(t, i, s, a), r.copy(n)) }, reset: function () { t = !1, i = null, r.set(-1, 0, 0, 0) } } }, s = new function () { let t = !1, n = null, i = null, r = null; return { setTest: function (t) { t ? G(e.DEPTH_TEST) : V(e.DEPTH_TEST) }, setMask: function (i) { n === i || t || (e.depthMask(i), n = i) }, setFunc: function (t) { if (i !== t) { switch (t) { case 0: e.depthFunc(e.NEVER); break; case 1: e.depthFunc(e.ALWAYS); break; case 2: e.depthFunc(e.LESS); break; case 3: default: e.depthFunc(e.LEQUAL); break; case 4: e.depthFunc(e.EQUAL); break; case 5: e.depthFunc(e.GEQUAL); break; case 6: e.depthFunc(e.GREATER); break; case 7: e.depthFunc(e.NOTEQUAL) }i = t } }, setLocked: function (e) { t = e }, setClear: function (t) { r !== t && (e.clearDepth(t), r = t) }, reset: function () { t = !1, n = null, i = null, r = null } } }, a = new function () { let t = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null; return { setTest: function (n) { t || (n ? G(e.STENCIL_TEST) : V(e.STENCIL_TEST)) }, setMask: function (i) { n === i || t || (e.stencilMask(i), n = i) }, setFunc: function (t, n, a) { i === t && r === n && s === a || (e.stencilFunc(t, n, a), i = t, r = n, s = a) }, setOp: function (t, n, i) { a === t && o === n && l === i || (e.stencilOp(t, n, i), a = t, o = n, l = i) }, setLocked: function (e) { t = e }, setClear: function (t) { c !== t && (e.clearStencil(t), c = t) }, reset: function () { t = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null } } }, o = new WeakMap, l = new WeakMap; let c = {}, u = {}, h = new WeakMap, d = [], p = null, f = !1, m = null, g = null, v = null, _ = null, y = null, x = null, b = null, E = new Pp(0, 0, 0), T = 0, S = !1, M = null, w = null, A = null, D = null, C = null; const R = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS); let L = !1, P = 0; const I = e.getParameter(e.VERSION); -1 !== I.indexOf("WebGL") ? (P = parseFloat(/^WebGL (\d)/.exec(I)[1]), L = P >= 1) : -1 !== I.indexOf("OpenGL ES") && (P = parseFloat(/^OpenGL ES (\d)/.exec(I)[1]), L = P >= 2); let N = null, O = {}; const F = e.getParameter(e.SCISSOR_BOX), U = e.getParameter(e.VIEWPORT), B = (new od).fromArray(F), k = (new od).fromArray(U); function z(t, n, r, s) { const a = new Uint8Array(4), o = e.createTexture(); e.bindTexture(t, o), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST); for (let o = 0; o < r; o++)!i || t !== e.TEXTURE_3D && t !== e.TEXTURE_2D_ARRAY ? e.texImage2D(n + o, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, a) : e.texImage3D(n, 0, e.RGBA, 1, 1, s, 0, e.RGBA, e.UNSIGNED_BYTE, a); return o } const H = {}; function G(t) { !0 !== c[t] && (e.enable(t), c[t] = !0) } function V(t) { !1 !== c[t] && (e.disable(t), c[t] = !1) } H[e.TEXTURE_2D] = z(e.TEXTURE_2D, e.TEXTURE_2D, 1), H[e.TEXTURE_CUBE_MAP] = z(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i && (H[e.TEXTURE_2D_ARRAY] = z(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1), H[e.TEXTURE_3D] = z(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1)), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), G(e.DEPTH_TEST), s.setFunc(3), q(!1), Y(1), G(e.CULL_FACE), X(0); const W = { [gu]: e.FUNC_ADD, 101: e.FUNC_SUBTRACT, 102: e.FUNC_REVERSE_SUBTRACT }; if (i) W[103] = e.MIN, W[104] = e.MAX; else { const e = t.get("EXT_blend_minmax"); null !== e && (W[103] = e.MIN_EXT, W[104] = e.MAX_EXT) } const j = { 200: e.ZERO, 201: e.ONE, 202: e.SRC_COLOR, 204: e.SRC_ALPHA, 210: e.SRC_ALPHA_SATURATE, 208: e.DST_COLOR, 206: e.DST_ALPHA, 203: e.ONE_MINUS_SRC_COLOR, 205: e.ONE_MINUS_SRC_ALPHA, 209: e.ONE_MINUS_DST_COLOR, 207: e.ONE_MINUS_DST_ALPHA, 211: e.CONSTANT_COLOR, 212: e.ONE_MINUS_CONSTANT_COLOR, 213: e.CONSTANT_ALPHA, 214: e.ONE_MINUS_CONSTANT_ALPHA }; function X(t, n, i, r, s, a, o, l, c, u) { if (0 !== t) { if (!1 === f && (G(e.BLEND), f = !0), 5 === t) s = s || n, a = a || i, o = o || r, n === g && s === y || (e.blendEquationSeparate(W[n], W[s]), g = n, y = s), i === v && r === _ && a === x && o === b || (e.blendFuncSeparate(j[i], j[r], j[a], j[o]), v = i, _ = r, x = a, b = o), !1 !== l.equals(E) && c === T || (e.blendColor(l.r, l.g, l.b, c), E.copy(l), T = c), m = t, S = !1; else if (t !== m || u !== S) { if (g === gu && y === gu || (e.blendEquation(e.FUNC_ADD), g = gu, y = gu), u) switch (t) { case 1: e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA); break; case 2: e.blendFunc(e.ONE, e.ONE); break; case 3: e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE); break; case 4: e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) } else switch (t) { case 1: e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA); break; case 2: e.blendFunc(e.SRC_ALPHA, e.ONE); break; case 3: e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE); break; case 4: e.blendFunc(e.ZERO, e.SRC_COLOR); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) }v = null, _ = null, x = null, b = null, E.set(0, 0, 0), T = 0, m = t, S = u } } else !0 === f && (V(e.BLEND), f = !1) } function q(t) { M !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), M = t) } function Y(t) { 0 !== t ? (G(e.CULL_FACE), t !== w && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : V(e.CULL_FACE), w = t } function K(t, n, i) { t ? (G(e.POLYGON_OFFSET_FILL), D === n && C === i || (e.polygonOffset(n, i), D = n, C = i)) : V(e.POLYGON_OFFSET_FILL) } return { buffers: { color: r, depth: s, stencil: a }, enable: G, disable: V, bindFramebuffer: function (t, n) { return u[t] !== n && (e.bindFramebuffer(t, n), u[t] = n, i && (t === e.DRAW_FRAMEBUFFER && (u[e.FRAMEBUFFER] = n), t === e.FRAMEBUFFER && (u[e.DRAW_FRAMEBUFFER] = n)), !0) }, drawBuffers: function (i, r) { let s = d, a = !1; if (i) { s = h.get(r), void 0 === s && (s = [], h.set(r, s)); const t = i.textures; if (s.length !== t.length || s[0] !== e.COLOR_ATTACHMENT0) { for (let n = 0, i = t.length; n < i; n++)s[n] = e.COLOR_ATTACHMENT0 + n; s.length = t.length, a = !0 } } else s[0] !== e.BACK && (s[0] = e.BACK, a = !0); if (a) if (n.isWebGL2) e.drawBuffers(s); else { if (!0 !== t.has("WEBGL_draw_buffers")) throw new Error("THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension"); t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s) } }, useProgram: function (t) { return p !== t && (e.useProgram(t), p = t, !0) }, setBlending: X, setMaterial: function (t, n) { 2 === t.side ? V(e.CULL_FACE) : G(e.CULL_FACE); let i = t.side === mu; n && (i = !i), q(i), 1 === t.blending && !1 === t.transparent ? X(0) : X(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite); const o = t.stencilWrite; a.setTest(o), o && (a.setMask(t.stencilWriteMask), a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), K(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? G(e.SAMPLE_ALPHA_TO_COVERAGE) : V(e.SAMPLE_ALPHA_TO_COVERAGE) }, setFlipSided: q, setCullFace: Y, setLineWidth: function (t) { t !== A && (L && e.lineWidth(t), A = t) }, setPolygonOffset: K, setScissorTest: function (t) { t ? G(e.SCISSOR_TEST) : V(e.SCISSOR_TEST) }, activeTexture: function (t) { void 0 === t && (t = e.TEXTURE0 + R - 1), N !== t && (e.activeTexture(t), N = t) }, bindTexture: function (t, n, i) { void 0 === i && (i = null === N ? e.TEXTURE0 + R - 1 : N); let r = O[i]; void 0 === r && (r = { type: void 0, texture: void 0 }, O[i] = r), r.type === t && r.texture === n || (N !== i && (e.activeTexture(i), N = i), e.bindTexture(t, n || H[t]), r.type = t, r.texture = n) }, unbindTexture: function () { const t = O[N]; void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0) }, compressedTexImage2D: function () { try { e.compressedTexImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, compressedTexImage3D: function () { try { e.compressedTexImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { e.texImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { e.texImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, updateUBOMapping: function (t, n) { let i = l.get(n); void 0 === i && (i = new WeakMap, l.set(n, i)); let r = i.get(t); void 0 === r && (r = e.getUniformBlockIndex(n, t.name), i.set(t, r)) }, uniformBlockBinding: function (t, n) { const i = l.get(n).get(t); o.get(n) !== i && (e.uniformBlockBinding(n, i, t.__bindingPointIndex), o.set(n, i)) }, texStorage2D: function () { try { e.texStorage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texStorage3D: function () { try { e.texStorage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texSubImage2D: function () { try { e.texSubImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texSubImage3D: function () { try { e.texSubImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, compressedTexSubImage2D: function () { try { e.compressedTexSubImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, compressedTexSubImage3D: function () { try { e.compressedTexSubImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (t) { !1 === B.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), B.copy(t)) }, viewport: function (t) { !1 === k.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), k.copy(t)) }, reset: function () { e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.blendColor(0, 0, 0, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(e.LESS), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(e.ALWAYS, 0, 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), !0 === i && (e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), c = {}, N = null, O = {}, u = {}, h = new WeakMap, d = [], p = null, f = !1, m = null, g = null, v = null, _ = null, y = null, x = null, b = null, E = new Pp(0, 0, 0), T = 0, S = !1, M = null, w = null, A = null, D = null, C = null, B.set(0, 0, e.canvas.width, e.canvas.height), k.set(0, 0, e.canvas.width, e.canvas.height), r.reset(), s.reset(), a.reset() } } } function mv(e, t, n, i, r, s, a) { const o = r.isWebGL2, l = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, c = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent), u = new kh, h = new WeakMap; let d; const p = new WeakMap; let f = !1; try { f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (e) { } function m(e, t) { return f ? new OffscreenCanvas(e, t) : Vh("canvas") } function g(e, t, n, i) { let r = 1; const s = z(e); if ((s.width > i || s.height > i) && (r = i / Math.max(s.width, s.height)), r < 1 || !0 === t) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) { const i = t ? Oh : Math.floor, a = i(r * s.width), o = i(r * s.height); void 0 === d && (d = m(a, o)); const l = n ? m(a, o) : d; l.width = a, l.height = o; return l.getContext("2d").drawImage(e, 0, 0, a, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + s.width + "x" + s.height + ") to (" + a + "x" + o + ")."), l } return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + s.width + "x" + s.height + ")."), e } return e } function v(e) { const t = z(e); return Nh(t.width) && Nh(t.height) } function _(e, t) { return e.generateMipmaps && t && e.minFilter !== Uu && e.minFilter !== zu } function y(t) { e.generateMipmap(t) } function x(n, i, r, s, a = !1) { if (!1 === o) return i; if (null !== n) { if (void 0 !== e[n]) return e[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } let l = i; if (i === e.RED && (r === e.FLOAT && (l = e.R32F), r === e.HALF_FLOAT && (l = e.R16F), r === e.UNSIGNED_BYTE && (l = e.R8)), i === e.RED_INTEGER && (r === e.UNSIGNED_BYTE && (l = e.R8UI), r === e.UNSIGNED_SHORT && (l = e.R16UI), r === e.UNSIGNED_INT && (l = e.R32UI), r === e.BYTE && (l = e.R8I), r === e.SHORT && (l = e.R16I), r === e.INT && (l = e.R32I)), i === e.RG && (r === e.FLOAT && (l = e.RG32F), r === e.HALF_FLOAT && (l = e.RG16F), r === e.UNSIGNED_BYTE && (l = e.RG8)), i === e.RG_INTEGER && (r === e.UNSIGNED_BYTE && (l = e.RG8UI), r === e.UNSIGNED_SHORT && (l = e.RG16UI), r === e.UNSIGNED_INT && (l = e.RG32UI), r === e.BYTE && (l = e.RG8I), r === e.SHORT && (l = e.RG16I), r === e.INT && (l = e.RG32I)), i === e.RGBA) { const t = a ? mh : Zh.getTransfer(s); r === e.FLOAT && (l = e.RGBA32F), r === e.HALF_FLOAT && (l = e.RGBA16F), r === e.UNSIGNED_BYTE && (l = t === gh ? e.SRGB8_ALPHA8 : e.RGBA8), r === e.UNSIGNED_SHORT_4_4_4_4 && (l = e.RGBA4), r === e.UNSIGNED_SHORT_5_5_5_1 && (l = e.RGB5_A1) } return l !== e.R16F && l !== e.R32F && l !== e.RG16F && l !== e.RG32F && l !== e.RGBA16F && l !== e.RGBA32F || t.get("EXT_color_buffer_float"), l } function b(e, t, n) { return !0 === _(e, n) || e.isFramebufferTexture && e.minFilter !== Uu && e.minFilter !== zu ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1 } function E(t) { return t === Uu || t === Bu || t === ku ? e.NEAREST : e.LINEAR } function T(e) { const t = e.target; t.removeEventListener("dispose", T), function (e) { const t = i.get(e); if (void 0 === t.__webglInit) return; const n = e.source, r = p.get(n); if (r) { const i = r[t.__cacheKey]; i.usedTimes--, 0 === i.usedTimes && M(e), 0 === Object.keys(r).length && p.delete(n) } i.remove(e) }(t), t.isVideoTexture && h.delete(t) } function S(t) { const n = t.target; n.removeEventListener("dispose", S), function (t) { const n = i.get(t); t.depthTexture && t.depthTexture.dispose(); if (t.isWebGLCubeRenderTarget) for (let t = 0; t < 6; t++) { if (Array.isArray(n.__webglFramebuffer[t])) for (let i = 0; i < n.__webglFramebuffer[t].length; i++)e.deleteFramebuffer(n.__webglFramebuffer[t][i]); else e.deleteFramebuffer(n.__webglFramebuffer[t]); n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t]) } else { if (Array.isArray(n.__webglFramebuffer)) for (let t = 0; t < n.__webglFramebuffer.length; t++)e.deleteFramebuffer(n.__webglFramebuffer[t]); else e.deleteFramebuffer(n.__webglFramebuffer); if (n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer) for (let t = 0; t < n.__webglColorRenderbuffer.length; t++)n.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]); n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer) } const r = t.textures; for (let t = 0, n = r.length; t < n; t++) { const n = i.get(r[t]); n.__webglTexture && (e.deleteTexture(n.__webglTexture), a.memory.textures--), i.remove(r[t]) } i.remove(t) }(n) } function M(t) { const n = i.get(t); e.deleteTexture(n.__webglTexture); const r = t.source; delete p.get(r)[n.__cacheKey], a.memory.textures-- } let w = 0; function A(t, r) { const s = i.get(t); if (t.isVideoTexture && function (e) { const t = a.render.frame; h.get(e) !== t && (h.set(e, t), e.update()) }(t), !1 === t.isRenderTargetTexture && t.version > 0 && s.__version !== t.version) { const e = t.image; if (null === e) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else { if (!1 !== e.complete) return void I(s, t, r); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.bindTexture(e.TEXTURE_2D, s.__webglTexture, e.TEXTURE0 + r) } const D = { [Nu]: e.REPEAT, [Ou]: e.CLAMP_TO_EDGE, [Fu]: e.MIRRORED_REPEAT }, C = { [Uu]: e.NEAREST, [Bu]: e.NEAREST_MIPMAP_NEAREST, [ku]: e.NEAREST_MIPMAP_LINEAR, [zu]: e.LINEAR, [Hu]: e.LINEAR_MIPMAP_NEAREST, [Gu]: e.LINEAR_MIPMAP_LINEAR }, R = { 512: e.NEVER, 519: e.ALWAYS, 513: e.LESS, 515: e.LEQUAL, 514: e.EQUAL, 518: e.GEQUAL, 516: e.GREATER, 517: e.NOTEQUAL }; function L(n, s, a) { if (s.type !== qu || !1 !== t.has("OES_texture_float_linear") || s.magFilter !== zu && s.magFilter !== Hu && s.magFilter !== ku && s.magFilter !== Gu && s.minFilter !== zu && s.minFilter !== Hu && s.minFilter !== ku && s.minFilter !== Gu || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), a ? (e.texParameteri(n, e.TEXTURE_WRAP_S, D[s.wrapS]), e.texParameteri(n, e.TEXTURE_WRAP_T, D[s.wrapT]), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, D[s.wrapR]), e.texParameteri(n, e.TEXTURE_MAG_FILTER, C[s.magFilter]), e.texParameteri(n, e.TEXTURE_MIN_FILTER, C[s.minFilter])) : (e.texParameteri(n, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(n, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, e.CLAMP_TO_EDGE), s.wrapS === Ou && s.wrapT === Ou || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, e.TEXTURE_MAG_FILTER, E(s.magFilter)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, E(s.minFilter)), s.minFilter !== Uu && s.minFilter !== zu && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), s.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE), e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, R[s.compareFunction])), !0 === t.has("EXT_texture_filter_anisotropic")) { if (s.magFilter === Uu) return; if (s.minFilter !== ku && s.minFilter !== Gu) return; if (s.type === qu && !1 === t.has("OES_texture_float_linear")) return; if (!1 === o && s.type === Yu && !1 === t.has("OES_texture_half_float_linear")) return; if (s.anisotropy > 1 || i.get(s).__currentAnisotropy) { const a = t.get("EXT_texture_filter_anisotropic"); e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy } } } function P(t, n) { let i = !1; void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", T)); const r = n.source; let s = p.get(r); void 0 === s && (s = {}, p.set(r, s)); const o = function (e) { const t = []; return t.push(e.wrapS), t.push(e.wrapT), t.push(e.wrapR || 0), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.colorSpace), t.join() }(n); if (o !== t.__cacheKey) { void 0 === s[o] && (s[o] = { texture: e.createTexture(), usedTimes: 0 }, a.memory.textures++, i = !0), s[o].usedTimes++; const r = s[t.__cacheKey]; void 0 !== r && (s[t.__cacheKey].usedTimes--, 0 === r.usedTimes && M(n)), t.__cacheKey = o, t.__webglTexture = s[o].texture } return i } function I(t, a, l) { let c = e.TEXTURE_2D; (a.isDataArrayTexture || a.isCompressedArrayTexture) && (c = e.TEXTURE_2D_ARRAY), a.isData3DTexture && (c = e.TEXTURE_3D); const u = P(t, a), h = a.source; n.bindTexture(c, t.__webglTexture, e.TEXTURE0 + l); const d = i.get(h); if (h.version !== d.__version || !0 === u) { n.activeTexture(e.TEXTURE0 + l); const t = Zh.getPrimaries(Zh.workingColorSpace), i = a.colorSpace === uh ? null : Zh.getPrimaries(a.colorSpace), p = a.colorSpace === uh || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL; e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, p); const f = function (e) { return !o && (e.wrapS !== Ou || e.wrapT !== Ou || e.minFilter !== Uu && e.minFilter !== zu) }(a) && !1 === v(a.image); let m = g(a.image, f, !1, r.maxTextureSize); m = k(a, m); const E = v(m) || o, T = s.convert(a.format, a.colorSpace); let S, M = s.convert(a.type), w = x(a.internalFormat, T, M, a.colorSpace, a.isVideoTexture); L(c, a, E); const A = a.mipmaps, D = o && !0 !== a.isVideoTexture && 36196 !== w, C = void 0 === d.__version || !0 === u, R = h.dataReady, P = b(a, m, E); if (a.isDepthTexture) w = e.DEPTH_COMPONENT, o ? w = a.type === qu ? e.DEPTH_COMPONENT32F : a.type === Xu ? e.DEPTH_COMPONENT24 : a.type === Ku ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT16 : a.type === qu && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), a.format === Zu && w === e.DEPTH_COMPONENT && a.type !== Wu && a.type !== Xu && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), a.type = Xu, M = s.convert(a.type)), a.format === Ju && w === e.DEPTH_COMPONENT && (w = e.DEPTH_STENCIL, a.type !== Ku && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), a.type = Ku, M = s.convert(a.type))), C && (D ? n.texStorage2D(e.TEXTURE_2D, 1, w, m.width, m.height) : n.texImage2D(e.TEXTURE_2D, 0, w, m.width, m.height, 0, T, M, null)); else if (a.isDataTexture) if (A.length > 0 && E) { D && C && n.texStorage2D(e.TEXTURE_2D, P, w, A[0].width, A[0].height); for (let t = 0, i = A.length; t < i; t++)S = A[t], D ? R && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, T, M, S.data) : n.texImage2D(e.TEXTURE_2D, t, w, S.width, S.height, 0, T, M, S.data); a.generateMipmaps = !1 } else D ? (C && n.texStorage2D(e.TEXTURE_2D, P, w, m.width, m.height), R && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, m.width, m.height, T, M, m.data)) : n.texImage2D(e.TEXTURE_2D, 0, w, m.width, m.height, 0, T, M, m.data); else if (a.isCompressedTexture) if (a.isCompressedArrayTexture) { D && C && n.texStorage3D(e.TEXTURE_2D_ARRAY, P, w, A[0].width, A[0].height, m.depth); for (let t = 0, i = A.length; t < i; t++)S = A[t], a.format !== $u ? null !== T ? D ? R && n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, S.width, S.height, m.depth, T, S.data, 0, 0) : n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, w, S.width, S.height, m.depth, 0, S.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : D ? R && n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, S.width, S.height, m.depth, T, M, S.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, w, S.width, S.height, m.depth, 0, T, M, S.data) } else { D && C && n.texStorage2D(e.TEXTURE_2D, P, w, A[0].width, A[0].height); for (let t = 0, i = A.length; t < i; t++)S = A[t], a.format !== $u ? null !== T ? D ? R && n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, T, S.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, w, S.width, S.height, 0, S.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : D ? R && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, T, M, S.data) : n.texImage2D(e.TEXTURE_2D, t, w, S.width, S.height, 0, T, M, S.data) } else if (a.isDataArrayTexture) D ? (C && n.texStorage3D(e.TEXTURE_2D_ARRAY, P, w, m.width, m.height, m.depth), R && n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, m.width, m.height, m.depth, T, M, m.data)) : n.texImage3D(e.TEXTURE_2D_ARRAY, 0, w, m.width, m.height, m.depth, 0, T, M, m.data); else if (a.isData3DTexture) D ? (C && n.texStorage3D(e.TEXTURE_3D, P, w, m.width, m.height, m.depth), R && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, m.width, m.height, m.depth, T, M, m.data)) : n.texImage3D(e.TEXTURE_3D, 0, w, m.width, m.height, m.depth, 0, T, M, m.data); else if (a.isFramebufferTexture) { if (C) if (D) n.texStorage2D(e.TEXTURE_2D, P, w, m.width, m.height); else { let t = m.width, i = m.height; for (let r = 0; r < P; r++)n.texImage2D(e.TEXTURE_2D, r, w, t, i, 0, T, M, null), t >>= 1, i >>= 1 } } else if (A.length > 0 && E) { if (D && C) { const t = z(A[0]); n.texStorage2D(e.TEXTURE_2D, P, w, t.width, t.height) } for (let t = 0, i = A.length; t < i; t++)S = A[t], D ? R && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, T, M, S) : n.texImage2D(e.TEXTURE_2D, t, w, T, M, S); a.generateMipmaps = !1 } else if (D) { if (C) { const t = z(m); n.texStorage2D(e.TEXTURE_2D, P, w, t.width, t.height) } R && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, T, M, m) } else n.texImage2D(e.TEXTURE_2D, 0, w, T, M, m); _(a, E) && y(c), d.__version = h.version, a.onUpdate && a.onUpdate(a) } t.__version = a.version } function N(t, r, a, o, c, u) { const h = s.convert(a.format, a.colorSpace), d = s.convert(a.type), p = x(a.internalFormat, h, d, a.colorSpace); if (!i.get(r).__hasExternalTextures) { const t = Math.max(1, r.width >> u), i = Math.max(1, r.height >> u); c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, u, p, t, i, r.depth, 0, h, d, null) : n.texImage2D(c, u, p, t, i, 0, h, d, null) } n.bindFramebuffer(e.FRAMEBUFFER, t), B(r) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, o, c, i.get(a).__webglTexture, 0, U(r)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, o, c, i.get(a).__webglTexture, u), n.bindFramebuffer(e.FRAMEBUFFER, null) } function O(t, n, i) { if (e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer && !n.stencilBuffer) { let r = !0 === o ? e.DEPTH_COMPONENT24 : e.DEPTH_COMPONENT16; if (i || B(n)) { const t = n.depthTexture; t && t.isDepthTexture && (t.type === qu ? r = e.DEPTH_COMPONENT32F : t.type === Xu && (r = e.DEPTH_COMPONENT24)); const i = U(n); B(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, i, r, n.width, n.height) : e.renderbufferStorageMultisample(e.RENDERBUFFER, i, r, n.width, n.height) } else e.renderbufferStorage(e.RENDERBUFFER, r, n.width, n.height); e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t) } else if (n.depthBuffer && n.stencilBuffer) { const r = U(n); i && !1 === B(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r, e.DEPTH24_STENCIL8, n.width, n.height) : B(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, r, e.DEPTH24_STENCIL8, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t) } else { const t = n.textures; for (let r = 0; r < t.length; r++) { const a = t[r], o = s.convert(a.format, a.colorSpace), c = s.convert(a.type), u = x(a.internalFormat, o, c, a.colorSpace), h = U(n); i && !1 === B(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, h, u, n.width, n.height) : B(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, h, u, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, u, n.width, n.height) } } e.bindRenderbuffer(e.RENDERBUFFER, null) } function F(t) { const r = i.get(t), s = !0 === t.isWebGLCubeRenderTarget; if (t.depthTexture && !r.__autoAllocateDepthBuffer) { if (s) throw new Error("target.depthTexture not supported in Cube render targets"); !function (t, r) { if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (n.bindFramebuffer(e.FRAMEBUFFER, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), A(r.depthTexture, 0); const s = i.get(r.depthTexture).__webglTexture, a = U(r); if (r.depthTexture.format === Zu) B(r) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0, a) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0); else { if (r.depthTexture.format !== Ju) throw new Error("Unknown depthTexture format"); B(r) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0, a) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0) } }(r.__webglFramebuffer, t) } else if (s) { r.__webglDepthbuffer = []; for (let i = 0; i < 6; i++)n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = e.createRenderbuffer(), O(r.__webglDepthbuffer[i], t, !1) } else n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), O(r.__webglDepthbuffer, t, !1); n.bindFramebuffer(e.FRAMEBUFFER, null) } function U(e) { return Math.min(r.maxSamples, e.samples) } function B(e) { const n = i.get(e); return o && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture } function k(e, n) { const i = e.colorSpace, r = e.format, s = e.type; return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === Eh || i !== dh && i !== uh && (Zh.getTransfer(i) === gh ? !1 === o ? !0 === t.has("EXT_sRGB") && r === $u ? (e.format = Eh, e.minFilter = zu, e.generateMipmaps = !1) : n = td.sRGBToLinear(n) : r === $u && s === Vu || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", i)), n } function z(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (u.width = e.naturalWidth || e.width, u.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (u.width = e.displayWidth, u.height = e.displayHeight) : (u.width = e.width, u.height = e.height), u } this.allocateTextureUnit = function () { const e = w; return e >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + r.maxTextures), w += 1, e }, this.resetTextureUnits = function () { w = 0 }, this.setTexture2D = A, this.setTexture2DArray = function (t, r) { const s = i.get(t); t.version > 0 && s.__version !== t.version ? I(s, t, r) : n.bindTexture(e.TEXTURE_2D_ARRAY, s.__webglTexture, e.TEXTURE0 + r) }, this.setTexture3D = function (t, r) { const s = i.get(t); t.version > 0 && s.__version !== t.version ? I(s, t, r) : n.bindTexture(e.TEXTURE_3D, s.__webglTexture, e.TEXTURE0 + r) }, this.setTextureCube = function (t, a) { const l = i.get(t); t.version > 0 && l.__version !== t.version ? function (t, a, l) { if (6 !== a.image.length) return; const c = P(t, a), u = a.source; n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + l); const h = i.get(u); if (u.version !== h.__version || !0 === c) { n.activeTexture(e.TEXTURE0 + l); const t = Zh.getPrimaries(Zh.workingColorSpace), i = a.colorSpace === uh ? null : Zh.getPrimaries(a.colorSpace), d = a.colorSpace === uh || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL; e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d); const p = a.isCompressedTexture || a.image[0].isCompressedTexture, f = a.image[0] && a.image[0].isDataTexture, m = []; for (let e = 0; e < 6; e++)m[e] = p || f ? f ? a.image[e].image : a.image[e] : g(a.image[e], !1, !0, r.maxCubemapSize), m[e] = k(a, m[e]); const E = m[0], T = v(E) || o, S = s.convert(a.format, a.colorSpace), M = s.convert(a.type), w = x(a.internalFormat, S, M, a.colorSpace), A = o && !0 !== a.isVideoTexture, D = void 0 === h.__version || !0 === c, C = u.dataReady; let R, P = b(a, E, T); if (L(e.TEXTURE_CUBE_MAP, a, T), p) { A && D && n.texStorage2D(e.TEXTURE_CUBE_MAP, P, w, E.width, E.height); for (let t = 0; t < 6; t++) { R = m[t].mipmaps; for (let i = 0; i < R.length; i++) { const r = R[i]; a.format !== $u ? null !== S ? A ? C && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, S, r.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, w, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : A ? C && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, S, M, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, w, r.width, r.height, 0, S, M, r.data) } } } else { if (R = a.mipmaps, A && D) { R.length > 0 && P++; const t = z(m[0]); n.texStorage2D(e.TEXTURE_CUBE_MAP, P, w, t.width, t.height) } for (let t = 0; t < 6; t++)if (f) { A ? C && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, m[t].width, m[t].height, S, M, m[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, w, m[t].width, m[t].height, 0, S, M, m[t].data); for (let i = 0; i < R.length; i++) { const r = R[i].image[t].image; A ? C && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, r.width, r.height, S, M, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, w, r.width, r.height, 0, S, M, r.data) } } else { A ? C && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, S, M, m[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, w, S, M, m[t]); for (let i = 0; i < R.length; i++) { const r = R[i]; A ? C && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, S, M, r.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, w, S, M, r.image[t]) } } } _(a, T) && y(e.TEXTURE_CUBE_MAP), h.__version = u.version, a.onUpdate && a.onUpdate(a) } t.__version = a.version }(l, t, a) : n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture, e.TEXTURE0 + a) }, this.rebindTextures = function (t, n, r) { const s = i.get(t); void 0 !== n && N(s.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0), void 0 !== r && F(t) }, this.setupRenderTarget = function (t) { const l = t.texture, c = i.get(t), u = i.get(l); t.addEventListener("dispose", S); const h = t.textures, d = !0 === t.isWebGLCubeRenderTarget, p = h.length > 1, f = v(t) || o; if (p || (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()), u.__version = l.version, a.memory.textures++), d) { c.__webglFramebuffer = []; for (let t = 0; t < 6; t++)if (o && l.mipmaps && l.mipmaps.length > 0) { c.__webglFramebuffer[t] = []; for (let n = 0; n < l.mipmaps.length; n++)c.__webglFramebuffer[t][n] = e.createFramebuffer() } else c.__webglFramebuffer[t] = e.createFramebuffer() } else { if (o && l.mipmaps && l.mipmaps.length > 0) { c.__webglFramebuffer = []; for (let t = 0; t < l.mipmaps.length; t++)c.__webglFramebuffer[t] = e.createFramebuffer() } else c.__webglFramebuffer = e.createFramebuffer(); if (p) if (r.drawBuffers) for (let t = 0, n = h.length; t < n; t++) { const n = i.get(h[t]); void 0 === n.__webglTexture && (n.__webglTexture = e.createTexture(), a.memory.textures++) } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); if (o && t.samples > 0 && !1 === B(t)) { c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = [], n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer); for (let n = 0; n < h.length; n++) { const i = h[n]; c.__webglColorRenderbuffer[n] = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, c.__webglColorRenderbuffer[n]); const r = s.convert(i.format, i.colorSpace), a = s.convert(i.type), o = x(i.internalFormat, r, a, i.colorSpace, !0 === t.isXRRenderTarget), l = U(t); e.renderbufferStorageMultisample(e.RENDERBUFFER, l, o, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, c.__webglColorRenderbuffer[n]) } e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), O(c.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(e.FRAMEBUFFER, null) } } if (d) { n.bindTexture(e.TEXTURE_CUBE_MAP, u.__webglTexture), L(e.TEXTURE_CUBE_MAP, l, f); for (let n = 0; n < 6; n++)if (o && l.mipmaps && l.mipmaps.length > 0) for (let i = 0; i < l.mipmaps.length; i++)N(c.__webglFramebuffer[n][i], t, l, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, i); else N(c.__webglFramebuffer[n], t, l, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0); _(l, f) && y(e.TEXTURE_CUBE_MAP), n.unbindTexture() } else if (p) { for (let r = 0, s = h.length; r < s; r++) { const s = h[r], a = i.get(s); n.bindTexture(e.TEXTURE_2D, a.__webglTexture), L(e.TEXTURE_2D, s, f), N(c.__webglFramebuffer, t, s, e.COLOR_ATTACHMENT0 + r, e.TEXTURE_2D, 0), _(s, f) && y(e.TEXTURE_2D) } n.unbindTexture() } else { let i = e.TEXTURE_2D; if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (o ? i = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(i, u.__webglTexture), L(i, l, f), o && l.mipmaps && l.mipmaps.length > 0) for (let n = 0; n < l.mipmaps.length; n++)N(c.__webglFramebuffer[n], t, l, e.COLOR_ATTACHMENT0, i, n); else N(c.__webglFramebuffer, t, l, e.COLOR_ATTACHMENT0, i, 0); _(l, f) && y(i), n.unbindTexture() } t.depthBuffer && F(t) }, this.updateRenderTargetMipmap = function (t) { const r = v(t) || o, s = t.textures; for (let a = 0, o = s.length; a < o; a++) { const o = s[a]; if (_(o, r)) { const r = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D, s = i.get(o).__webglTexture; n.bindTexture(r, s), y(r), n.unbindTexture() } } }, this.updateMultisampleRenderTarget = function (t) { if (o && t.samples > 0 && !1 === B(t)) { const r = t.textures, s = t.width, a = t.height; let o = e.COLOR_BUFFER_BIT; const l = [], u = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, h = i.get(t), d = r.length > 1; if (d) for (let t = 0; t < r.length; t++)n.bindFramebuffer(e.FRAMEBUFFER, h.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null), n.bindFramebuffer(e.FRAMEBUFFER, h.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0); n.bindFramebuffer(e.READ_FRAMEBUFFER, h.__webglMultisampledFramebuffer), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, h.__webglFramebuffer); for (let n = 0; n < r.length; n++) { l.push(e.COLOR_ATTACHMENT0 + n), t.depthBuffer && l.push(u); const p = void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues; if (!1 === p && (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && (o |= e.STENCIL_BUFFER_BIT)), d && e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, h.__webglColorRenderbuffer[n]), !0 === p && (e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [u]), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [u])), d) { const t = i.get(r[n]).__webglTexture; e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0) } e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, e.NEAREST), c && e.invalidateFramebuffer(e.READ_FRAMEBUFFER, l) } if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), d) for (let t = 0; t < r.length; t++) { n.bindFramebuffer(e.FRAMEBUFFER, h.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, h.__webglColorRenderbuffer[t]); const s = i.get(r[t]).__webglTexture; n.bindFramebuffer(e.FRAMEBUFFER, h.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, s, 0) } n.bindFramebuffer(e.DRAW_FRAMEBUFFER, h.__webglMultisampledFramebuffer) } }, this.setupDepthRenderbuffer = F, this.setupFrameBufferTexture = N, this.useMultisampledRTT = B } function gv(e, t, n) { const i = n.isWebGL2; return { convert: function (n, r = "") { let s; const a = Zh.getTransfer(r); if (n === Vu) return e.UNSIGNED_BYTE; if (1017 === n) return e.UNSIGNED_SHORT_4_4_4_4; if (1018 === n) return e.UNSIGNED_SHORT_5_5_5_1; if (1010 === n) return e.BYTE; if (1011 === n) return e.SHORT; if (n === Wu) return e.UNSIGNED_SHORT; if (n === ju) return e.INT; if (n === Xu) return e.UNSIGNED_INT; if (n === qu) return e.FLOAT; if (n === Yu) return i ? e.HALF_FLOAT : (s = t.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null); if (1021 === n) return e.ALPHA; if (n === $u) return e.RGBA; if (1024 === n) return e.LUMINANCE; if (1025 === n) return e.LUMINANCE_ALPHA; if (n === Zu) return e.DEPTH_COMPONENT; if (n === Ju) return e.DEPTH_STENCIL; if (n === Eh) return s = t.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null; if (1028 === n) return e.RED; if (1029 === n) return e.RED_INTEGER; if (1030 === n) return e.RG; if (1031 === n) return e.RG_INTEGER; if (1033 === n) return e.RGBA_INTEGER; if (n === Qu || n === eh || n === th || n === nh) if (a === gh) { if (s = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null; if (n === Qu) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (n === eh) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (n === th) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (n === nh) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else { if (s = t.get("WEBGL_compressed_texture_s3tc"), null === s) return null; if (n === Qu) return s.COMPRESSED_RGB_S3TC_DXT1_EXT; if (n === eh) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (n === th) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (n === nh) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (35840 === n || 35841 === n || 35842 === n || 35843 === n) { if (s = t.get("WEBGL_compressed_texture_pvrtc"), null === s) return null; if (35840 === n) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === n) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === n) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === n) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === n) return s = t.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null; if (37492 === n || 37496 === n) { if (s = t.get("WEBGL_compressed_texture_etc"), null === s) return null; if (37492 === n) return a === gh ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2; if (37496 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC } if (37808 === n || 37809 === n || 37810 === n || 37811 === n || 37812 === n || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n) { if (s = t.get("WEBGL_compressed_texture_astc"), null === s) return null; if (37808 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR; if (37809 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR; if (37810 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR; if (37811 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR; if (37812 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR; if (37813 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR; if (37814 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR; if (37815 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR; if (37816 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR; if (37817 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR; if (37818 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR; if (37819 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR; if (37820 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR; if (37821 === n) return a === gh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR } if (n === ih || 36494 === n || 36495 === n) { if (s = t.get("EXT_texture_compression_bptc"), null === s) return null; if (n === ih) return a === gh ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT; if (36494 === n) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT; if (36495 === n) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT } if (36283 === n || 36284 === n || 36285 === n || 36286 === n) { if (s = t.get("EXT_texture_compression_rgtc"), null === s) return null; if (n === ih) return s.COMPRESSED_RED_RGTC1_EXT; if (36284 === n) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (36285 === n) return s.COMPRESSED_RED_GREEN_RGTC2_EXT; if (36286 === n) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } return n === Ku ? i ? e.UNSIGNED_INT_24_8 : (s = t.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e[n] ? e[n] : null } } } class vv extends Af { constructor(e = []) { super(), this.isArrayCamera = !0, this.cameras = e } } class _v extends gp { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const yv = { type: "move" }; class xv { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return null === this._hand && (this._hand = new _v, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new _v, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new pd, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new pd), this._targetRay } getGripSpace() { return null === this._grip && (this._grip = new _v, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new pd, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new pd), this._grip } dispatchEvent(e) { return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this } connect(e) { if (e && e.hand) { const t = this._hand; if (t) for (const n of e.hand.values()) this._getHandJoint(t, n) } return this.dispatchEvent({ type: "connected", data: e }), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this } update(e, t, n) { let i = null, r = null, s = null; const a = this._targetRay, o = this._grip, l = this._hand; if (e && "visible-blurred" !== t.session.visibilityState) { if (l && e.hand) { s = !0; for (const i of e.hand.values()) { const e = t.getJointPose(i, n), r = this._getHandJoint(l, i); null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = e.radius), r.visible = null !== e } const i = l.joints["index-finger-tip"], r = l.joints["thumb-tip"], a = i.position.distanceTo(r.position), o = .02, c = .005; l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1)); null !== a && (i = t.getPose(e.targetRaySpace, n), null === i && null !== r && (i = r), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(yv))) } return null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this } _getHandJoint(e, t) { if (void 0 === e.joints[t.jointName]) { const n = new _v; n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n) } return e.joints[t.jointName] } } class bv { constructor() { this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0 } init(e, t, n) { if (null === this.texture) { const i = new ad; e.properties.get(i).__webglTexture = t.texture, t.depthNear == n.depthNear && t.depthFar == n.depthFar || (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i } } render(e, t) { if (null !== this.texture) { if (null === this.mesh) { const e = t.cameras[0].viewport, n = new Ef({ extensions: { fragDepth: !0 }, vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}", fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}", uniforms: { depthColor: { value: this.texture }, depthWidth: { value: e.z }, depthHeight: { value: e.w } } }); this.mesh = new mf(new Hf(20, 20), n) } e.render(this.mesh, t) } } reset() { this.texture = null, this.mesh = null } } class Ev extends Mh { constructor(e, t) { super(); const n = this; let i = null, r = 1, s = null, a = "local-floor", o = 1, l = null, c = null, u = null, h = null, d = null, p = null; const f = new bv, m = t.getContextAttributes(); let g = null, v = null; const _ = [], y = [], x = new kh; let b = null; const E = new Af; E.layers.enable(1), E.viewport = new od; const T = new Af; T.layers.enable(2), T.viewport = new od; const S = [E, T], M = new vv; M.layers.enable(1), M.layers.enable(2); let w = null, A = null; function D(e) { const t = y.indexOf(e.inputSource); if (-1 === t) return; const n = _[t]; void 0 !== n && (n.update(e.inputSource, e.frame, l || s), n.dispatchEvent({ type: e.type, data: e.inputSource })) } function C() { i.removeEventListener("select", D), i.removeEventListener("selectstart", D), i.removeEventListener("selectend", D), i.removeEventListener("squeeze", D), i.removeEventListener("squeezestart", D), i.removeEventListener("squeezeend", D), i.removeEventListener("end", C), i.removeEventListener("inputsourceschange", R); for (let e = 0; e < _.length; e++) { const t = y[e]; null !== t && (y[e] = null, _[e].disconnect(t)) } w = null, A = null, f.reset(), e.setRenderTarget(g), d = null, h = null, u = null, i = null, v = null, O.stop(), n.isPresenting = !1, e.setPixelRatio(b), e.setSize(x.width, x.height, !1), n.dispatchEvent({ type: "sessionend" }) } function R(e) { for (let t = 0; t < e.removed.length; t++) { const n = e.removed[t], i = y.indexOf(n); i >= 0 && (y[i] = null, _[i].disconnect(n)) } for (let t = 0; t < e.added.length; t++) { const n = e.added[t]; let i = y.indexOf(n); if (-1 === i) { for (let e = 0; e < _.length; e++) { if (e >= y.length) { y.push(n), i = e; break } if (null === y[e]) { y[e] = n, i = e; break } } if (-1 === i) break } const r = _[i]; r && r.connect(n) } } this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (e) { let t = _[e]; return void 0 === t && (t = new xv, _[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function (e) { let t = _[e]; return void 0 === t && (t = new xv, _[e] = t), t.getGripSpace() }, this.getHand = function (e) { let t = _[e]; return void 0 === t && (t = new xv, _[e] = t), t.getHandSpace() }, this.setFramebufferScaleFactor = function (e) { r = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (e) { a = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return l || s }, this.setReferenceSpace = function (e) { l = e }, this.getBaseLayer = function () { return null !== h ? h : d }, this.getBinding = function () { return u }, this.getFrame = function () { return p }, this.getSession = function () { return i }, this.setSession = async function (c) { if (i = c, null !== i) { if (g = e.getRenderTarget(), i.addEventListener("select", D), i.addEventListener("selectstart", D), i.addEventListener("selectend", D), i.addEventListener("squeeze", D), i.addEventListener("squeezestart", D), i.addEventListener("squeezeend", D), i.addEventListener("end", C), i.addEventListener("inputsourceschange", R), !0 !== m.xrCompatible && await t.makeXRCompatible(), b = e.getPixelRatio(), e.getSize(x), void 0 === i.renderState.layers || !1 === e.capabilities.isWebGL2) { const n = { antialias: void 0 !== i.renderState.layers || m.antialias, alpha: !0, depth: m.depth, stencil: m.stencil, framebufferScaleFactor: r }; d = new XRWebGLLayer(i, t, n), i.updateRenderState({ baseLayer: d }), e.setPixelRatio(1), e.setSize(d.framebufferWidth, d.framebufferHeight, !1), v = new cd(d.framebufferWidth, d.framebufferHeight, { format: $u, type: Vu, colorSpace: e.outputColorSpace, stencilBuffer: m.stencil }) } else { let n = null, s = null, a = null; m.depth && (a = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, n = m.stencil ? Ju : Zu, s = m.stencil ? Ku : Xu); const o = { colorFormat: t.RGBA8, depthFormat: a, scaleFactor: r }; u = new XRWebGLBinding(i, t), h = u.createProjectionLayer(o), i.updateRenderState({ layers: [h] }), e.setPixelRatio(1), e.setSize(h.textureWidth, h.textureHeight, !1), v = new cd(h.textureWidth, h.textureHeight, { format: $u, type: Vu, depthTexture: new wm(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n), stencilBuffer: m.stencil, colorSpace: e.outputColorSpace, samples: m.antialias ? 4 : 0 }); e.properties.get(v).__ignoreDepthValues = h.ignoreDepthValues } v.isXRRenderTarget = !0, this.setFoveation(o), l = null, s = await i.requestReferenceSpace(a), O.setContext(i), O.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } }, this.getEnvironmentBlendMode = function () { if (null !== i) return i.environmentBlendMode }; const L = new pd, P = new pd; function I(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert() } this.updateCamera = function (e) { if (null === i) return; null !== f.texture && (e.near = f.depthNear, e.far = f.depthFar), M.near = T.near = E.near = e.near, M.far = T.far = E.far = e.far, w === M.near && A === M.far || (i.updateRenderState({ depthNear: M.near, depthFar: M.far }), w = M.near, A = M.far, E.near = w, E.far = A, T.near = w, T.far = A, E.updateProjectionMatrix(), T.updateProjectionMatrix(), e.updateProjectionMatrix()); const t = e.parent, n = M.cameras; I(M, t); for (let e = 0; e < n.length; e++)I(n[e], t); 2 === n.length ? function (e, t, n) { L.setFromMatrixPosition(t.matrixWorld), P.setFromMatrixPosition(n.matrixWorld); const i = L.distanceTo(P), r = t.projectionMatrix.elements, s = n.projectionMatrix.elements, a = r[14] / (r[10] - 1), o = r[14] / (r[10] + 1), l = (r[9] + 1) / r[5], c = (r[9] - 1) / r[5], u = (r[8] - 1) / r[0], h = (s[8] + 1) / s[0], d = a * u, p = a * h, f = i / (-u + h), m = f * -u; t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(); const g = a + f, v = o + f, _ = d - m, y = p + (i - m), x = l * o / v * g, b = c * o / v * g; e.projectionMatrix.makePerspective(_, y, x, b, g, v), e.projectionMatrixInverse.copy(e.projectionMatrix).invert() }(M, E, T) : M.projectionMatrix.copy(E.projectionMatrix), function (e, t, n) { null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld), e.matrix.invert(), e.matrix.multiply(t.matrixWorld)); e.matrix.decompose(e.position, e.quaternion, e.scale), e.updateMatrixWorld(!0), e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse), e.isPerspectiveCamera && (e.fov = 2 * Ch * Math.atan(1 / e.projectionMatrix.elements[5]), e.zoom = 1) }(e, M, t) }, this.getCamera = function () { return M }, this.getFoveation = function () { if (null !== h || null !== d) return o }, this.setFoveation = function (e) { o = e, null !== h && (h.fixedFoveation = e), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e) }, this.hasDepthSensing = function () { return null !== f.texture }; let N = null; const O = new kf; O.setAnimationLoop((function (t, r) { if (c = r.getViewerPose(l || s), p = r, null !== c) { const t = c.views; null !== d && (e.setRenderTargetFramebuffer(v, d.framebuffer), e.setRenderTarget(v)); let n = !1; t.length !== M.cameras.length && (M.cameras.length = 0, n = !0); for (let i = 0; i < t.length; i++) { const r = t[i]; let s = null; if (null !== d) s = d.getViewport(r); else { const t = u.getViewSubImage(h, r); s = t.viewport, 0 === i && (e.setRenderTargetTextures(v, t.colorTexture, h.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(v)) } let a = S[i]; void 0 === a && (a = new Af, a.layers.enable(i), a.viewport = new od, S[i] = a), a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.quaternion, a.scale), a.projectionMatrix.fromArray(r.projectionMatrix), a.projectionMatrixInverse.copy(a.projectionMatrix).invert(), a.viewport.set(s.x, s.y, s.width, s.height), 0 === i && (M.matrix.copy(a.matrix), M.matrix.decompose(M.position, M.quaternion, M.scale)), !0 === n && M.cameras.push(a) } const r = i.enabledFeatures; if (r && r.includes("depth-sensing")) { const n = u.getDepthInformation(t[0]); n && n.isValid && n.texture && f.init(e, n, i.renderState) } } for (let e = 0; e < _.length; e++) { const t = y[e], n = _[e]; null !== t && void 0 !== n && n.update(t, r, l || s) } f.render(e, M), N && N(t, r), r.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: r }), p = null })), this.setAnimationLoop = function (e) { N = e }, this.dispose = function () { } } } const Tv = new Qd, Sv = new Vd; function Mv(e, t) { function n(e, t) { !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix) } function i(i, r) { i.opacity.value = r.opacity, r.color && i.diffuse.value.copy(r.color), r.emissive && i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (i.map.value = r.map, n(r.map, i.mapTransform)), r.alphaMap && (i.alphaMap.value = r.alphaMap, n(r.alphaMap, i.alphaMapTransform)), r.bumpMap && (i.bumpMap.value = r.bumpMap, n(r.bumpMap, i.bumpMapTransform), i.bumpScale.value = r.bumpScale, r.side === mu && (i.bumpScale.value *= -1)), r.normalMap && (i.normalMap.value = r.normalMap, n(r.normalMap, i.normalMapTransform), i.normalScale.value.copy(r.normalScale), r.side === mu && i.normalScale.value.negate()), r.displacementMap && (i.displacementMap.value = r.displacementMap, n(r.displacementMap, i.displacementMapTransform), i.displacementScale.value = r.displacementScale, i.displacementBias.value = r.displacementBias), r.emissiveMap && (i.emissiveMap.value = r.emissiveMap, n(r.emissiveMap, i.emissiveMapTransform)), r.specularMap && (i.specularMap.value = r.specularMap, n(r.specularMap, i.specularMapTransform)), r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest); const s = t.get(r), a = s.envMap, o = s.envMapRotation; if (a && (i.envMap.value = a, Tv.copy(o), Tv.x *= -1, Tv.y *= -1, Tv.z *= -1, a.isCubeTexture && !1 === a.isRenderTargetTexture && (Tv.y *= -1, Tv.z *= -1), i.envMapRotation.value.setFromMatrix4(Sv.makeRotationFromEuler(Tv)), i.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1, i.reflectivity.value = r.reflectivity, i.ior.value = r.ior, i.refractionRatio.value = r.refractionRatio), r.lightMap) { i.lightMap.value = r.lightMap; const t = !0 === e._useLegacyLights ? Math.PI : 1; i.lightMapIntensity.value = r.lightMapIntensity * t, n(r.lightMap, i.lightMapTransform) } r.aoMap && (i.aoMap.value = r.aoMap, i.aoMapIntensity.value = r.aoMapIntensity, n(r.aoMap, i.aoMapTransform)) } return { refreshFogUniforms: function (t, n) { n.color.getRGB(t.fogColor.value, xf(e)), n.isFog ? (t.fogNear.value = n.near, t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density) }, refreshMaterialUniforms: function (e, r, s, a, o) { r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(e, r) : r.isMeshToonMaterial ? (i(e, r), function (e, t) { t.gradientMap && (e.gradientMap.value = t.gradientMap) }(e, r)) : r.isMeshPhongMaterial ? (i(e, r), function (e, t) { e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4) }(e, r)) : r.isMeshStandardMaterial ? (i(e, r), function (e, i) { e.metalness.value = i.metalness, i.metalnessMap && (e.metalnessMap.value = i.metalnessMap, n(i.metalnessMap, e.metalnessMapTransform)); e.roughness.value = i.roughness, i.roughnessMap && (e.roughnessMap.value = i.roughnessMap, n(i.roughnessMap, e.roughnessMapTransform)); const r = t.get(i).envMap; r && (e.envMapIntensity.value = i.envMapIntensity) }(e, r), r.isMeshPhysicalMaterial && function (e, t, i) { e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap, n(t.sheenColorMap, e.sheenColorMapTransform)), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap, n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform))); t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap, n(t.clearcoatMap, e.clearcoatMapTransform)), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap, n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)), t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap, n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform), e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), t.side === mu && e.clearcoatNormalScale.value.negate())); t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap, n(t.iridescenceMap, e.iridescenceMapTransform)), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap, n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform))); t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = i.texture, e.transmissionSamplerSize.value.set(i.width, i.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap, n(t.transmissionMap, e.transmissionMapTransform)), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap, n(t.thicknessMap, e.thicknessMapTransform)), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor)); t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)), t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap, n(t.anisotropyMap, e.anisotropyMapTransform))); e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap, n(t.specularColorMap, e.specularColorMapTransform)); t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap, n(t.specularIntensityMap, e.specularIntensityMapTransform)) }(e, r, o)) : r.isMeshMatcapMaterial ? (i(e, r), function (e, t) { t.matcap && (e.matcap.value = t.matcap) }(e, r)) : r.isMeshDepthMaterial ? i(e, r) : r.isMeshDistanceMaterial ? (i(e, r), function (e, n) { const i = t.get(n).light; e.referencePosition.value.setFromMatrixPosition(i.matrixWorld), e.nearDistance.value = i.shadow.camera.near, e.farDistance.value = i.shadow.camera.far }(e, r)) : r.isMeshNormalMaterial ? i(e, r) : r.isLineBasicMaterial ? (function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, t.map && (e.map.value = t.map, n(t.map, e.mapTransform)) }(e, r), r.isLineDashedMaterial && function (e, t) { e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale }(e, r)) : r.isPointsMaterial ? function (e, t, i, r) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * i, e.scale.value = .5 * r, t.map && (e.map.value = t.map, n(t.map, e.uvTransform)); t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform)); t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest) }(e, r, s, a) : r.isSpriteMaterial ? function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map, n(t.map, e.mapTransform)); t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform)); t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest) }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1) } } } function wv(e, t, n, i) { let r = {}, s = {}, a = []; const o = n.isWebGL2 ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0; function l(e, t, n, i) { const r = e.value, s = t + "_" + n; if (void 0 === i[s]) return i[s] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(), !0; { const e = i[s]; if ("number" == typeof r || "boolean" == typeof r) { if (e !== r) return i[s] = r, !0 } else if (!1 === e.equals(r)) return e.copy(r), !0 } return !1 } function c(e) { const t = { boundary: 0, storage: 0 }; return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e), t } function u(t) { const n = t.target; n.removeEventListener("dispose", u); const i = a.indexOf(n.__bindingPointIndex); a.splice(i, 1), e.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id] } return { bind: function (e, t) { const n = t.program; i.uniformBlockBinding(e, n) }, update: function (n, h) { let d = r[n.id]; void 0 === d && (!function (e) { const t = e.uniforms; let n = 0; const i = 16; for (let e = 0, r = t.length; e < r; e++) { const r = Array.isArray(t[e]) ? t[e] : [t[e]]; for (let e = 0, t = r.length; e < t; e++) { const t = r[e], s = Array.isArray(t.value) ? t.value : [t.value]; for (let e = 0, r = s.length; e < r; e++) { const r = c(s[e]), a = n % i; 0 !== a && i - a < r.boundary && (n += i - a), t.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT), t.__offset = n, n += r.storage } } } const r = n % i; r > 0 && (n += i - r); e.__size = n, e.__cache = {} }(n), d = function (t) { const n = function () { for (let e = 0; e < o; e++)if (-1 === a.indexOf(e)) return a.push(e), e; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 }(); t.__bindingPointIndex = n; const i = e.createBuffer(), r = t.__size, s = t.usage; return e.bindBuffer(e.UNIFORM_BUFFER, i), e.bufferData(e.UNIFORM_BUFFER, r, s), e.bindBuffer(e.UNIFORM_BUFFER, null), e.bindBufferBase(e.UNIFORM_BUFFER, n, i), i }(n), r[n.id] = d, n.addEventListener("dispose", u)); const p = h.program; i.updateUBOMapping(n, p); const f = t.render.frame; s[n.id] !== f && (!function (t) { const n = r[t.id], i = t.uniforms, s = t.__cache; e.bindBuffer(e.UNIFORM_BUFFER, n); for (let t = 0, n = i.length; t < n; t++) { const n = Array.isArray(i[t]) ? i[t] : [i[t]]; for (let i = 0, r = n.length; i < r; i++) { const r = n[i]; if (!0 === l(r, t, i, s)) { const t = r.__offset, n = Array.isArray(r.value) ? r.value : [r.value]; let i = 0; for (let s = 0; s < n.length; s++) { const a = n[s], o = c(a); "number" == typeof a || "boolean" == typeof a ? (r.__data[0] = a, e.bufferSubData(e.UNIFORM_BUFFER, t + i, r.__data)) : a.isMatrix3 ? (r.__data[0] = a.elements[0], r.__data[1] = a.elements[1], r.__data[2] = a.elements[2], r.__data[3] = 0, r.__data[4] = a.elements[3], r.__data[5] = a.elements[4], r.__data[6] = a.elements[5], r.__data[7] = 0, r.__data[8] = a.elements[6], r.__data[9] = a.elements[7], r.__data[10] = a.elements[8], r.__data[11] = 0) : (a.toArray(r.__data, i), i += o.storage / Float32Array.BYTES_PER_ELEMENT) } e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data) } } } e.bindBuffer(e.UNIFORM_BUFFER, null) }(n), s[n.id] = f) }, dispose: function () { for (const t in r) e.deleteBuffer(r[t]); a = [], r = {}, s = {} } } } class Av { constructor(e = {}) { const { canvas: t = Wh(), context: n = null, depth: i = !0, stencil: r = !0, alpha: s = !1, antialias: a = !1, premultipliedAlpha: o = !0, preserveDrawingBuffer: l = !1, powerPreference: c = "default", failIfMajorPerformanceCaveat: u = !1 } = e; let h; this.isWebGLRenderer = !0, h = null !== n ? n.getContextAttributes().alpha : s; const d = new Uint32Array(4), p = new Int32Array(4); let f = null, m = null; const g = [], v = []; this.domElement = t, this.debug = { checkShaderErrors: !0, onShaderError: null }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = hh, this._useLegacyLights = !1, this.toneMapping = xu, this.toneMappingExposure = 1; const _ = this; let y = !1, x = 0, b = 0, E = null, T = -1, S = null; const M = new od, w = new od; let A = null; const D = new Pp(0); let C = 0, R = t.width, L = t.height, P = 1, I = null, N = null; const O = new od(0, 0, R, L), F = new od(0, 0, R, L); let U = !1; const B = new Bf; let k = !1, z = !1, H = null; const G = new Vd, V = new kh, W = new pd, j = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function X() { return null === E ? P : 1 } let q, Y, K, $, Z, J, Q, ee, te, ne, ie, re, se, ae, oe, le, ce, ue, he, de, pe, fe, me, ge, ve = n; function _e(e, n) { for (let i = 0; i < e.length; i++) { const r = e[i], s = t.getContext(r, n); if (null !== s) return s } return null } try { const e = { alpha: !0, depth: i, stencil: r, antialias: a, premultipliedAlpha: o, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: u }; if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${uu}`), t.addEventListener("webglcontextlost", be, !1), t.addEventListener("webglcontextrestored", Ee, !1), t.addEventListener("webglcontextcreationerror", Te, !1), null === ve) { const t = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === _.isWebGL1Renderer && t.shift(), ve = _e(t, e), null === ve) throw _e(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } "undefined" != typeof WebGLRenderingContext && ve instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), void 0 === ve.getShaderPrecisionFormat && (ve.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e } function ye() { q = new _m(ve), Y = new Zf(ve, q, e), q.init(Y), fe = new gv(ve, q, Y), K = new fv(ve, q, Y), $ = new bm(ve), Z = new ev, J = new mv(ve, q, K, Z, Y, fe, $), Q = new Qf(_), ee = new vm(_), te = new zf(ve, Y), me = new Kf(ve, q, te, Y), ne = new ym(ve, te, $, me), ie = new Mm(ve, ne, te, $), he = new Sm(ve, Y, J), le = new Jf(Z), re = new Qg(_, Q, ee, q, Y, me, le), se = new Mv(_, Z), ae = new rv, oe = new uv(q, Y), ue = new Yf(_, Q, ee, K, ie, h, o), ce = new pv(_, ie, Y), ge = new wv(ve, $, Y, K), de = new $f(ve, q, $, Y), pe = new xm(ve, q, $, Y), $.programs = re.programs, _.capabilities = Y, _.extensions = q, _.properties = Z, _.renderLists = ae, _.shadowMap = ce, _.state = K, _.info = $ } ye(); const xe = new Ev(_, ve); function be(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y = !0 } function Ee() { console.log("THREE.WebGLRenderer: Context Restored."), y = !1; const e = $.autoReset, t = ce.enabled, n = ce.autoUpdate, i = ce.needsUpdate, r = ce.type; ye(), $.autoReset = e, ce.enabled = t, ce.autoUpdate = n, ce.needsUpdate = i, ce.type = r } function Te(e) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage) } function Se(e) { const t = e.target; t.removeEventListener("dispose", Se), function (e) { (function (e) { const t = Z.get(e).programs; void 0 !== t && (t.forEach((function (e) { re.releaseProgram(e) })), e.isShaderMaterial && re.releaseShaderCache(e)) })(e), Z.remove(e) }(t) } function Me(e, t, n) { !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass ? (e.side = mu, e.needsUpdate = !0, Ne(e, t, n), e.side = fu, e.needsUpdate = !0, Ne(e, t, n), e.side = 2) : Ne(e, t, n) } this.xr = xe, this.getContext = function () { return ve }, this.getContextAttributes = function () { return ve.getContextAttributes() }, this.forceContextLoss = function () { const e = q.get("WEBGL_lose_context"); e && e.loseContext() }, this.forceContextRestore = function () { const e = q.get("WEBGL_lose_context"); e && e.restoreContext() }, this.getPixelRatio = function () { return P }, this.setPixelRatio = function (e) { void 0 !== e && (P = e, this.setSize(R, L, !1)) }, this.getSize = function (e) { return e.set(R, L) }, this.setSize = function (e, n, i = !0) { xe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R = e, L = n, t.width = Math.floor(e * P), t.height = Math.floor(n * P), !0 === i && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n)) }, this.getDrawingBufferSize = function (e) { return e.set(R * P, L * P).floor() }, this.setDrawingBufferSize = function (e, n, i) { R = e, L = n, P = i, t.width = Math.floor(e * i), t.height = Math.floor(n * i), this.setViewport(0, 0, e, n) }, this.getCurrentViewport = function (e) { return e.copy(M) }, this.getViewport = function (e) { return e.copy(O) }, this.setViewport = function (e, t, n, i) { e.isVector4 ? O.set(e.x, e.y, e.z, e.w) : O.set(e, t, n, i), K.viewport(M.copy(O).multiplyScalar(P).round()) }, this.getScissor = function (e) { return e.copy(F) }, this.setScissor = function (e, t, n, i) { e.isVector4 ? F.set(e.x, e.y, e.z, e.w) : F.set(e, t, n, i), K.scissor(w.copy(F).multiplyScalar(P).round()) }, this.getScissorTest = function () { return U }, this.setScissorTest = function (e) { K.setScissorTest(U = e) }, this.setOpaqueSort = function (e) { I = e }, this.setTransparentSort = function (e) { N = e }, this.getClearColor = function (e) { return e.copy(ue.getClearColor()) }, this.setClearColor = function () { ue.setClearColor.apply(ue, arguments) }, this.getClearAlpha = function () { return ue.getClearAlpha() }, this.setClearAlpha = function () { ue.setClearAlpha.apply(ue, arguments) }, this.clear = function (e = !0, t = !0, n = !0) { let i = 0; if (e) { let e = !1; if (null !== E) { const t = E.texture.format; e = 1033 === t || 1031 === t || 1029 === t } if (e) { const e = E.texture.type, t = e === Vu || e === Xu || e === Wu || e === Ku || 1017 === e || 1018 === e, n = ue.getClearColor(), i = ue.getClearAlpha(), r = n.r, s = n.g, a = n.b; t ? (d[0] = r, d[1] = s, d[2] = a, d[3] = i, ve.clearBufferuiv(ve.COLOR, 0, d)) : (p[0] = r, p[1] = s, p[2] = a, p[3] = i, ve.clearBufferiv(ve.COLOR, 0, p)) } else i |= ve.COLOR_BUFFER_BIT } t && (i |= ve.DEPTH_BUFFER_BIT), n && (i |= ve.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), ve.clear(i) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", be, !1), t.removeEventListener("webglcontextrestored", Ee, !1), t.removeEventListener("webglcontextcreationerror", Te, !1), ae.dispose(), oe.dispose(), Z.dispose(), Q.dispose(), ee.dispose(), ie.dispose(), me.dispose(), ge.dispose(), re.dispose(), xe.dispose(), xe.removeEventListener("sessionstart", Ae), xe.removeEventListener("sessionend", De), H && (H.dispose(), H = null), Ce.stop() }, this.renderBufferDirect = function (e, t, n, i, r, s) { null === t && (t = j); const a = r.isMesh && r.matrixWorld.determinant() < 0, o = function (e, t, n, i, r) { !0 !== t.isScene && (t = j); J.resetTextureUnits(); const s = t.fog, a = i.isMeshStandardMaterial ? t.environment : null, o = null === E ? _.outputColorSpace : !0 === E.isXRRenderTarget ? E.texture.colorSpace : dh, l = (i.isMeshStandardMaterial ? ee : Q).get(i.envMap || a), c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize, u = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0), h = !!n.morphAttributes.position, d = !!n.morphAttributes.normal, p = !!n.morphAttributes.color; let f = xu; i.toneMapped && (null !== E && !0 !== E.isXRRenderTarget || (f = _.toneMapping)); const g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color, v = void 0 !== g ? g.length : 0, y = Z.get(i), x = m.state.lights; if (!0 === k && (!0 === z || e !== S)) { const t = e === S && i.id === T; le.setState(i, e, t) } let b = !1; i.version === y.__version ? y.needsLights && y.lightsStateVersion !== x.state.version || y.outputColorSpace !== o || r.isBatchedMesh && !1 === y.batching ? b = !0 : r.isBatchedMesh || !0 !== y.batching ? r.isInstancedMesh && !1 === y.instancing ? b = !0 : r.isInstancedMesh || !0 !== y.instancing ? r.isSkinnedMesh && !1 === y.skinning ? b = !0 : r.isSkinnedMesh || !0 !== y.skinning ? r.isInstancedMesh && !0 === y.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === y.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === y.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === y.instancingMorph && null !== r.morphTexture || y.envMap !== l || !0 === i.fog && y.fog !== s ? b = !0 : void 0 === y.numClippingPlanes || y.numClippingPlanes === le.numPlanes && y.numIntersection === le.numIntersection ? (y.vertexAlphas !== c || y.vertexTangents !== u || y.morphTargets !== h || y.morphNormals !== d || y.morphColors !== p || y.toneMapping !== f || !0 === Y.isWebGL2 && y.morphTargetsCount !== v) && (b = !0) : b = !0 : b = !0 : b = !0 : b = !0 : (b = !0, y.__version = i.version); let M = y.currentProgram; !0 === b && (M = Ne(i, t, r)); let w = !1, A = !1, D = !1; const C = M.getUniforms(), R = y.uniforms; K.useProgram(M.program) && (w = !0, A = !0, D = !0); i.id !== T && (T = i.id, A = !0); if (w || S !== e) { C.setValue(ve, "projectionMatrix", e.projectionMatrix), C.setValue(ve, "viewMatrix", e.matrixWorldInverse); const t = C.map.cameraPosition; void 0 !== t && t.setValue(ve, W.setFromMatrixPosition(e.matrixWorld)), Y.logarithmicDepthBuffer && C.setValue(ve, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && C.setValue(ve, "isOrthographic", !0 === e.isOrthographicCamera), S !== e && (S = e, A = !0, D = !0) } if (r.isSkinnedMesh) { C.setOptional(ve, r, "bindMatrix"), C.setOptional(ve, r, "bindMatrixInverse"); const e = r.skeleton; e && (Y.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), C.setValue(ve, "boneTexture", e.boneTexture, J)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.")) } r.isBatchedMesh && (C.setOptional(ve, r, "batchingTexture"), C.setValue(ve, "batchingTexture", r._matricesTexture, J)); const I = n.morphAttributes; (void 0 !== I.position || void 0 !== I.normal || void 0 !== I.color && !0 === Y.isWebGL2) && he.update(r, n, M); (A || y.receiveShadow !== r.receiveShadow) && (y.receiveShadow = r.receiveShadow, C.setValue(ve, "receiveShadow", r.receiveShadow)); i.isMeshGouraudMaterial && null !== i.envMap && (R.envMap.value = l, R.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1); A && (C.setValue(ve, "toneMappingExposure", _.toneMappingExposure), y.needsLights && (O = D, (N = R).ambientLightColor.needsUpdate = O, N.lightProbe.needsUpdate = O, N.directionalLights.needsUpdate = O, N.directionalLightShadows.needsUpdate = O, N.pointLights.needsUpdate = O, N.pointLightShadows.needsUpdate = O, N.spotLights.needsUpdate = O, N.spotLightShadows.needsUpdate = O, N.rectAreaLights.needsUpdate = O, N.hemisphereLights.needsUpdate = O), s && !0 === i.fog && se.refreshFogUniforms(R, s), se.refreshMaterialUniforms(R, i, P, L, H), Lg.upload(ve, Oe(y), R, J)); var N, O; i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Lg.upload(ve, Oe(y), R, J), i.uniformsNeedUpdate = !1); i.isSpriteMaterial && C.setValue(ve, "center", r.center); if (C.setValue(ve, "modelViewMatrix", r.modelViewMatrix), C.setValue(ve, "normalMatrix", r.normalMatrix), C.setValue(ve, "modelMatrix", r.matrixWorld), i.isShaderMaterial || i.isRawShaderMaterial) { const e = i.uniformsGroups; for (let t = 0, n = e.length; t < n; t++)if (Y.isWebGL2) { const n = e[t]; ge.update(n, M), ge.bind(n, M) } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.") } return M }(e, t, n, i, r); K.setMaterial(i, a); let l = n.index, c = 1; if (!0 === i.wireframe) { if (l = ne.getWireframeAttribute(n), void 0 === l) return; c = 2 } const u = n.drawRange, h = n.attributes.position; let d = u.start * c, p = (u.start + u.count) * c; null !== s && (d = Math.max(d, s.start * c), p = Math.min(p, (s.start + s.count) * c)), null !== l ? (d = Math.max(d, 0), p = Math.min(p, l.count)) : null != h && (d = Math.max(d, 0), p = Math.min(p, h.count)); const f = p - d; if (f < 0 || f === 1 / 0) return; let g; me.setup(r, i, o, n, l); let v = de; if (null !== l && (g = te.get(l), v = pe, v.setIndex(g)), r.isMesh) !0 === i.wireframe ? (K.setLineWidth(i.wireframeLinewidth * X()), v.setMode(ve.LINES)) : v.setMode(ve.TRIANGLES); else if (r.isLine) { let e = i.linewidth; void 0 === e && (e = 1), K.setLineWidth(e * X()), r.isLineSegments ? v.setMode(ve.LINES) : r.isLineLoop ? v.setMode(ve.LINE_LOOP) : v.setMode(ve.LINE_STRIP) } else r.isPoints ? v.setMode(ve.POINTS) : r.isSprite && v.setMode(ve.TRIANGLES); if (r.isBatchedMesh) v.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount); else if (r.isInstancedMesh) v.renderInstances(d, f, r.count); else if (n.isInstancedBufferGeometry) { const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0, t = Math.min(n.instanceCount, e); v.renderInstances(d, f, t) } else v.render(d, f) }, this.compile = function (e, t, n = null) { null === n && (n = e), m = oe.get(n), m.init(), v.push(m), n.traverseVisible((function (e) { e.isLight && e.layers.test(t.layers) && (m.pushLight(e), e.castShadow && m.pushShadow(e)) })), e !== n && e.traverseVisible((function (e) { e.isLight && e.layers.test(t.layers) && (m.pushLight(e), e.castShadow && m.pushShadow(e)) })), m.setupLights(_._useLegacyLights); const i = new Set; return e.traverse((function (e) { const t = e.material; if (t) if (Array.isArray(t)) for (let r = 0; r < t.length; r++) { const s = t[r]; Me(s, n, e), i.add(s) } else Me(t, n, e), i.add(t) })), v.pop(), m = null, i }, this.compileAsync = function (e, t, n = null) { const i = this.compile(e, t, n); return new Promise((t => { function n() { i.forEach((function (e) { Z.get(e).currentProgram.isReady() && i.delete(e) })), 0 !== i.size ? setTimeout(n, 10) : t(e) } null !== q.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10) })) }; let we = null; function Ae() { Ce.stop() } function De() { Ce.start() } const Ce = new kf; function Re(e, t, n, i) { if (!1 === e.visible) return; if (e.layers.test(t.layers)) if (e.isGroup) n = e.renderOrder; else if (e.isLOD) !0 === e.autoUpdate && e.update(t); else if (e.isLight) m.pushLight(e), e.castShadow && m.pushShadow(e); else if (e.isSprite) { if (!e.frustumCulled || B.intersectsSprite(e)) { i && W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(G); const t = ie.update(e), r = e.material; r.visible && f.push(e, t, r, n, W.z, null) } } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || B.intersectsObject(e))) { const t = ie.update(e), r = e.material; if (i && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(), W.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(), W.copy(t.boundingSphere.center)), W.applyMatrix4(e.matrixWorld).applyMatrix4(G)), Array.isArray(r)) { const i = t.groups; for (let s = 0, a = i.length; s < a; s++) { const a = i[s], o = r[a.materialIndex]; o && o.visible && f.push(e, t, o, n, W.z, a) } } else r.visible && f.push(e, t, r, n, W.z, null) } const r = e.children; for (let e = 0, s = r.length; e < s; e++)Re(r[e], t, n, i) } function Le(e, t, n, i) { const r = e.opaque, s = e.transmissive, a = e.transparent; m.setupLightsView(n), !0 === k && le.setGlobalState(_.clippingPlanes, n), s.length > 0 && function (e, t, n, i) { const r = !0 === n.isScene ? n.overrideMaterial : null; if (null !== r) return; const s = Y.isWebGL2; null === H && (H = new cd(1, 1, { generateMipmaps: !0, type: q.has("EXT_color_buffer_half_float") ? Yu : Vu, minFilter: Gu, samples: s ? 4 : 0 })); _.getDrawingBufferSize(V), s ? H.setSize(V.x, V.y) : H.setSize(Oh(V.x), Oh(V.y)); const a = _.getRenderTarget(); _.setRenderTarget(H), _.getClearColor(D), C = _.getClearAlpha(), C < 1 && _.setClearColor(16777215, .5); _.clear(); const o = _.toneMapping; _.toneMapping = xu, Pe(e, n, i), J.updateMultisampleRenderTarget(H), J.updateRenderTargetMipmap(H); let l = !1; for (let e = 0, r = t.length; e < r; e++) { const r = t[e], s = r.object, a = r.geometry, o = r.material, c = r.group; if (2 === o.side && s.layers.test(i.layers)) { const e = o.side; o.side = mu, o.needsUpdate = !0, Ie(s, n, i, a, o, c), o.side = e, o.needsUpdate = !0, l = !0 } } !0 === l && (J.updateMultisampleRenderTarget(H), J.updateRenderTargetMipmap(H)); _.setRenderTarget(a), _.setClearColor(D, C), _.toneMapping = o }(r, s, t, n), i && K.viewport(M.copy(i)), r.length > 0 && Pe(r, t, n), s.length > 0 && Pe(s, t, n), a.length > 0 && Pe(a, t, n), K.buffers.depth.setTest(!0), K.buffers.depth.setMask(!0), K.buffers.color.setMask(!0), K.setPolygonOffset(!1) } function Pe(e, t, n) { const i = !0 === t.isScene ? t.overrideMaterial : null; for (let r = 0, s = e.length; r < s; r++) { const s = e[r], a = s.object, o = s.geometry, l = null === i ? s.material : i, c = s.group; a.layers.test(n.layers) && Ie(a, t, n, o, l, c) } } function Ie(e, t, n, i, r, s) { e.onBeforeRender(_, t, n, i, r, s), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), r.onBeforeRender(_, t, n, i, e, s), !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = mu, r.needsUpdate = !0, _.renderBufferDirect(n, t, i, r, e, s), r.side = fu, r.needsUpdate = !0, _.renderBufferDirect(n, t, i, r, e, s), r.side = 2) : _.renderBufferDirect(n, t, i, r, e, s), e.onAfterRender(_, t, n, i, r, s) } function Ne(e, t, n) { !0 !== t.isScene && (t = j); const i = Z.get(e), r = m.state.lights, s = m.state.shadowsArray, a = r.state.version, o = re.getParameters(e, r.state, s, t, n), l = re.getProgramCacheKey(o); let c = i.programs; i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = (e.isMeshStandardMaterial ? ee : Q).get(e.envMap || i.environment), i.envMapRotation = null !== i.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation, void 0 === c && (e.addEventListener("dispose", Se), c = new Map, i.programs = c); let u = c.get(l); if (void 0 !== u) { if (i.currentProgram === u && i.lightsStateVersion === a) return Fe(e, o), u } else o.uniforms = re.getUniforms(e), e.onBuild(n, o, _), e.onBeforeCompile(o, _), u = re.acquireProgram(o, l), c.set(l, u), i.uniforms = o.uniforms; const h = i.uniforms; return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = le.uniform), Fe(e, o), i.needsLights = function (e) { return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights }(e), i.lightsStateVersion = a, i.needsLights && (h.ambientLightColor.value = r.state.ambient, h.lightProbe.value = r.state.probe, h.directionalLights.value = r.state.directional, h.directionalLightShadows.value = r.state.directionalShadow, h.spotLights.value = r.state.spot, h.spotLightShadows.value = r.state.spotShadow, h.rectAreaLights.value = r.state.rectArea, h.ltc_1.value = r.state.rectAreaLTC1, h.ltc_2.value = r.state.rectAreaLTC2, h.pointLights.value = r.state.point, h.pointLightShadows.value = r.state.pointShadow, h.hemisphereLights.value = r.state.hemi, h.directionalShadowMap.value = r.state.directionalShadowMap, h.directionalShadowMatrix.value = r.state.directionalShadowMatrix, h.spotShadowMap.value = r.state.spotShadowMap, h.spotLightMatrix.value = r.state.spotLightMatrix, h.spotLightMap.value = r.state.spotLightMap, h.pointShadowMap.value = r.state.pointShadowMap, h.pointShadowMatrix.value = r.state.pointShadowMatrix), i.currentProgram = u, i.uniformsList = null, u } function Oe(e) { if (null === e.uniformsList) { const t = e.currentProgram.getUniforms(); e.uniformsList = Lg.seqWithValue(t.seq, e.uniforms) } return e.uniformsList } function Fe(e, t) { const n = Z.get(e); n.outputColorSpace = t.outputColorSpace, n.batching = t.batching, n.instancing = t.instancing, n.instancingColor = t.instancingColor, n.instancingMorph = t.instancingMorph, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping } Ce.setAnimationLoop((function (e) { we && we(e) })), "undefined" != typeof self && Ce.setContext(self), this.setAnimationLoop = function (e) { we = e, xe.setAnimationLoop(e), null === e ? Ce.stop() : Ce.start() }, xe.addEventListener("sessionstart", Ae), xe.addEventListener("sessionend", De), this.render = function (e, t) { if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === y) return; !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === xe.enabled && !0 === xe.isPresenting && (!0 === xe.cameraAutoUpdate && xe.updateCamera(t), t = xe.getCamera()), !0 === e.isScene && e.onBeforeRender(_, e, t, E), m = oe.get(e, v.length), m.init(), v.push(m), G.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), B.setFromProjectionMatrix(G), z = this.localClippingEnabled, k = le.init(this.clippingPlanes, z), f = ae.get(e, g.length), f.init(), g.push(f), Re(e, t, 0, _.sortObjects), f.finish(), !0 === _.sortObjects && f.sort(I, N), this.info.render.frame++, !0 === k && le.beginShadows(); const n = m.state.shadowsArray; if (ce.render(n, e, t), !0 === k && le.endShadows(), !0 === this.info.autoReset && this.info.reset(), !1 !== xe.enabled && !1 !== xe.isPresenting && !1 !== xe.hasDepthSensing() || ue.render(f, e), m.setupLights(_._useLegacyLights), t.isArrayCamera) { const n = t.cameras; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; Le(f, e, i, i.viewport) } } else Le(f, e, t); null !== E && (J.updateMultisampleRenderTarget(E), J.updateRenderTargetMipmap(E)), !0 === e.isScene && e.onAfterRender(_, e, t), me.resetDefaultState(), T = -1, S = null, v.pop(), m = v.length > 0 ? v[v.length - 1] : null, g.pop(), f = g.length > 0 ? g[g.length - 1] : null }, this.getActiveCubeFace = function () { return x }, this.getActiveMipmapLevel = function () { return b }, this.getRenderTarget = function () { return E }, this.setRenderTargetTextures = function (e, t, n) { Z.get(e.texture).__webglTexture = t, Z.get(e.depthTexture).__webglTexture = n; const i = Z.get(e); i.__hasExternalTextures = !0, i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === q.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i.__useRenderToTexture = !1) }, this.setRenderTargetFramebuffer = function (e, t) { const n = Z.get(e); n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t }, this.setRenderTarget = function (e, t = 0, n = 0) { E = e, x = t, b = n; let i = !0, r = null, s = !1, a = !1; if (e) { const o = Z.get(e); void 0 !== o.__useDefaultFramebuffer ? (K.bindFramebuffer(ve.FRAMEBUFFER, null), i = !1) : void 0 === o.__webglFramebuffer ? J.setupRenderTarget(e) : o.__hasExternalTextures && J.rebindTextures(e, Z.get(e.texture).__webglTexture, Z.get(e.depthTexture).__webglTexture); const l = e.texture; (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (a = !0); const c = Z.get(e).__webglFramebuffer; e.isWebGLCubeRenderTarget ? (r = Array.isArray(c[t]) ? c[t][n] : c[t], s = !0) : r = Y.isWebGL2 && e.samples > 0 && !1 === J.useMultisampledRTT(e) ? Z.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c, M.copy(e.viewport), w.copy(e.scissor), A = e.scissorTest } else M.copy(O).multiplyScalar(P).floor(), w.copy(F).multiplyScalar(P).floor(), A = U; if (K.bindFramebuffer(ve.FRAMEBUFFER, r) && Y.drawBuffers && i && K.drawBuffers(e, r), K.viewport(M), K.scissor(w), K.setScissorTest(A), s) { const i = Z.get(e.texture); ve.framebufferTexture2D(ve.FRAMEBUFFER, ve.COLOR_ATTACHMENT0, ve.TEXTURE_CUBE_MAP_POSITIVE_X + t, i.__webglTexture, n) } else if (a) { const i = Z.get(e.texture), r = t || 0; ve.framebufferTextureLayer(ve.FRAMEBUFFER, ve.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r) } T = -1 }, this.readRenderTargetPixels = function (e, t, n, i, r, s, a) { if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let o = Z.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) { K.bindFramebuffer(ve.FRAMEBUFFER, o); try { const a = e.texture, o = a.format, l = a.type; if (o !== $u && fe.convert(o) !== ve.getParameter(ve.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); const c = l === Yu && (q.has("EXT_color_buffer_half_float") || Y.isWebGL2 && q.has("EXT_color_buffer_float")); if (!(l === Vu || fe.convert(l) === ve.getParameter(ve.IMPLEMENTATION_COLOR_READ_TYPE) || l === qu && (Y.isWebGL2 || q.has("OES_texture_float") || q.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && ve.readPixels(t, n, i, r, fe.convert(o), fe.convert(l), s) } finally { const e = null !== E ? Z.get(E).__webglFramebuffer : null; K.bindFramebuffer(ve.FRAMEBUFFER, e) } } }, this.copyFramebufferToTexture = function (e, t, n = 0) { const i = Math.pow(2, -n), r = Math.floor(t.image.width * i), s = Math.floor(t.image.height * i); J.setTexture2D(t, 0), ve.copyTexSubImage2D(ve.TEXTURE_2D, n, 0, 0, e.x, e.y, r, s), K.unbindTexture() }, this.copyTextureToTexture = function (e, t, n, i = 0) { const r = t.image.width, s = t.image.height, a = fe.convert(n.format), o = fe.convert(n.type); J.setTexture2D(n, 0), ve.pixelStorei(ve.UNPACK_FLIP_Y_WEBGL, n.flipY), ve.pixelStorei(ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), ve.pixelStorei(ve.UNPACK_ALIGNMENT, n.unpackAlignment), t.isDataTexture ? ve.texSubImage2D(ve.TEXTURE_2D, i, e.x, e.y, r, s, a, o, t.image.data) : t.isCompressedTexture ? ve.compressedTexSubImage2D(ve.TEXTURE_2D, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : ve.texSubImage2D(ve.TEXTURE_2D, i, e.x, e.y, a, o, t.image), 0 === i && n.generateMipmaps && ve.generateMipmap(ve.TEXTURE_2D), K.unbindTexture() }, this.copyTextureToTexture3D = function (e, t, n, i, r = 0) { if (_.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); const s = Math.round(e.max.x - e.min.x), a = Math.round(e.max.y - e.min.y), o = e.max.z - e.min.z + 1, l = fe.convert(i.format), c = fe.convert(i.type); let u; if (i.isData3DTexture) J.setTexture3D(i, 0), u = ve.TEXTURE_3D; else { if (!i.isDataArrayTexture && !i.isCompressedArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); J.setTexture2DArray(i, 0), u = ve.TEXTURE_2D_ARRAY } ve.pixelStorei(ve.UNPACK_FLIP_Y_WEBGL, i.flipY), ve.pixelStorei(ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), ve.pixelStorei(ve.UNPACK_ALIGNMENT, i.unpackAlignment); const h = ve.getParameter(ve.UNPACK_ROW_LENGTH), d = ve.getParameter(ve.UNPACK_IMAGE_HEIGHT), p = ve.getParameter(ve.UNPACK_SKIP_PIXELS), f = ve.getParameter(ve.UNPACK_SKIP_ROWS), m = ve.getParameter(ve.UNPACK_SKIP_IMAGES), g = n.isCompressedTexture ? n.mipmaps[r] : n.image; ve.pixelStorei(ve.UNPACK_ROW_LENGTH, g.width), ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT, g.height), ve.pixelStorei(ve.UNPACK_SKIP_PIXELS, e.min.x), ve.pixelStorei(ve.UNPACK_SKIP_ROWS, e.min.y), ve.pixelStorei(ve.UNPACK_SKIP_IMAGES, e.min.z), n.isDataTexture || n.isData3DTexture ? ve.texSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, c, g.data) : i.isCompressedArrayTexture ? ve.compressedTexSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, g.data) : ve.texSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, c, g), ve.pixelStorei(ve.UNPACK_ROW_LENGTH, h), ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT, d), ve.pixelStorei(ve.UNPACK_SKIP_PIXELS, p), ve.pixelStorei(ve.UNPACK_SKIP_ROWS, f), ve.pixelStorei(ve.UNPACK_SKIP_IMAGES, m), 0 === r && i.generateMipmaps && ve.generateMipmap(u), K.unbindTexture() }, this.initTexture = function (e) { e.isCubeTexture ? J.setTextureCube(e, 0) : e.isData3DTexture ? J.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? J.setTexture2DArray(e, 0) : J.setTexture2D(e, 0), K.unbindTexture() }, this.resetState = function () { x = 0, b = 0, E = null, K.reset(), me.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } get coordinateSystem() { return Th } get outputColorSpace() { return this._outputColorSpace } set outputColorSpace(e) { this._outputColorSpace = e; const t = this.getContext(); t.drawingBufferColorSpace = e === ph ? "display-p3" : "srgb", t.unpackColorSpace = Zh.workingColorSpace === fh ? "display-p3" : "srgb" } get useLegacyLights() { return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights } set useLegacyLights(e) { console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e } } (class extends Av { }).prototype.isWebGL1Renderer = !0; class Dv extends gp { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Qd, this.environmentRotation = new Qd, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentRotation.copy(e.environmentRotation), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), t.object.environmentRotation = this.environmentRotation.toArray(), t } } class Cv { constructor(e, t) { this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = xh, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = Rh() } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } get updateRange() { return Xh("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange } setUsage(e) { return this.usage = e, this } addUpdateRange(e, t) { this.updateRanges.push({ start: e, count: t }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, n) { e *= this.stride, n *= t.stride; for (let i = 0, r = this.stride; i < r; i++)this.array[e + i] = t.array[n + i]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Rh()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride); return n.setUsage(this.usage), n } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Rh()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const Rv = new pd; class Lv { constructor(e, t, n, i = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, n = this.data.count; t < n; t++)Rv.fromBufferAttribute(this, t), Rv.applyMatrix4(e), this.setXYZ(t, Rv.x, Rv.y, Rv.z); return this } applyNormalMatrix(e) { for (let t = 0, n = this.count; t < n; t++)Rv.fromBufferAttribute(this, t), Rv.applyNormalMatrix(e), this.setXYZ(t, Rv.x, Rv.y, Rv.z); return this } transformDirection(e) { for (let t = 0, n = this.count; t < n; t++)Rv.fromBufferAttribute(this, t), Rv.transformDirection(e), this.setXYZ(t, Rv.x, Rv.y, Rv.z); return this } getComponent(e, t) { let n = this.array[e * this.data.stride + this.offset + t]; return this.normalized && (n = Fh(n, this.array)), n } setComponent(e, t, n) { return this.normalized && (n = Uh(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this } setX(e, t) { return this.normalized && (t = Uh(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.normalized && (t = Uh(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.normalized && (t = Uh(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.normalized && (t = Uh(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { let t = this.data.array[e * this.data.stride + this.offset]; return this.normalized && (t = Fh(t, this.array)), t } getY(e) { let t = this.data.array[e * this.data.stride + this.offset + 1]; return this.normalized && (t = Fh(t, this.array)), t } getZ(e) { let t = this.data.array[e * this.data.stride + this.offset + 2]; return this.normalized && (t = Fh(t, this.array)), t } getW(e) { let t = this.data.array[e * this.data.stride + this.offset + 3]; return this.normalized && (t = Fh(t, this.array)), t } setXY(e, t, n) { return e = e * this.data.stride + this.offset, this.normalized && (t = Uh(t, this.array), n = Uh(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this } setXYZ(e, t, n, i) { return e = e * this.data.stride + this.offset, this.normalized && (t = Uh(t, this.array), n = Uh(n, this.array), i = Uh(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this } setXYZW(e, t, n, i, r) { return e = e * this.data.stride + this.offset, this.normalized && (t = Uh(t, this.array), n = Uh(n, this.array), i = Uh(i, this.array), r = Uh(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this } clone(e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); const e = []; for (let t = 0; t < this.count; t++) { const n = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[n + t]) } return new kp(new this.array.constructor(e), this.itemSize, this.normalized) } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Lv(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); const e = []; for (let t = 0; t < this.count; t++) { const n = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[n + t]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized } } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } const Pv = new pd, Iv = new od, Nv = new od, Ov = new pd, Fv = new Vd, Uv = new pd, Bv = new Nd, kv = new Vd, zv = new Gd; class Hv extends mf { constructor(e, t) { super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = Du, this.bindMatrix = new Vd, this.bindMatrixInverse = new Vd, this.boundingBox = null, this.boundingSphere = null } computeBoundingBox() { const e = this.geometry; null === this.boundingBox && (this.boundingBox = new gd), this.boundingBox.makeEmpty(); const t = e.getAttribute("position"); for (let e = 0; e < t.count; e++)this.getVertexPosition(e, Uv), this.boundingBox.expandByPoint(Uv) } computeBoundingSphere() { const e = this.geometry; null === this.boundingSphere && (this.boundingSphere = new Nd), this.boundingSphere.makeEmpty(); const t = e.getAttribute("position"); for (let e = 0; e < t.count; e++)this.getVertexPosition(e, Uv), this.boundingSphere.expandByPoint(Uv) } copy(e, t) { return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this } raycast(e, t) { const n = this.material, i = this.matrixWorld; void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), Bv.copy(this.boundingSphere), Bv.applyMatrix4(i), !1 !== e.ray.intersectsSphere(Bv) && (kv.copy(i).invert(), zv.copy(e.ray).applyMatrix4(kv), null !== this.boundingBox && !1 === zv.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, zv))) } getVertexPosition(e, t) { return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t } bind(e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new od, t = this.geometry.attributes.skinWeight; for (let n = 0, i = t.count; n < i; n++) { e.fromBufferAttribute(t, n); const i = 1 / e.manhattanLength(); i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.bindMode === Du ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } applyBoneTransform(e, t) { const n = this.skeleton, i = this.geometry; Iv.fromBufferAttribute(i.attributes.skinIndex, e), Nv.fromBufferAttribute(i.attributes.skinWeight, e), Pv.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let e = 0; e < 4; e++) { const i = Nv.getComponent(e); if (0 !== i) { const r = Iv.getComponent(e); Fv.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(Ov.copy(Pv).applyMatrix4(Fv), i) } } return t.applyMatrix4(this.bindMatrixInverse) } } class Gv extends gp { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class Vv extends ad { constructor(e = null, t = 1, n = 1, i, r, s, a, o, l = 1003, c = 1003, u, h) { super(null, s, a, o, l, c, i, r, u, h), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const Wv = new Vd, jv = new Vd; class Xv { constructor(e = [], t = []) { this.uuid = Rh(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let e = 0, t = this.bones.length; e < t; e++)this.boneInverses.push(new Vd) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const t = new Vd; this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && t.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) } } update() { const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture; for (let i = 0, r = e.length; i < r; i++) { const r = e[i] ? e[i].matrixWorld : jv; Wv.multiplyMatrices(r, t[i]), Wv.toArray(n, 16 * i) } null !== i && (i.needsUpdate = !0) } clone() { return new Xv(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(4 * this.bones.length); e = 4 * Math.ceil(e / 4), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); const n = new Vv(t, e, e, $u, qu); return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this } getBoneByName(e) { for (let t = 0, n = this.bones.length; t < n; t++) { const n = this.bones[t]; if (n.name === e) return n } } dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let n = 0, i = e.bones.length; n < i; n++) { const i = e.bones[n]; let r = t[i]; void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Gv), this.bones.push(r), this.boneInverses.push((new Vd).fromArray(e.boneInverses[n])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, n = this.boneInverses; for (let i = 0, r = t.length; i < r; i++) { const r = t[i]; e.bones.push(r.uuid); const s = n[i]; e.boneInverses.push(s.toArray()) } return e } } class qv extends kp { constructor(e, t, n, i = 1) { super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } const Yv = new Vd, Kv = new Vd, $v = [], Zv = new gd, Jv = new Vd, Qv = new mf, e_ = new Nd; class t_ extends mf { constructor(e, t, n) { super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new qv(new Float32Array(16 * n), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null; for (let e = 0; e < n; e++)this.setMatrixAt(e, Jv) } computeBoundingBox() { const e = this.geometry, t = this.count; null === this.boundingBox && (this.boundingBox = new gd), null === e.boundingBox && e.computeBoundingBox(), this.boundingBox.makeEmpty(); for (let n = 0; n < t; n++)this.getMatrixAt(n, Yv), Zv.copy(e.boundingBox).applyMatrix4(Yv), this.boundingBox.union(Zv) } computeBoundingSphere() { const e = this.geometry, t = this.count; null === this.boundingSphere && (this.boundingSphere = new Nd), null === e.boundingSphere && e.computeBoundingSphere(), this.boundingSphere.makeEmpty(); for (let n = 0; n < t; n++)this.getMatrixAt(n, Yv), e_.copy(e.boundingSphere).applyMatrix4(Yv), this.boundingSphere.union(e_) } copy(e, t) { return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, 3 * e) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, 16 * e) } getMorphAt(e, t) { const n = t.morphTargetInfluences, i = this.morphTexture.source.data.data, r = e * (n.length + 1) + 1; for (let e = 0; e < n.length; e++)n[e] = i[r + e] } raycast(e, t) { const n = this.matrixWorld, i = this.count; if (Qv.geometry = this.geometry, Qv.material = this.material, void 0 !== Qv.material && (null === this.boundingSphere && this.computeBoundingSphere(), e_.copy(this.boundingSphere), e_.applyMatrix4(n), !1 !== e.ray.intersectsSphere(e_))) for (let r = 0; r < i; r++) { this.getMatrixAt(r, Yv), Kv.multiplyMatrices(n, Yv), Qv.matrixWorld = Kv, Qv.raycast(e, $v); for (let e = 0, n = $v.length; e < n; e++) { const n = $v[e]; n.instanceId = r, n.object = this, t.push(n) } $v.length = 0 } } setColorAt(e, t) { null === this.instanceColor && (this.instanceColor = new qv(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, 16 * e) } setMorphAt(e, t) { const n = t.morphTargetInfluences, i = n.length + 1; null === this.morphTexture && (this.morphTexture = new Vv(new Float32Array(i * this.count), i, this.count, 1028, qu)); const r = this.morphTexture.source.data.data; let s = 0; for (let e = 0; e < n.length; e++)s += n[e]; const a = this.geometry.morphTargetsRelative ? 1 : 1 - s, o = i * e; r[o] = a, r.set(n, o + 1) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } } class n_ extends Op { constructor(e) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Pp(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this } } const i_ = new pd, r_ = new pd, s_ = new Vd, a_ = new Gd, o_ = new Nd; class l_ extends gp { constructor(e = new $p, t = new n_) { super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (null === e.index) { const t = e.attributes.position, n = [0]; for (let e = 1, i = t.count; e < i; e++)i_.fromBufferAttribute(t, e - 1), r_.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += i_.distanceTo(r_); e.setAttribute("lineDistance", new Gp(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(e, t) { const n = this.geometry, i = this.matrixWorld, r = e.params.Line.threshold, s = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), o_.copy(n.boundingSphere), o_.applyMatrix4(i), o_.radius += r, !1 === e.ray.intersectsSphere(o_)) return; s_.copy(i).invert(), a_.copy(e.ray).applyMatrix4(s_); const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a, l = new pd, c = new pd, u = new pd, h = new pd, d = this.isLineSegments ? 2 : 1, p = n.index, f = n.attributes.position; if (null !== p) { for (let n = Math.max(0, s.start), i = Math.min(p.count, s.start + s.count) - 1; n < i; n += d) { const i = p.getX(n), r = p.getX(n + 1); l.fromBufferAttribute(f, i), c.fromBufferAttribute(f, r); if (a_.distanceSqToSegment(l, c, h, u) > o) continue; h.applyMatrix4(this.matrixWorld); const s = e.ray.origin.distanceTo(h); s < e.near || s > e.far || t.push({ distance: s, point: u.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } else { for (let n = Math.max(0, s.start), i = Math.min(f.count, s.start + s.count) - 1; n < i; n += d) { l.fromBufferAttribute(f, n), c.fromBufferAttribute(f, n + 1); if (a_.distanceSqToSegment(l, c, h, u) > o) continue; h.applyMatrix4(this.matrixWorld); const i = e.ray.origin.distanceTo(h); i < e.near || i > e.far || t.push({ distance: i, point: u.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } } updateMorphTargets() { const e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { const n = e[t[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = n.length; e < t; e++) { const t = n[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e } } } } } const c_ = new pd, u_ = new pd; class h_ extends l_ { constructor(e, t) { super(e, t), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (null === e.index) { const t = e.attributes.position, n = []; for (let e = 0, i = t.count; e < i; e += 2)c_.fromBufferAttribute(t, e), u_.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + c_.distanceTo(u_); e.setAttribute("lineDistance", new Gp(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class d_ extends l_ { constructor(e, t) { super(e, t), this.isLineLoop = !0, this.type = "LineLoop" } } class p_ extends Op { constructor(e) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Pp(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } const f_ = new Vd, m_ = new Gd, g_ = new Nd, v_ = new pd; class __ extends gp { constructor(e = new $p, t = new p_) { super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } raycast(e, t) { const n = this.geometry, i = this.matrixWorld, r = e.params.Points.threshold, s = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), g_.copy(n.boundingSphere), g_.applyMatrix4(i), g_.radius += r, !1 === e.ray.intersectsSphere(g_)) return; f_.copy(i).invert(), m_.copy(e.ray).applyMatrix4(f_); const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a, l = n.index, c = n.attributes.position; if (null !== l) { for (let n = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count); n < r; n++) { const r = l.getX(n); v_.fromBufferAttribute(c, r), y_(v_, r, o, i, e, t, this) } } else { for (let n = Math.max(0, s.start), r = Math.min(c.count, s.start + s.count); n < r; n++)v_.fromBufferAttribute(c, n), y_(v_, n, o, i, e, t, this) } } updateMorphTargets() { const e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { const n = e[t[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = n.length; e < t; e++) { const t = n[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e } } } } } function y_(e, t, n, i, r, s, a) { const o = m_.distanceSqToPoint(e); if (o < n) { const n = new pd; m_.closestPointToPoint(e, n), n.applyMatrix4(i); const l = r.ray.origin.distanceTo(n); if (l < r.near || l > r.far) return; s.push({ distance: l, distanceToRay: Math.sqrt(o), point: n, index: t, face: null, object: a }) } } class x_ extends Op { constructor(e) { super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Pp(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pp(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new kh(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qd, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class b_ extends x_ { constructor(e) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new kh(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return Lh(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (e) { this.ior = (1 + .4 * e) / (1 - .4 * e) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Pp(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Pp(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Pp(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e) } get anisotropy() { return this._anisotropy } set anisotropy(e) { this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get iridescence() { return this._iridescence } set iridescence(e) { this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } function E_(e, t, n) { return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) } function T_(e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) } function S_(e) { const t = e.length, n = new Array(t); for (let e = 0; e !== t; ++e)n[e] = e; return n.sort((function (t, n) { return e[t] - e[n] })), n } function M_(e, t, n) { const i = e.length, r = new e.constructor(i); for (let s = 0, a = 0; a !== i; ++s) { const i = n[s] * t; for (let n = 0; n !== t; ++n)r[a++] = e[i + n] } return r } function w_(e, t, n, i) { let r = 1, s = e[0]; for (; void 0 !== s && void 0 === s[i];)s = e[r++]; if (void 0 === s) return; let a = s[i]; if (void 0 !== a) if (Array.isArray(a)) do { a = s[i], void 0 !== a && (t.push(s.time), n.push.apply(n, a)), s = e[r++] } while (void 0 !== s); else if (void 0 !== a.toArray) do { a = s[i], void 0 !== a && (t.push(s.time), a.toArray(n, n.length)), s = e[r++] } while (void 0 !== s); else do { a = s[i], void 0 !== a && (t.push(s.time), n.push(a)), s = e[r++] } while (void 0 !== s) } class A_ { constructor(e, t, n, i) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const t = this.parameterPositions; let n = this._cachedIndex, i = t[n], r = t[n - 1]; e: { t: { let s; n: { i: if (!(e < i)) { for (let s = n + 2; ;) { if (void 0 === i) { if (e < r) break i; return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1) } if (n === s) break; if (r = i, i = t[++n], e < i) break t } s = t.length; break n } if (e >= r) break e; { const a = t[1]; e < a && (n = 2, r = a); for (let s = n - 2; ;) { if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0); if (n === s) break; if (i = r, r = t[--n - 1], e >= r) break t } s = n, n = 0 } } for (; n < s;) { const i = n + s >>> 1; e < t[i] ? s = i : n = i + 1 } if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0); if (void 0 === i) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1) } this._cachedIndex = n, this.intervalChanged_(n, r, i) } return this.interpolate_(n, r, e, i) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i; for (let e = 0; e !== i; ++e)t[e] = n[r + e]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class D_ extends A_ { constructor(e, t, n, i) { super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: oh, endingEnd: oh } } intervalChanged_(e, t, n) { const i = this.parameterPositions; let r = e - 2, s = e + 1, a = i[r], o = i[s]; if (void 0 === a) switch (this.getSettings_().endingStart) { case lh: r = e, a = 2 * t - n; break; case ch: r = i.length - 2, a = t + i[r] - i[r + 1]; break; default: r = e, a = n }if (void 0 === o) switch (this.getSettings_().endingEnd) { case lh: s = e, o = 2 * n - t; break; case ch: s = 1, o = n + i[1] - i[0]; break; default: s = e - 1, o = t }const l = .5 * (n - t), c = this.valueSize; this._weightPrev = l / (t - a), this._weightNext = l / (o - n), this._offsetPrev = r * c, this._offsetNext = s * c } interpolate_(e, t, n, i) { const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = o - a, c = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - t) / (i - t), f = p * p, m = f * p, g = -h * m + 2 * h * f - h * p, v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, _ = (-1 - d) * m + (1.5 + d) * f + .5 * p, y = d * m - d * f; for (let e = 0; e !== a; ++e)r[e] = g * s[c + e] + v * s[l + e] + _ * s[o + e] + y * s[u + e]; return r } } class C_ extends A_ { constructor(e, t, n, i) { super(e, t, n, i) } interpolate_(e, t, n, i) { const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = o - a, c = (n - t) / (i - t), u = 1 - c; for (let e = 0; e !== a; ++e)r[e] = s[l + e] * u + s[o + e] * c; return r } } class R_ extends A_ { constructor(e, t, n, i) { super(e, t, n, i) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class L_ { constructor(e, t, n, i) { if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = E_(t, this.TimeBufferType), this.values = E_(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let n; if (t.toJSON !== this.toJSON) n = t.toJSON(e); else { n = { name: e.name, times: E_(e.times, Array), values: E_(e.values, Array) }; const t = e.getInterpolation(); t !== e.DefaultInterpolation && (n.interpolation = t) } return n.type = e.ValueTypeName, n } InterpolantFactoryMethodDiscrete(e) { return new R_(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new C_(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new D_(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case rh: t = this.InterpolantFactoryMethodDiscrete; break; case sh: t = this.InterpolantFactoryMethodLinear; break; case ah: t = this.InterpolantFactoryMethodSmooth }if (void 0 === t) { const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw new Error(t); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", t), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return rh; case this.InterpolantFactoryMethodLinear: return sh; case this.InterpolantFactoryMethodSmooth: return ah } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (0 !== e) { const t = this.times; for (let n = 0, i = t.length; n !== i; ++n)t[n] += e } return this } scale(e) { if (1 !== e) { const t = this.times; for (let n = 0, i = t.length; n !== i; ++n)t[n] *= e } return this } trim(e, t) { const n = this.times, i = n.length; let r = 0, s = i - 1; for (; r !== i && n[r] < e;)++r; for (; -1 !== s && n[s] > t;)--s; if (++s, 0 !== r || s !== i) { r >= s && (s = Math.max(s, 1), r = s - 1); const e = this.getValueSize(); this.times = n.slice(r, s), this.values = this.values.slice(r * e, s * e) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const n = this.times, i = this.values, r = n.length; 0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let s = null; for (let t = 0; t !== r; t++) { const i = n[t]; if ("number" == typeof i && isNaN(i)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, i), e = !1; break } if (null !== s && s > i) { console.error("THREE.KeyframeTrack: Out of order keys.", this, t, i, s), e = !1; break } s = i } if (void 0 !== i && T_(i)) for (let t = 0, n = i.length; t !== n; ++t) { const n = i[t]; if (isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n), e = !1; break } } return e } optimize() { const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === ah, r = e.length - 1; let s = 1; for (let a = 1; a < r; ++a) { let r = !1; const o = e[a]; if (o !== e[a + 1] && (1 !== a || o !== e[0])) if (i) r = !0; else { const e = a * n, i = e - n, s = e + n; for (let a = 0; a !== n; ++a) { const n = t[e + a]; if (n !== t[i + a] || n !== t[s + a]) { r = !0; break } } } if (r) { if (a !== s) { e[s] = e[a]; const i = a * n, r = s * n; for (let e = 0; e !== n; ++e)t[r + e] = t[i + e] } ++s } } if (r > 0) { e[s] = e[r]; for (let e = r * n, i = s * n, a = 0; a !== n; ++a)t[i + a] = t[e + a]; ++s } return s !== e.length ? (this.times = e.slice(0, s), this.values = t.slice(0, s * n)) : (this.times = e, this.values = t), this } clone() { const e = this.times.slice(), t = this.values.slice(), n = new (0, this.constructor)(this.name, e, t); return n.createInterpolant = this.createInterpolant, n } } L_.prototype.TimeBufferType = Float32Array, L_.prototype.ValueBufferType = Float32Array, L_.prototype.DefaultInterpolation = sh; class P_ extends L_ { } P_.prototype.ValueTypeName = "bool", P_.prototype.ValueBufferType = Array, P_.prototype.DefaultInterpolation = rh, P_.prototype.InterpolantFactoryMethodLinear = void 0, P_.prototype.InterpolantFactoryMethodSmooth = void 0; class I_ extends L_ { } I_.prototype.ValueTypeName = "color"; class N_ extends L_ { } N_.prototype.ValueTypeName = "number"; class O_ extends A_ { constructor(e, t, n, i) { super(e, t, n, i) } interpolate_(e, t, n, i) { const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = (n - t) / (i - t); let l = e * a; for (let e = l + a; l !== e; l += 4)dd.slerpFlat(r, 0, s, l - a, s, l, o); return r } } class F_ extends L_ { InterpolantFactoryMethodLinear(e) { return new O_(this.times, this.values, this.getValueSize(), e) } } F_.prototype.ValueTypeName = "quaternion", F_.prototype.DefaultInterpolation = sh, F_.prototype.InterpolantFactoryMethodSmooth = void 0; class U_ extends L_ { } U_.prototype.ValueTypeName = "string", U_.prototype.ValueBufferType = Array, U_.prototype.DefaultInterpolation = rh, U_.prototype.InterpolantFactoryMethodLinear = void 0, U_.prototype.InterpolantFactoryMethodSmooth = void 0; class B_ extends L_ { } B_.prototype.ValueTypeName = "vector"; class k_ { constructor(e, t = -1, n, i = 2500) { this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = Rh(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], n = e.tracks, i = 1 / (e.fps || 1); for (let e = 0, r = n.length; e !== r; ++e)t.push(z_(n[e]).scale(i)); const r = new this(e.name, e.duration, t, e.blendMode); return r.uuid = e.uuid, r } static toJSON(e) { const t = [], n = e.tracks, i = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let e = 0, i = n.length; e !== i; ++e)t.push(L_.toJSON(n[e])); return i } static CreateFromMorphTargetSequence(e, t, n, i) { const r = t.length, s = []; for (let e = 0; e < r; e++) { let a = [], o = []; a.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0); const l = S_(a); a = M_(a, 1, l), o = M_(o, 1, l), i || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new N_(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(1 / n)) } return new this(e, -1, s) } static findByName(e, t) { let n = e; if (!Array.isArray(e)) { const t = e; n = t.geometry && t.geometry.animations || t.animations } for (let e = 0; e < n.length; e++)if (n[e].name === t) return n[e]; return null } static CreateClipsFromMorphTargetSequences(e, t, n) { const i = {}, r = /^([\w-]*?)([\d]+)$/; for (let t = 0, n = e.length; t < n; t++) { const n = e[t], s = n.name.match(r); if (s && s.length > 1) { const e = s[1]; let t = i[e]; t || (i[e] = t = []), t.push(n) } } const s = []; for (const e in i) s.push(this.CreateFromMorphTargetSequence(e, i[e], t, n)); return s } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const n = function (e, t, n, i, r) { if (0 !== n.length) { const s = [], a = []; w_(n, s, a, i), 0 !== s.length && r.push(new e(t, s, a)) } }, i = [], r = e.name || "default", s = e.fps || 30, a = e.blendMode; let o = e.length || -1; const l = e.hierarchy || []; for (let e = 0; e < l.length; e++) { const r = l[e].keys; if (r && 0 !== r.length) if (r[0].morphTargets) { const e = {}; let t; for (t = 0; t < r.length; t++)if (r[t].morphTargets) for (let n = 0; n < r[t].morphTargets.length; n++)e[r[t].morphTargets[n]] = -1; for (const n in e) { const e = [], s = []; for (let i = 0; i !== r[t].morphTargets.length; ++i) { const i = r[t]; e.push(i.time), s.push(i.morphTarget === n ? 1 : 0) } i.push(new N_(".morphTargetInfluence[" + n + "]", e, s)) } o = e.length * s } else { const s = ".bones[" + t[e].name + "]"; n(B_, s + ".position", r, "pos", i), n(F_, s + ".quaternion", r, "rot", i), n(B_, s + ".scale", r, "scl", i) } } if (0 === i.length) return null; return new this(r, o, i, a) } resetDuration() { let e = 0; for (let t = 0, n = this.tracks.length; t !== n; ++t) { const n = this.tracks[t]; e = Math.max(e, n.times[n.times.length - 1]) } return this.duration = e, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function z_(e) { if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const t = function (e) { switch (e.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return N_; case "vector": case "vector2": case "vector3": case "vector4": return B_; case "color": return I_; case "quaternion": return F_; case "bool": case "boolean": return P_; case "string": return U_ }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { const t = [], n = []; w_(e.keys, t, n, "value"), e.times = t, e.values = n } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) } const H_ = { enabled: !1, files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }; class G_ { constructor(e, t, n) { const i = this; let r, s = !1, a = 0, o = 0; const l = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) { o++, !1 === s && void 0 !== i.onStart && i.onStart(e, a, o), s = !0 }, this.itemEnd = function (e) { a++, void 0 !== i.onProgress && i.onProgress(e, a, o), a === o && (s = !1, void 0 !== i.onLoad && i.onLoad()) }, this.itemError = function (e) { void 0 !== i.onError && i.onError(e) }, this.resolveURL = function (e) { return r ? r(e) : e }, this.setURLModifier = function (e) { return r = e, this }, this.addHandler = function (e, t) { return l.push(e, t), this }, this.removeHandler = function (e) { const t = l.indexOf(e); return -1 !== t && l.splice(t, 2), this }, this.getHandler = function (e) { for (let t = 0, n = l.length; t < n; t += 2) { const n = l[t], i = l[t + 1]; if (n.global && (n.lastIndex = 0), n.test(e)) return i } return null } } } const V_ = new G_; class W_ { constructor(e) { this.manager = void 0 !== e ? e : V_, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const n = this; return new Promise((function (i, r) { n.load(e, i, t, r) })) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } W_.DEFAULT_MATERIAL_NAME = "__DEFAULT"; const j_ = {}; class X_ extends Error { constructor(e, t) { super(e), this.response = t } } class q_ extends W_ { constructor(e) { super(e) } load(e, t, n, i) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = H_.get(e); if (void 0 !== r) return this.manager.itemStart(e), setTimeout((() => { t && t(r), this.manager.itemEnd(e) }), 0), r; if (void 0 !== j_[e]) return void j_[e].push({ onLoad: t, onProgress: n, onError: i }); j_[e] = [], j_[e].push({ onLoad: t, onProgress: n, onError: i }); const s = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a = this.mimeType, o = this.responseType; fetch(s).then((t => { if (200 === t.status || 0 === t.status) { if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t; const n = j_[e], i = t.body.getReader(), r = t.headers.get("Content-Length") || t.headers.get("X-File-Size"), s = r ? parseInt(r) : 0, a = 0 !== s; let o = 0; const l = new ReadableStream({ start(e) { !function t() { i.read().then((({ done: i, value: r }) => { if (i) e.close(); else { o += r.byteLength; const i = new ProgressEvent("progress", { lengthComputable: a, loaded: o, total: s }); for (let e = 0, t = n.length; e < t; e++) { const t = n[e]; t.onProgress && t.onProgress(i) } e.enqueue(r), t() } })) }() } }); return new Response(l) } throw new X_(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t) })).then((e => { switch (o) { case "arraybuffer": return e.arrayBuffer(); case "blob": return e.blob(); case "document": return e.text().then((e => (new DOMParser).parseFromString(e, a))); case "json": return e.json(); default: if (void 0 === a) return e.text(); { const t = /charset="?([^;"\s]*)"?/i.exec(a), n = t && t[1] ? t[1].toLowerCase() : void 0, i = new TextDecoder(n); return e.arrayBuffer().then((e => i.decode(e))) } } })).then((t => { H_.add(e, t); const n = j_[e]; delete j_[e]; for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; i.onLoad && i.onLoad(t) } })).catch((t => { const n = j_[e]; if (void 0 === n) throw this.manager.itemError(e), t; delete j_[e]; for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; i.onError && i.onError(t) } this.manager.itemError(e) })).finally((() => { this.manager.itemEnd(e) })), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class Y_ extends W_ { constructor(e) { super(e) } load(e, t, n, i) { void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = this, s = H_.get(e); if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function () { t && t(s), r.manager.itemEnd(e) }), 0), s; const a = Vh("img"); function o() { c(), H_.add(e, this), t && t(this), r.manager.itemEnd(e) } function l(t) { c(), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e) } function c() { a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1) } return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a } } class K_ extends W_ { constructor(e) { super(e) } load(e, t, n, i) { const r = new ad, s = new Y_(this.manager); return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, (function (e) { r.image = e, r.needsUpdate = !0, void 0 !== t && t(r) }), n, i), r } } class $_ extends gp { constructor(e, t = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new Pp(e), this.intensity = t } dispose() { } copy(e, t) { return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } } const Z_ = new Vd, J_ = new pd, Q_ = new pd; class ey { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new kh(512, 512), this.map = null, this.mapPass = null, this.matrix = new Vd, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Bf, this._frameExtents = new kh(1, 1), this._viewportCount = 1, this._viewports = [new od(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, n = this.matrix; J_.setFromMatrixPosition(e.matrixWorld), t.position.copy(J_), Q_.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Q_), t.updateMatrixWorld(), Z_.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Z_), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(Z_) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = {}; return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class ty extends ey { constructor() { super(new Af(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices(e) { const t = this.camera, n = 2 * Ch * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = e.distance || t.far; n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } class ny extends $_ { constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 2) { super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(gp.DEFAULT_UP), this.updateMatrix(), this.target = new gp, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.map = null, this.shadow = new ty } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } const iy = new Vd, ry = new pd, sy = new pd; class ay extends ey { constructor() { super(new Af(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new kh(4, 2), this._viewportCount = 6, this._viewports = [new od(2, 1, 1, 1), new od(0, 1, 1, 1), new od(3, 1, 1, 1), new od(1, 1, 1, 1), new od(3, 0, 1, 1), new od(1, 0, 1, 1)], this._cubeDirections = [new pd(1, 0, 0), new pd(-1, 0, 0), new pd(0, 0, 1), new pd(0, 0, -1), new pd(0, 1, 0), new pd(0, -1, 0)], this._cubeUps = [new pd(0, 1, 0), new pd(0, 1, 0), new pd(0, 1, 0), new pd(0, 1, 0), new pd(0, 0, 1), new pd(0, 0, -1)] } updateMatrices(e, t = 0) { const n = this.camera, i = this.matrix, r = e.distance || n.far; r !== n.far && (n.far = r, n.updateProjectionMatrix()), ry.setFromMatrixPosition(e.matrixWorld), n.position.copy(ry), sy.copy(n.position), sy.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(sy), n.updateMatrixWorld(), i.makeTranslation(-ry.x, -ry.y, -ry.z), iy.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(iy) } } class oy extends $_ { constructor(e, t, n = 0, i = 2) { super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new ay } get power() { return 4 * this.intensity * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } class ly extends ey { constructor() { super(new em(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class cy extends $_ { constructor(e, t) { super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(gp.DEFAULT_UP), this.updateMatrix(), this.target = new gp, this.shadow = new ly } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } class uy extends $_ { constructor(e, t) { super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight" } } class hy { static decodeText(e) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); let t = ""; for (let n = 0, i = e.length; n < i; n++)t += String.fromCharCode(e[n]); try { return decodeURIComponent(escape(t)) } catch (e) { return t } } static extractUrlBase(e) { const t = e.lastIndexOf("/"); return -1 === t ? "./" : e.slice(0, t + 1) } static resolveURL(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } } class dy extends W_ { constructor(e) { super(e), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, n, i) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = this, s = H_.get(e); if (void 0 !== s) return r.manager.itemStart(e), s.then ? void s.then((n => { t && t(n), r.manager.itemEnd(e) })).catch((e => { i && i(e) })) : (setTimeout((function () { t && t(s), r.manager.itemEnd(e) }), 0), s); const a = {}; a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader; const o = fetch(e, a).then((function (e) { return e.blob() })).then((function (e) { return createImageBitmap(e, Object.assign(r.options, { colorSpaceConversion: "none" })) })).then((function (n) { return H_.add(e, n), t && t(n), r.manager.itemEnd(e), n })).catch((function (t) { i && i(t), H_.remove(e), r.manager.itemError(e), r.manager.itemEnd(e) })); H_.add(e, o), r.manager.itemStart(e) } } const py = "\\[\\]\\.:\\/", fy = new RegExp("[" + py + "]", "g"), my = "[^" + py + "]", gy = "[^" + py.replace("\\.", "") + "]", vy = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", my) + /(WCOD+)?/.source.replace("WCOD", gy) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", my) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", my) + "$"), _y = ["material", "materials", "bones", "map"]; class yy { constructor(e, t, n) { this.path = t, this.parsedPath = n || yy.parseTrackName(t), this.node = yy.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, n) { return e && e.isAnimationObjectGroup ? new yy.Composite(e, t, n) : new yy(e, t, n) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(fy, "") } static parseTrackName(e) { const t = vy.exec(e); if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const n = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, i = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== i && -1 !== i) { const e = n.nodeName.substring(i + 1); -1 !== _y.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return n } static findNode(e, t) { if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e; if (e.skeleton) { const n = e.skeleton.getBoneByName(t); if (void 0 !== n) return n } if (e.children) { const n = function (e) { for (let i = 0; i < e.length; i++) { const r = e[i]; if (r.name === t || r.uuid === t) return r; const s = n(r.children); if (s) return s } return null }, i = n(e.children); if (i) return i } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.targetObject[this.propertyName] } _getValue_array(e, t) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)e[t++] = n[i] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node; const t = this.parsedPath, n = t.objectName, i = t.propertyName; let r = t.propertyIndex; if (e || (e = yy.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + "."); if (n) { let i = t.objectIndex; switch (n) { case "materials": if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); e = e.material.materials; break; case "bones": if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); e = e.skeleton.bones; for (let t = 0; t < e.length; t++)if (e[t].name === i) { i = t; break } break; case "map": if ("map" in e) { e = e.map; break } if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); e = e.material.map; break; default: if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); e = e[n] }if (void 0 !== i) { if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); e = e[i] } } const s = e[i]; if (void 0 === s) { const n = t.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e) } let a = this.Versioning.None; this.targetObject = e, void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate); let o = this.BindingType.Direct; if (void 0 !== r) { if ("morphTargetInfluences" === i) { if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r]) } o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i; this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } yy.Composite = class { constructor(e, t, n) { const i = n || yy.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, i) } getValue(e, t) { this.bind(); const n = this._targetGroup.nCachedObjects_, i = this._bindings[n]; void 0 !== i && i.getValue(e, t) } setValue(e, t) { const n = this._bindings; for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)n[i].setValue(e, t) } bind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].bind() } unbind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].unbind() } }, yy.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, yy.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, yy.prototype.GetterByBindingType = [yy.prototype._getValue_direct, yy.prototype._getValue_array, yy.prototype._getValue_arrayElement, yy.prototype._getValue_toArray], yy.prototype.SetterByBindingTypeAndVersioning = [[yy.prototype._setValue_direct, yy.prototype._setValue_direct_setNeedsUpdate, yy.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [yy.prototype._setValue_array, yy.prototype._setValue_array_setNeedsUpdate, yy.prototype._setValue_array_setMatrixWorldNeedsUpdate], [yy.prototype._setValue_arrayElement, yy.prototype._setValue_arrayElement_setNeedsUpdate, yy.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [yy.prototype._setValue_fromArray, yy.prototype._setValue_fromArray_setNeedsUpdate, yy.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; new Float32Array(1); function xy(e, t) { if (0 === t) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e; if (2 === t || 1 === t) { let n = e.getIndex(); if (null === n) { const t = [], i = e.getAttribute("position"); if (void 0 === i) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (let e = 0; e < i.count; e++)t.push(e); e.setIndex(t), n = e.getIndex() } const i = n.count - 2, r = []; if (2 === t) for (let e = 1; e <= i; e++)r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1)); else for (let e = 0; e < i; e++)e % 2 == 0 ? (r.push(n.getX(e)), r.push(n.getX(e + 1)), r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)), r.push(n.getX(e + 1)), r.push(n.getX(e))); r.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const s = e.clone(); return s.setIndex(r), s.clearGroups(), s } return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), e } "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: uu } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = uu); function by() { let e = {}; return { get: function (t) { return e[t] }, add: function (t, n) { e[t] = n }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } const Ey = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_MATERIALS_BUMP: "EXT_materials_bump", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" }; class Ty { constructor(e) { this.parser = e, this.name = Ey.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, n = "light:" + e; let i = t.cache.get(n); if (i) return i; const r = t.json, s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e]; let a; const o = new Pp(16777215); void 0 !== s.color && o.setRGB(s.color[0], s.color[1], s.color[2], dh); const l = void 0 !== s.range ? s.range : 0; switch (s.type) { case "directional": a = new cy(o), a.target.position.set(0, 0, -1), a.add(a.target); break; case "point": a = new oy(o), a.distance = l; break; case "spot": a = new ny(o), a.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, a.angle = s.spot.outerConeAngle, a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type) }return a.position.set(0, 0, 0), a.decay = 2, lx(a, s), void 0 !== s.intensity && (a.intensity = s.intensity), a.name = t.createUniqueName(s.name || "light_" + e), i = Promise.resolve(a), t.cache.add(n, i), i } getDependency(e, t) { if ("light" === e) return this._loadLight(t) } createNodeAttachment(e) { const t = this, n = this.parser, i = n.json.nodes[e], r = (i.extensions && i.extensions[this.name] || {}).light; return void 0 === r ? null : this._loadLight(r).then((function (e) { return n._getNodeRef(t.cache, r, e) })) } } class Sy { constructor() { this.name = Ey.KHR_MATERIALS_UNLIT } getMaterialType() { return Fp } extendParams(e, t, n) { const i = []; e.color = new Pp(1, 1, 1), e.opacity = 1; const r = t.pbrMetallicRoughness; if (r) { if (Array.isArray(r.baseColorFactor)) { const t = r.baseColorFactor; e.color.setRGB(t[0], t[1], t[2], dh), e.opacity = t[3] } void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture, hh)) } return Promise.all(i) } } class My { constructor(e) { this.parser = e, this.name = Ey.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(e, t) { const n = this.parser.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const i = n.extensions[this.name].emissiveStrength; return void 0 !== i && (t.emissiveIntensity = i), Promise.resolve() } } class wy { constructor(e) { this.parser = e, this.name = Ey.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? b_ : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; if (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (t.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) { const e = s.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new kh(e, e) } return Promise.all(r) } } class Ay { constructor(e) { this.parser = e, this.name = Ey.KHR_MATERIALS_IRIDESCENCE } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? b_ : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; return void 0 !== s.iridescenceFactor && (t.iridescence = s.iridescenceFactor), void 0 !== s.iridescenceTexture && r.push(n.assignTexture(t, "iridescenceMap", s.iridescenceTexture)), void 0 !== s.iridescenceIor && (t.iridescenceIOR = s.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== s.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum), void 0 !== s.iridescenceThicknessTexture && r.push(n.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)), Promise.all(r) } } class Dy { constructor(e) { this.parser = e, this.name = Ey.KHR_MATERIALS_SHEEN } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? b_ : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = []; t.sheenColor = new Pp(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1; const s = i.extensions[this.name]; if (void 0 !== s.sheenColorFactor) { const e = s.sheenColorFactor; t.sheenColor.setRGB(e[0], e[1], e[2], dh) } return void 0 !== s.sheenRoughnessFactor && (t.sheenRoughness = s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture && r.push(n.assignTexture(t, "sheenColorMap", s.sheenColorTexture, hh)), void 0 !== s.sheenRoughnessTexture && r.push(n.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)), Promise.all(r) } } class Cy { constructor(e) { this.parser = e, this.name = Ey.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? b_ : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(r) } } class Ry { constructor(e) { this.parser = e, this.name = Ey.KHR_MATERIALS_VOLUME } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? b_ : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0, void 0 !== s.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)), t.attenuationDistance = s.attenuationDistance || 1 / 0; const a = s.attenuationColor || [1, 1, 1]; return t.attenuationColor = (new Pp).setRGB(a[0], a[1], a[2], dh), Promise.all(r) } } class Ly { constructor(e) { this.parser = e, this.name = Ey.KHR_MATERIALS_IOR } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? b_ : null } extendMaterialParams(e, t) { const n = this.parser.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const i = n.extensions[this.name]; return t.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve() } } class Py { constructor(e) { this.parser = e, this.name = Ey.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? b_ : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; t.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1, void 0 !== s.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", s.specularTexture)); const a = s.specularColorFactor || [1, 1, 1]; return t.specularColor = (new Pp).setRGB(a[0], a[1], a[2], dh), void 0 !== s.specularColorTexture && r.push(n.assignTexture(t, "specularColorMap", s.specularColorTexture, hh)), Promise.all(r) } } class Iy { constructor(e) { this.parser = e, this.name = Ey.EXT_MATERIALS_BUMP } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? b_ : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; return t.bumpScale = void 0 !== s.bumpFactor ? s.bumpFactor : 1, void 0 !== s.bumpTexture && r.push(n.assignTexture(t, "bumpMap", s.bumpTexture)), Promise.all(r) } } class Ny { constructor(e) { this.parser = e, this.name = Ey.KHR_MATERIALS_ANISOTROPY } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? b_ : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; return void 0 !== s.anisotropyStrength && (t.anisotropy = s.anisotropyStrength), void 0 !== s.anisotropyRotation && (t.anisotropyRotation = s.anisotropyRotation), void 0 !== s.anisotropyTexture && r.push(n.assignTexture(t, "anisotropyMap", s.anisotropyTexture)), Promise.all(r) } } class Oy { constructor(e) { this.parser = e, this.name = Ey.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, n = t.json, i = n.textures[e]; if (!i.extensions || !i.extensions[this.name]) return null; const r = i.extensions[this.name], s = t.options.ktx2Loader; if (!s) { if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, r.source, s) } } class Fy { constructor(e) { this.parser = e, this.name = Ey.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, n = this.parser, i = n.json, r = i.textures[e]; if (!r.extensions || !r.extensions[t]) return null; const s = r.extensions[t], a = i.images[s.source]; let o = n.textureLoader; if (a.uri) { const e = n.options.manager.getHandler(a.uri); null !== e && (o = e) } return this.detectSupport().then((function (r) { if (r) return n.loadTextureImage(e, s.source, o); if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return n.loadTexture(e) })) } detectSupport() { return this.isSupported || (this.isSupported = new Promise((function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported } } class Uy { constructor(e) { this.parser = e, this.name = Ey.EXT_TEXTURE_AVIF, this.isSupported = null } loadTexture(e) { const t = this.name, n = this.parser, i = n.json, r = i.textures[e]; if (!r.extensions || !r.extensions[t]) return null; const s = r.extensions[t], a = i.images[s.source]; let o = n.textureLoader; if (a.uri) { const e = n.options.manager.getHandler(a.uri); null !== e && (o = e) } return this.detectSupport().then((function (r) { if (r) return n.loadTextureImage(e, s.source, o); if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported."); return n.loadTexture(e) })) } detectSupport() { return this.isSupported || (this.isSupported = new Promise((function (e) { const t = new Image; t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported } } class By { constructor(e) { this.name = Ey.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, n = t.bufferViews[e]; if (n.extensions && n.extensions[this.name]) { const e = n.extensions[this.name], i = this.parser.getDependency("buffer", e.buffer), r = this.parser.options.meshoptDecoder; if (!r || !r.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return i.then((function (t) { const n = e.byteOffset || 0, i = e.byteLength || 0, s = e.count, a = e.byteStride, o = new Uint8Array(t, n, i); return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(s, a, o, e.mode, e.filter).then((function (e) { return e.buffer })) : r.ready.then((function () { const t = new ArrayBuffer(s * a); return r.decodeGltfBuffer(new Uint8Array(t), s, a, o, e.mode, e.filter), t })) })) } return null } } class ky { constructor(e) { this.name = Ey.EXT_MESH_GPU_INSTANCING, this.parser = e } createNodeMesh(e) { const t = this.parser.json, n = t.nodes[e]; if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null; const i = t.meshes[n.mesh]; for (const e of i.primitives) if (e.mode !== $y.TRIANGLES && e.mode !== $y.TRIANGLE_STRIP && e.mode !== $y.TRIANGLE_FAN && void 0 !== e.mode) return null; const r = n.extensions[this.name].attributes, s = [], a = {}; for (const e in r) s.push(this.parser.getDependency("accessor", r[e]).then((t => (a[e] = t, a[e])))); return s.length < 1 ? null : (s.push(this.parser.createNodeMesh(e)), Promise.all(s).then((e => { const t = e.pop(), n = t.isGroup ? t.children : [t], i = e[0].count, r = []; for (const e of n) { const t = new Vd, n = new pd, s = new dd, o = new pd(1, 1, 1), l = new t_(e.geometry, e.material, i); for (let e = 0; e < i; e++)a.TRANSLATION && n.fromBufferAttribute(a.TRANSLATION, e), a.ROTATION && s.fromBufferAttribute(a.ROTATION, e), a.SCALE && o.fromBufferAttribute(a.SCALE, e), l.setMatrixAt(e, t.compose(n, s, o)); for (const t in a) if ("_COLOR_0" === t) { const e = a[t]; l.instanceColor = new qv(e.array, e.itemSize, e.normalized) } else "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, a[t]); gp.prototype.copy.call(l, e), this.parser.assignFinalMaterial(l), r.push(l) } return t.isGroup ? (t.clear(), t.add(...r), t) : r[0] }))) } } const zy = "glTF", Hy = 1313821514, Gy = 5130562; class Vy { constructor(e) { this.name = Ey.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, 12), n = new TextDecoder; if (this.header = { magic: n.decode(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== zy) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const i = this.header.length - 12, r = new DataView(e, 12); let s = 0; for (; s < i;) { const t = r.getUint32(s, !0); s += 4; const i = r.getUint32(s, !0); if (s += 4, i === Hy) { const i = new Uint8Array(e, 12 + s, t); this.content = n.decode(i) } else if (i === Gy) { const n = 12 + s; this.body = e.slice(n, n + t) } s += t } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class Wy { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = Ey.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const n = this.json, i = this.dracoLoader, r = e.extensions[this.name].bufferView, s = e.extensions[this.name].attributes, a = {}, o = {}, l = {}; for (const e in s) { const t = tx[e] || e.toLowerCase(); a[t] = s[e] } for (const t in e.attributes) { const i = tx[t] || t.toLowerCase(); if (void 0 !== s[t]) { const r = n.accessors[e.attributes[t]], s = Zy[r.componentType]; l[i] = s.name, o[i] = !0 === r.normalized } } return t.getDependency("bufferView", r).then((function (e) { return new Promise((function (t, n) { i.decodeDracoFile(e, (function (e) { for (const t in e.attributes) { const n = e.attributes[t], i = o[t]; void 0 !== i && (n.normalized = i) } t(e) }), a, l, dh, n) })) })) } } class jy { constructor() { this.name = Ey.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(), void 0 !== t.texCoord && (e.channel = t.texCoord), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e) : e } } class Xy { constructor() { this.name = Ey.KHR_MESH_QUANTIZATION } } class qy extends A_ { constructor(e, t, n, i) { super(e, t, n, i) } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i * 3 + i; for (let e = 0; e !== i; e++)t[e] = n[r + e]; return t } interpolate_(e, t, n, i) { const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = 2 * a, l = 3 * a, c = i - t, u = (n - t) / c, h = u * u, d = h * u, p = e * l, f = p - l, m = -2 * d + 3 * h, g = d - h, v = 1 - m, _ = g - h + u; for (let e = 0; e !== a; e++) { const t = s[f + e + a], n = s[f + e + o] * c, i = s[p + e + a], l = s[p + e] * c; r[e] = v * t + _ * n + m * i + g * l } return r } } const Yy = new dd; class Ky extends qy { interpolate_(e, t, n, i) { const r = super.interpolate_(e, t, n, i); return Yy.fromArray(r).normalize().toArray(r), r } } const $y = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, Zy = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, Jy = { 9728: Uu, 9729: zu, 9984: Bu, 9985: Hu, 9986: ku, 9987: Gu }, Qy = { 33071: Ou, 33648: Fu, 10497: Nu }, ex = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, tx = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, nx = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, ix = { CUBICSPLINE: void 0, LINEAR: sh, STEP: rh }, rx = "OPAQUE", sx = "MASK", ax = "BLEND"; function ox(e, t, n) { for (const i in n.extensions) void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i]) } function lx(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) } function cx(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (let n = 0, i = t.weights.length; n < i; n++)e.morphTargetInfluences[n] = t.weights[n]; if (t.extras && Array.isArray(t.extras.targetNames)) { const n = t.extras.targetNames; if (e.morphTargetInfluences.length === n.length) { e.morphTargetDictionary = {}; for (let t = 0, i = n.length; t < i; t++)e.morphTargetDictionary[n[t]] = t } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function ux(e) { let t; const n = e.extensions && e.extensions[Ey.KHR_DRACO_MESH_COMPRESSION]; if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + hx(n.attributes) : e.indices + ":" + hx(e.attributes) + ":" + e.mode, void 0 !== e.targets) for (let n = 0, i = e.targets.length; n < i; n++)t += ":" + hx(e.targets[n]); return t } function hx(e) { let t = ""; const n = Object.keys(e).sort(); for (let i = 0, r = n.length; i < r; i++)t += n[i] + ":" + e[n[i]] + ";"; return t } function dx(e) { switch (e) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } const px = new Vd; class fx { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new by, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; let n = !1, i = !1, r = -1; "undefined" != typeof navigator && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), i = navigator.userAgent.indexOf("Firefox") > -1, r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || n || i && r < 98 ? this.textureLoader = new K_(this.options.manager) : this.textureLoader = new dy(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new q_(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const n = this, i = this.json, r = this.extensions; this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function (e) { return e._markDefs && e._markDefs() })), Promise.all(this._invokeAll((function (e) { return e.beforeRoot && e.beforeRoot() }))).then((function () { return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]) })).then((function (t) { const s = { scene: t[0][i.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: i.asset, parser: n, userData: {} }; return ox(r, s, i), lx(s, i), Promise.all(n._invokeAll((function (e) { return e.afterRoot && e.afterRoot(s) }))).then((function () { e(s) })) })).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n].joints; for (let t = 0, n = i.length; t < n; t++)e[i[t]].isBone = !0 } for (let t = 0, i = e.length; t < i; t++) { const i = e[t]; void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera) } } _addNodeRef(e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, n) { if (e.refs[t] <= 1) return n; const i = n.clone(), r = (e, t) => { const n = this.associations.get(e); null != n && this.associations.set(t, n); for (const [n, i] of e.children.entries()) r(i, t.children[n]) }; return r(n, i), i.name += "_instance_" + e.uses[t]++, i } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let n = 0; n < t.length; n++) { const i = e(t[n]); if (i) return i } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const n = []; for (let i = 0; i < t.length; i++) { const r = e(t[i]); r && n.push(r) } return n } getDependency(e, t) { const n = e + ":" + t; let i = this.cache.get(n); if (!i) { switch (e) { case "scene": i = this.loadScene(t); break; case "node": i = this._invokeOne((function (e) { return e.loadNode && e.loadNode(t) })); break; case "mesh": i = this._invokeOne((function (e) { return e.loadMesh && e.loadMesh(t) })); break; case "accessor": i = this.loadAccessor(t); break; case "bufferView": i = this._invokeOne((function (e) { return e.loadBufferView && e.loadBufferView(t) })); break; case "buffer": i = this.loadBuffer(t); break; case "material": i = this._invokeOne((function (e) { return e.loadMaterial && e.loadMaterial(t) })); break; case "texture": i = this._invokeOne((function (e) { return e.loadTexture && e.loadTexture(t) })); break; case "skin": i = this.loadSkin(t); break; case "animation": i = this._invokeOne((function (e) { return e.loadAnimation && e.loadAnimation(t) })); break; case "camera": i = this.loadCamera(t); break; default: if (i = this._invokeOne((function (n) { return n != this && n.getDependency && n.getDependency(e, t) })), !i) throw new Error("Unknown type: " + e) }this.cache.add(n, i) } return i } getDependencies(e) { let t = this.cache.get(e); if (!t) { const n = this, i = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(i.map((function (t, i) { return n.getDependency(e, i) }))), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], n = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[Ey.KHR_BINARY_GLTF].body); const i = this.options; return new Promise((function (e, r) { n.load(hy.resolveURL(t.uri, i.path), e, void 0, (function () { r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) })) })) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then((function (e) { const n = t.byteLength || 0, i = t.byteOffset || 0; return e.slice(i, i + n) })) } loadAccessor(e) { const t = this, n = this.json, i = this.json.accessors[e]; if (void 0 === i.bufferView && void 0 === i.sparse) { const e = ex[i.type], t = Zy[i.componentType], n = !0 === i.normalized, r = new t(i.count * e); return Promise.resolve(new kp(r, e, n)) } const r = []; return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function (e) { const r = e[0], s = ex[i.type], a = Zy[i.componentType], o = a.BYTES_PER_ELEMENT, l = o * s, c = i.byteOffset || 0, u = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0, h = !0 === i.normalized; let d, p; if (u && u !== l) { const e = Math.floor(c / u), n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count; let l = t.cache.get(n); l || (d = new a(r, e * u, i.count * u / o), l = new Cv(d, u / o), t.cache.add(n, l)), p = new Lv(l, s, c % u / o, h) } else d = null === r ? new a(i.count * s) : new a(r, c, i.count * s), p = new kp(d, s, h); if (void 0 !== i.sparse) { const t = ex.SCALAR, n = Zy[i.sparse.indices.componentType], o = i.sparse.indices.byteOffset || 0, l = i.sparse.values.byteOffset || 0, c = new n(e[1], o, i.sparse.count * t), u = new a(e[2], l, i.sparse.count * s); null !== r && (p = new kp(p.array.slice(), p.itemSize, p.normalized)); for (let e = 0, t = c.length; e < t; e++) { const t = c[e]; if (p.setX(t, u[e * s]), s >= 2 && p.setY(t, u[e * s + 1]), s >= 3 && p.setZ(t, u[e * s + 2]), s >= 4 && p.setW(t, u[e * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return p })) } loadTexture(e) { const t = this.json, n = this.options, i = t.textures[e].source, r = t.images[i]; let s = this.textureLoader; if (r.uri) { const e = n.manager.getHandler(r.uri); null !== e && (s = e) } return this.loadTextureImage(e, i, s) } loadTextureImage(e, t, n) { const i = this, r = this.json, s = r.textures[e], a = r.images[t], o = (a.uri || a.bufferView) + ":" + s.sampler; if (this.textureCache[o]) return this.textureCache[o]; const l = this.loadImageSource(t, n).then((function (t) { t.flipY = !1, t.name = s.name || a.name || "", "" === t.name && "string" == typeof a.uri && !1 === a.uri.startsWith("data:image/") && (t.name = a.uri); const n = (r.samplers || {})[s.sampler] || {}; return t.magFilter = Jy[n.magFilter] || zu, t.minFilter = Jy[n.minFilter] || Gu, t.wrapS = Qy[n.wrapS] || Nu, t.wrapT = Qy[n.wrapT] || Nu, i.associations.set(t, { textures: e }), t })).catch((function () { return null })); return this.textureCache[o] = l, l } loadImageSource(e, t) { const n = this, i = this.json, r = this.options; if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e => e.clone())); const s = i.images[e], a = self.URL || self.webkitURL; let o = s.uri || "", l = !1; if (void 0 !== s.bufferView) o = n.getDependency("bufferView", s.bufferView).then((function (e) { l = !0; const t = new Blob([e], { type: s.mimeType }); return o = a.createObjectURL(t), o })); else if (void 0 === s.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const c = Promise.resolve(o).then((function (e) { return new Promise((function (n, i) { let s = n; !0 === t.isImageBitmapLoader && (s = function (e) { const t = new ad(e); t.needsUpdate = !0, n(t) }), t.load(hy.resolveURL(e, r.path), s, void 0, i) })) })).then((function (e) { var t; return !0 === l && a.revokeObjectURL(o), e.userData.mimeType = s.mimeType || ((t = s.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e })).catch((function (e) { throw console.error("THREE.GLTFLoader: Couldn't load texture", o), e })); return this.sourceCache[e] = c, c } assignTexture(e, t, n, i) { const r = this; return this.getDependency("texture", n.index).then((function (s) { if (!s) return null; if (void 0 !== n.texCoord && n.texCoord > 0 && ((s = s.clone()).channel = n.texCoord), r.extensions[Ey.KHR_TEXTURE_TRANSFORM]) { const e = void 0 !== n.extensions ? n.extensions[Ey.KHR_TEXTURE_TRANSFORM] : void 0; if (e) { const t = r.associations.get(s); s = r.extensions[Ey.KHR_TEXTURE_TRANSFORM].extendTexture(s, e), r.associations.set(s, t) } } return void 0 !== i && (s.colorSpace = i), e[t] = s, s })) } assignFinalMaterial(e) { const t = e.geometry; let n = e.material; const i = void 0 === t.attributes.tangent, r = void 0 !== t.attributes.color, s = void 0 === t.attributes.normal; if (e.isPoints) { const e = "PointsMaterial:" + n.uuid; let t = this.cache.get(e); t || (t = new p_, Op.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t } else if (e.isLine) { const e = "LineBasicMaterial:" + n.uuid; let t = this.cache.get(e); t || (t = new n_, Op.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, this.cache.add(e, t)), n = t } if (i || r || s) { let e = "ClonedMaterial:" + n.uuid + ":"; i && (e += "derivative-tangents:"), r && (e += "vertex-colors:"), s && (e += "flat-shading:"); let t = this.cache.get(e); t || (t = n.clone(), r && (t.vertexColors = !0), s && (t.flatShading = !0), i && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t } e.material = n } getMaterialType() { return x_ } loadMaterial(e) { const t = this, n = this.json, i = this.extensions, r = n.materials[e]; let s; const a = {}, o = []; if ((r.extensions || {})[Ey.KHR_MATERIALS_UNLIT]) { const e = i[Ey.KHR_MATERIALS_UNLIT]; s = e.getMaterialType(), o.push(e.extendParams(a, r, t)) } else { const n = r.pbrMetallicRoughness || {}; if (a.color = new Pp(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) { const e = n.baseColorFactor; a.color.setRGB(e[0], e[1], e[2], dh), a.opacity = e[3] } void 0 !== n.baseColorTexture && o.push(t.assignTexture(a, "map", n.baseColorTexture, hh)), a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (o.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), o.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne((function (t) { return t.getMaterialType && t.getMaterialType(e) })), o.push(Promise.all(this._invokeAll((function (t) { return t.extendMaterialParams && t.extendMaterialParams(e, a) })))) } !0 === r.doubleSided && (a.side = 2); const l = r.alphaMode || rx; if (l === ax ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, l === sx && (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && s !== Fp && (o.push(t.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new kh(1, 1), void 0 !== r.normalTexture.scale)) { const e = r.normalTexture.scale; a.normalScale.set(e, e) } if (void 0 !== r.occlusionTexture && s !== Fp && (o.push(t.assignTexture(a, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (a.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && s !== Fp) { const e = r.emissiveFactor; a.emissive = (new Pp).setRGB(e[0], e[1], e[2], dh) } return void 0 !== r.emissiveTexture && s !== Fp && o.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, hh)), Promise.all(o).then((function () { const n = new s(a); return r.name && (n.name = r.name), lx(n, r), t.associations.set(n, { materials: e }), r.extensions && ox(i, n, r), n })) } createUniqueName(e) { const t = yy.sanitizeNodeName(e || ""); return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t) } loadGeometries(e) { const t = this, n = this.extensions, i = this.primitiveCache; function r(e) { return n[Ey.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (n) { return mx(n, e, t) })) } const s = []; for (let n = 0, a = e.length; n < a; n++) { const a = e[n], o = ux(a), l = i[o]; if (l) s.push(l.promise); else { let e; e = a.extensions && a.extensions[Ey.KHR_DRACO_MESH_COMPRESSION] ? r(a) : mx(new $p, a, t), i[o] = { primitive: a, promise: e }, s.push(e) } } return Promise.all(s) } loadMesh(e) { const t = this, n = this.json, i = this.extensions, r = n.meshes[e], s = r.primitives, a = []; for (let e = 0, t = s.length; e < t; e++) { const t = void 0 === s[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new x_({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: fu })), o.DefaultMaterial) : this.getDependency("material", s[e].material); a.push(t) } var o; return a.push(t.loadGeometries(s)), Promise.all(a).then((function (n) { const a = n.slice(0, n.length - 1), o = n[n.length - 1], l = []; for (let n = 0, c = o.length; n < c; n++) { const c = o[n], u = s[n]; let h; const d = a[n]; if (u.mode === $y.TRIANGLES || u.mode === $y.TRIANGLE_STRIP || u.mode === $y.TRIANGLE_FAN || void 0 === u.mode) h = !0 === r.isSkinnedMesh ? new Hv(c, d) : new mf(c, d), !0 === h.isSkinnedMesh && h.normalizeSkinWeights(), u.mode === $y.TRIANGLE_STRIP ? h.geometry = xy(h.geometry, 1) : u.mode === $y.TRIANGLE_FAN && (h.geometry = xy(h.geometry, 2)); else if (u.mode === $y.LINES) h = new h_(c, d); else if (u.mode === $y.LINE_STRIP) h = new l_(c, d); else if (u.mode === $y.LINE_LOOP) h = new d_(c, d); else { if (u.mode !== $y.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode); h = new __(c, d) } Object.keys(h.geometry.morphAttributes).length > 0 && cx(h, r), h.name = t.createUniqueName(r.name || "mesh_" + e), lx(h, r), u.extensions && ox(i, h, u), t.assignFinalMaterial(h), l.push(h) } for (let n = 0, i = l.length; n < i; n++)t.associations.set(l[n], { meshes: e, primitives: n }); if (1 === l.length) return r.extensions && ox(i, l[0], r), l[0]; const c = new _v; r.extensions && ox(i, c, r), t.associations.set(c, { meshes: e }); for (let e = 0, t = l.length; e < t; e++)c.add(l[e]); return c })) } loadCamera(e) { let t; const n = this.json.cameras[e], i = n[n.type]; if (i) return "perspective" === n.type ? t = new Af(Bh.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (t = new em(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), lx(t, n), Promise.resolve(t); console.warn("THREE.GLTFLoader: Missing camera parameters.") } loadSkin(e) { const t = this.json.skins[e], n = []; for (let e = 0, i = t.joints.length; e < i; e++)n.push(this._loadNodeShallow(t.joints[e])); return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then((function (e) { const n = e.pop(), i = e, r = [], s = []; for (let e = 0, a = i.length; e < a; e++) { const a = i[e]; if (a) { r.push(a); const t = new Vd; null !== n && t.fromArray(n.array, 16 * e), s.push(t) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e]) } return new Xv(r, s) })) } loadAnimation(e) { const t = this.json, n = this, i = t.animations[e], r = i.name ? i.name : "animation_" + e, s = [], a = [], o = [], l = [], c = []; for (let e = 0, t = i.channels.length; e < t; e++) { const t = i.channels[e], n = i.samplers[t.sampler], r = t.target, u = r.node, h = void 0 !== i.parameters ? i.parameters[n.input] : n.input, d = void 0 !== i.parameters ? i.parameters[n.output] : n.output; void 0 !== r.node && (s.push(this.getDependency("node", u)), a.push(this.getDependency("accessor", h)), o.push(this.getDependency("accessor", d)), l.push(n), c.push(r)) } return Promise.all([Promise.all(s), Promise.all(a), Promise.all(o), Promise.all(l), Promise.all(c)]).then((function (e) { const t = e[0], i = e[1], s = e[2], a = e[3], o = e[4], l = []; for (let e = 0, r = t.length; e < r; e++) { const r = t[e], c = i[e], u = s[e], h = a[e], d = o[e]; if (void 0 === r) continue; r.updateMatrix && r.updateMatrix(); const p = n._createAnimationTracks(r, c, u, h, d); if (p) for (let e = 0; e < p.length; e++)l.push(p[e]) } return new k_(r, void 0, l) })) } createNodeMesh(e) { const t = this.json, n = this, i = t.nodes[e]; return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function (e) { const t = n._getNodeRef(n.meshCache, i.mesh, e); return void 0 !== i.weights && t.traverse((function (e) { if (e.isMesh) for (let t = 0, n = i.weights.length; t < n; t++)e.morphTargetInfluences[t] = i.weights[t] })), t })) } loadNode(e) { const t = this, n = this.json.nodes[e], i = t._loadNodeShallow(e), r = [], s = n.children || []; for (let e = 0, n = s.length; e < n; e++)r.push(t.getDependency("node", s[e])); const a = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin); return Promise.all([i, Promise.all(r), a]).then((function (e) { const t = e[0], n = e[1], i = e[2]; null !== i && t.traverse((function (e) { e.isSkinnedMesh && e.bind(i, px) })); for (let e = 0, i = n.length; e < i; e++)t.add(n[e]); return t })) } _loadNodeShallow(e) { const t = this.json, n = this.extensions, i = this; if (void 0 !== this.nodeCache[e]) return this.nodeCache[e]; const r = t.nodes[e], s = r.name ? i.createUniqueName(r.name) : "", a = [], o = i._invokeOne((function (t) { return t.createNodeMesh && t.createNodeMesh(e) })); return o && a.push(o), void 0 !== r.camera && a.push(i.getDependency("camera", r.camera).then((function (e) { return i._getNodeRef(i.cameraCache, r.camera, e) }))), i._invokeAll((function (t) { return t.createNodeAttachment && t.createNodeAttachment(e) })).forEach((function (e) { a.push(e) })), this.nodeCache[e] = Promise.all(a).then((function (t) { let a; if (a = !0 === r.isBone ? new Gv : t.length > 1 ? new _v : 1 === t.length ? t[0] : new gp, a !== t[0]) for (let e = 0, n = t.length; e < n; e++)a.add(t[e]); if (r.name && (a.userData.name = r.name, a.name = s), lx(a, r), r.extensions && ox(n, a, r), void 0 !== r.matrix) { const e = new Vd; e.fromArray(r.matrix), a.applyMatrix4(e) } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale); return i.associations.has(a) || i.associations.set(a, {}), i.associations.get(a).nodes = e, a })), this.nodeCache[e] } loadScene(e) { const t = this.extensions, n = this.json.scenes[e], i = this, r = new _v; n.name && (r.name = i.createUniqueName(n.name)), lx(r, n), n.extensions && ox(t, r, n); const s = n.nodes || [], a = []; for (let e = 0, t = s.length; e < t; e++)a.push(i.getDependency("node", s[e])); return Promise.all(a).then((function (e) { for (let t = 0, n = e.length; t < n; t++)r.add(e[t]); return i.associations = (e => { const t = new Map; for (const [e, n] of i.associations) (e instanceof Op || e instanceof ad) && t.set(e, n); return e.traverse((e => { const n = i.associations.get(e); null != n && t.set(e, n) })), t })(r), r })) } _createAnimationTracks(e, t, n, i, r) { const s = [], a = e.name ? e.name : e.uuid, o = []; let l; switch (nx[r.path] === nx.weights ? e.traverse((function (e) { e.morphTargetInfluences && o.push(e.name ? e.name : e.uuid) })) : o.push(a), nx[r.path]) { case nx.weights: l = N_; break; case nx.rotation: l = F_; break; case nx.position: case nx.scale: l = B_; break; default: if (1 === n.itemSize) l = N_; else l = B_ }const c = void 0 !== i.interpolation ? ix[i.interpolation] : sh, u = this._getArrayFromAccessor(n); for (let e = 0, n = o.length; e < n; e++) { const n = new l(o[e] + "." + nx[r.path], t.array, u, c); "CUBICSPLINE" === i.interpolation && this._createCubicSplineTrackInterpolant(n), s.push(n) } return s } _getArrayFromAccessor(e) { let t = e.array; if (e.normalized) { const e = dx(t.constructor), n = new Float32Array(t.length); for (let i = 0, r = t.length; i < r; i++)n[i] = t[i] * e; t = n } return t } _createCubicSplineTrackInterpolant(e) { e.createInterpolant = function (e) { return new (this instanceof F_ ? Ky : qy)(this.times, this.values, this.getValueSize() / 3, e) }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0 } } function mx(e, t, n) { const i = t.attributes, r = []; function s(t, i) { return n.getDependency("accessor", t).then((function (t) { e.setAttribute(i, t) })) } for (const t in i) { const n = tx[t] || t.toLowerCase(); n in e.attributes || r.push(s(i[t], n)) } if (void 0 !== t.indices && !e.index) { const i = n.getDependency("accessor", t.indices).then((function (t) { e.setIndex(t) })); r.push(i) } return Zh.workingColorSpace !== dh && "COLOR_0" in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Zh.workingColorSpace}" not supported.`), lx(e, t), function (e, t, n) { const i = t.attributes, r = new gd; if (void 0 === i.POSITION) return; { const e = n.json.accessors[i.POSITION], t = e.min, s = e.max; if (void 0 === t || void 0 === s) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); if (r.set(new pd(t[0], t[1], t[2]), new pd(s[0], s[1], s[2])), e.normalized) { const t = dx(Zy[e.componentType]); r.min.multiplyScalar(t), r.max.multiplyScalar(t) } } const s = t.targets; if (void 0 !== s) { const e = new pd, t = new pd; for (let i = 0, r = s.length; i < r; i++) { const r = s[i]; if (void 0 !== r.POSITION) { const i = n.json.accessors[r.POSITION], s = i.min, a = i.max; if (void 0 !== s && void 0 !== a) { if (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))), i.normalized) { const e = dx(Zy[i.componentType]); t.multiplyScalar(e) } e.max(t) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } r.expandByVector(e) } e.boundingBox = r; const a = new Nd; r.getCenter(a.center), a.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = a }(e, t, n), Promise.all(r).then((function () { return void 0 !== t.targets ? function (e, t, n) { let i = !1, r = !1, s = !1; for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), void 0 !== n.COLOR_0 && (s = !0), i && r && s) break } if (!i && !r && !s) return Promise.resolve(e); const a = [], o = [], l = []; for (let c = 0, u = t.length; c < u; c++) { const u = t[c]; if (i) { const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position; a.push(t) } if (r) { const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal; o.push(t) } if (s) { const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color; l.push(t) } } return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then((function (t) { const n = t[0], a = t[1], o = t[2]; return i && (e.morphAttributes.position = n), r && (e.morphAttributes.normal = a), s && (e.morphAttributes.color = o), e.morphTargetsRelative = !0, e })) }(e, t.targets, n) : e })) } var gx = n(755); const vx = class { constructor(e, t) { this.map = e, this.params = t, this.init() } init() { var e = this, t = new google.maps.Map(e.map[0], { zoom: 1, scrollwheel: !1, center: new google.maps.LatLng(0, 0), mapTypeId: google.maps.MapTypeId.ROADMAP, styles: this.getCustomization() }); return t.markers = [], gx.each(this.params.markers, (function () { e.add_marker(gx(this), t) })), e.center_map(t), t } add_marker(e, t) { var n = new google.maps.LatLng(e.data("lat"), e.data("lng")), i = { url: e.data("icon"), scaledSize: new google.maps.Size(60, 60), origin: new google.maps.Point(0, 0), anchor: new google.maps.Point(0, 0) }, r = new google.maps.Marker({ position: n, map: t, icon: i }); if (t.markers.push(r), e.html()) { var s = new google.maps.InfoWindow({ content: '<div class="map-card">' + e.html() + "</div>" }); google.maps.event.addListener(r, "click", (function () { s.open(t, r) })) } } center_map(e) { var t = new google.maps.LatLngBounds; gx.each(e.markers, (function (e, n) { var i = new google.maps.LatLng(n.position.lat(), n.position.lng()); t.extend(i) })), 1 == e.markers.length ? (e.setCenter(t.getCenter()), e.setZoom(this.params.zoom)) : e.fitBounds(t) } getCustomization() { return [{ elementType: "geometry", stylers: [{ color: "#f5f5f5" }] }, { elementType: "labels.icon", stylers: [{ visibility: "off" }] }, { elementType: "labels.text.fill", stylers: [{ color: "#616161" }] }, { elementType: "labels.text.stroke", stylers: [{ color: "#f5f5f5" }] }, { featureType: "administrative.land_parcel", elementType: "labels.text.fill", stylers: [{ color: "#bdbdbd" }] }, { featureType: "poi", elementType: "geometry", stylers: [{ color: "#eeeeee" }] }, { featureType: "poi", elementType: "labels.text.fill", stylers: [{ color: "#757575" }] }, { featureType: "poi.park", elementType: "geometry", stylers: [{ color: "#e5e5e5" }] }, { featureType: "poi.park", elementType: "labels.text.fill", stylers: [{ color: "#9e9e9e" }] }, { featureType: "road", elementType: "geometry", stylers: [{ color: "#ffffff" }] }, { featureType: "road.arterial", elementType: "labels.text.fill", stylers: [{ color: "#757575" }] }, { featureType: "road.highway", elementType: "geometry", stylers: [{ color: "#dadada" }] }, { featureType: "road.highway", elementType: "labels.text.fill", stylers: [{ color: "#616161" }] }, { featureType: "road.local", elementType: "labels.text.fill", stylers: [{ color: "#9e9e9e" }] }, { featureType: "transit.line", elementType: "geometry", stylers: [{ color: "#e5e5e5" }] }, { featureType: "transit.station", elementType: "geometry", stylers: [{ color: "#eeeeee" }] }, { featureType: "water", elementType: "geometry", stylers: [{ color: "#c9c9c9" }] }, { featureType: "water", elementType: "labels.text.fill", stylers: [{ color: "#9e9e9e" }] }] } }; var _x = n(755); const yx = class { constructor(e, t = {}) { this.formWrapper = e, this.params = this.initParams(t), this.init() } initParams(e) { const { selectors: t, labelEffect: n } = e, { group: i, label: r, input: s } = t, { duration: a, scale: o, y: l, ease: c } = n; return { selectors: { group: this.isDefined(i) ? i : "form-group", label: this.isDefined(r) ? r : "label", input: this.isDefined(s) ? s : "input" }, labelEffect: { duration: this.isDefined(a) ? a : .3, scale: this.isDefined(o) ? o : .7, y: this.isDefined(l) ? l : -10, ease: this.isDefined(c) ? c : Power1.easeOut }, focusedClasses: { group: "materialize-group-focused", label: "materialize-label-focused", input: "materialize-input-focused" } } } initTimeline() { return new TimelineMax({ paused: !0, onComplete: this.handleComplete, onReverseComplete: this.handleReverseComplete }) } init() { this.formWrapperExist() && this.handleToggleInputs() } handleToggleInputs() { const e = this, t = this.formWrapper, { group: n, input: i } = this.params.selectors, r = t.find(n + " " + i); _x.each(r, (function () { const t = _x(this), i = t.closest(n).find("label"); "" != t.val() && e.animateFocus(i) })), r.on("blur focus", (function (t) { console.log("error"); const i = t.type, r = _x(this), s = r.closest(n), a = s.find("label"); "focus" === i && e.handleFocus(s, a), "blur" === i && e.handleBlur(s, a, r) })) } handleFocus(e, t) { const { group: n, label: i } = this.params.focusedClasses; e.addClass(n), t.addClass(i), this.animateFocus(t) } animateFocus(e) { const { duration: t, scale: n, y: i, ease: r } = this.params.labelEffect; Gr.to(e, t, { scale: n, y: i, transformOrigin: "left top", ease: r }) } handleBlur(e, t, n) { const { group: i, label: r } = this.params.focusedClasses; "" === n.val() && (e.removeClass(i), t.removeClass(r), this.animateBlur(t)) } animateBlur(e) { const { duration: t, ease: n } = this.params.labelEffect; Gr.to(e, t, { scale: 1, y: 0, transformOrigin: "left top", ease: n }) } formWrapperExist() { return this.control(this.exist(this.formWrapper), this.getMessage("formWrapperExist"), this.formWrapper) } isDefined(e) { return void 0 !== e } exist(e) { return e.length } control(e, t, n = null) { return e || (null === n ? console.error(t) : console.error(t, n)), e } getMessage(e, t = "", n = "") { return "Materialize form: " + { formWrapperExist: "The form wrapper (specified as 1st parameter) does not exist:" }[e] } }; Gr.registerPlugin(wl); const xx = class { constructor(e = {}) { this.params = this.getParams(e), this.tweens = {} } getDefaults() { return { loadEvent: [window, "DOMContentLoaded"], scrollTrigger: { start: "top bottom", toggleActions: "play complete none reset" }, tweenParams: { start: "-=0.4" }, selectors: { wrappers: "[data-kira-timeline]", items: "[data-kira-item]" } } } getParams(e) { const t = { ...this.getDefaults() }, { scrollTrigger: n, tweenParams: i, selectors: r, ...s } = e; return e.hasOwnProperty("scrollTrigger") && (t.scrollTrigger = { ...t.scrollTrigger, ...n }), e.hasOwnProperty("tweenParams") && (t.tweenParams = { ...t.tweenParams, ...i }), { ...t, ...s } } init() { Gr.utils.toArray(this.params.selectors.wrappers).forEach((e => "onload" === e.dataset.kiraTimeline ? this.runEntranceAnimations(e) : this.runScrollAnimations(e))) } runEntranceAnimations(e) { const [t, n] = this.params.loadEvent, i = this.createTimeline(e, { paused: !0 }); t.addEventListener(n, (() => i.play()), !1) } runScrollAnimations(e) { const { scrollTrigger: t } = this.params, n = { trigger: e }; let i = {}; i.scrollTrigger = { ...t, ...n }, this.createTimeline(e, i) } createTimeline(e, t = {}) { const n = Gr.timeline(t), { items: i } = this.params.selectors, { start: r } = this.params.tweenParams; return e.querySelectorAll(i).forEach(((e, t) => { const i = e.dataset.kiraItem, s = e.dataset.kiraStart; let a = 0 === t ? "start" : r; a = s || a; const o = !!e.hasAttribute("data-kira-duration") && parseFloat(e.dataset.kiraDuration), l = !!e.hasAttribute("data-kira-delay") && parseFloat(e.dataset.kiraDelay); this.tweenExists(i) && this.tweens[i](e, n, a, o, l) })), n } add(e, t) { this.tweens[e] = t } tweenExists(e) { return this.control(this.tweens.hasOwnProperty(e), this.getMessage("tween_not_exist", e)) } control(e, t, n = null) { return e || (null === n ? console.error(t) : console.error(t, n)), e } getMessage(e, ...t) { return { tween_exist: `The tween: "${t[0]}" has already been defined`, tween_not_exist: `The tween: "${t[0]}" not exist` }[e] } }, bx = () => document.documentElement.hasAttribute("lang") ? document.documentElement.lang.split("-")[0] : "fr", Ex = () => window.matchMedia("(hover: hover)").matches, Tx = () => window.matchMedia("(prefers-reduced-motion: no-preference)").matches, Sx = e => console.log(e), Mx = (e, t, n = {}) => e.dispatchEvent(new CustomEvent(t, { detail: n })), wx = (e, t, n, i) => { e.addEventListener(t, (t => { e.contains(t.target) && t.target.closest(n) && i.call(t.target, t) })) }, Ax = e => void 0 !== e, Dx = e => e.length, Cx = (e, t, n = !1) => { let i; return function () { let r = this, s = arguments, a = n && !i; clearTimeout(i), i = setTimeout((function () { i = null, n || e.apply(r, s) }), t), a && e.apply(r, s) } }, Rx = (e, t = new FormData) => { const n = new URLSearchParams(t), i = []; n.forEach(((e, t) => { "" == e && i.push(t) })), i.forEach((e => { n.delete(e) })); const r = n.toString(); history.replaceState({}, document.title, `${e}${r ? `?${r}` : ""}`) }; let Lx = 0; const Px = () => { 0 === Lx && (document.body.style.overflow = "hidden"), Lx++ }, Ix = (e = !1) => { Lx = e ? 0 : Math.max(0, Lx - 1), 0 === Lx && (document.body.style.overflow = "") }, Nx = e => { for (var t = e + "=", n = decodeURIComponent(document.cookie).split(";"), i = 0; i < n.length; i++) { for (var r = n[i]; " " == r.charAt(0);)r = r.substring(1); if (0 == r.indexOf(t)) return r.substring(t.length, r.length) } return null }, Ox = (e, t, n) => { const i = new Date; i.setTime(i.getTime() + 24 * n * 60 * 60 * 1e3); const r = "expires=" + i.toUTCString(); document.cookie = e + "=" + t + ";" + r + ";path=/" }, Fx = e => document.cookie = e + "=; expires=Thu, 01 Jan 1970 00:00:01 GMT;", Ux = new IntersectionObserver(((e, t) => { e.forEach((e => { e.isIntersecting && (e.target.style.backgroundImage = `url(${e.target.dataset.bg})`, e.target.removeAttribute("data-bg"), t.unobserve(e.target)) })) })), Bx = (e, t, n) => Math.min(Math.max(t, e), n), kx = (e, t) => Math.floor(Math.random() * (t - e + 1) + e), zx = [], Hx = ':where(a, button, input:not([type="hidden"]), select, textarea, iframe, [tabindex], [contentEditable="true"])', Gx = 0, Vx = 1, Wx = 2, jx = { stackable: !1 }; class Xx { constructor(e, t = {}) { this.bindMethods(), this.id = e.id, this.overlay = e, this.options = { ...jx, ...t }, e.getAttribute("role") || e.setAttribute("role", "dialog"), e.getAttribute("aria-modal") || e.setAttribute("aria-modal", !0), wx(document, "click", `[data-open="${this.id}"]`, this.open), wx(document, "click", `[data-close="${this.id}"], #${this.id} [data-close]`, this.close), this.overlay.addEventListener("transitionend", (() => { "closing" == this.overlay.dataset.state && (this.overlay.dataset.state = "closed"), "opening" == this.overlay.dataset.state && (this.overlay.dataset.state = "opened") })), this.options.stackable || addEventListener("opening", (e => { e.target !== this.overlay && this.isOpened && this.close() })) } bindMethods() { this.handleKeyPress = this.handleKeyPress.bind(this), this.handleFocus = this.handleFocus.bind(this), this.trapFocus = this.trapFocus.bind(this), this.toggle = this.toggle.bind(this), this.open = this.open.bind(this), this.close = this.close.bind(this) } get isOpened() { return ["opening", "opened"].includes(this.overlay.dataset.state) } get focusableElements() { return this.overlay.querySelectorAll(Hx) } get firstFocusableElement() { return this.focusableElements[0] } get lastFocusableElement() { const e = this.focusableElements; return e[e.length - 1] } emit(e, t = {}) { this.overlay.dispatchEvent(new CustomEvent(e, { detail: t, bubbles: !0 })) } handleKeyPress(e) { if ("Escape" == e.key) return this.close() } handleFocus(e) { this.overlay.contains(e.target) || (this.overlay.removeAttribute("tabindex"), e.relatedTarget !== this.firstFocusableElement ? e.relatedTarget !== this.lastFocusableElement || this.firstFocusableElement.focus({ preventScroll: !0 }) : this.lastFocusableElement.focus({ preventScroll: !0 })) } trapFocus() { this.returnFocusTo = document.activeElement, this.overlay.addEventListener("keydown", this.handleKeyPress), addEventListener("focusin", this.handleFocus), this.overlay.tabIndex = 0, this.overlay.focus({ preventScroll: !0 }) } releaseFocus() { this.overlay.removeEventListener("keydown", this.handleKeyPress), removeEventListener("focusin", this.handleFocus), this.overlay.removeAttribute("tabindex"), this.returnFocusTo && (this.returnFocusTo.focus(), this.returnFocusTo = null) } toggle() { this.isOpened ? this.close() : this.open() } open(e) { e && e.preventDefault && e.preventDefault(), this.overlay.dataset.state = "", this.emit("opening"), this.trapFocus(), Px(), setTimeout((() => this.overlay.dataset.state = "opening"), 1) } close(e) { e && e.preventDefault && e.preventDefault(), this.emit("closing"), this.releaseFocus(), Ix(), this.overlay.dataset.state = "closing" } } const qx = class { constructor(e) { this.routes = e } load() { this.routes.map((e => { const t = e.resolve; void 0 !== e.resolve ? document.querySelectorAll(t).length && this.runInitialization(e) : this.runInitialization(e) })) } runInitialization(e) { e.file.init.apply(null, e.dependencies) } }, Yx = { method: "GET", responseType: "json", data: {} }; class Kx { constructor(e = {}) { if (this.options = { ...Yx, ...e }, this.options.data = new URLSearchParams(this.options.data), "GET" === this.options.method.toUpperCase() && this.options.data) { const e = this.options.data.toString(); this.options.url += e ? (this.options.url.includes("?") ? "&" : "?") + e : "" } this.xhr = new XMLHttpRequest, this.xhr.open(this.options.method, this.options.url), this.xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest"), this.xhr.responseType = this.options.responseType, this.xhr.onload = () => { 200 == this.xhr.status ? this.options.onSuccess(this.xhr.response) : this.options.onError(this.xhr.status, this.xhr.statusText) }, this.xhr.onerror = this.options.onError, this.xhr.onloadstart = this.options.onLoadStart, this.xhr.onloadend = this.options.onLoadEnd, "GET" === this.options.method.toUpperCase() ? this.xhr.send() : this.xhr.send(this.options.data) } abort() { this.xhr.abort() } } const $x = { multilingual: !1, updateURL: !0, submitOnChange: !0, selectors: { page: ".js-grid", item: ".js-grid-item", loader: ".js-loader", loadMore: ".js-load-more", pagination: ".js-pagination" } }; class Zx { constructor(e, t, n = {}) { this.bindMethods(), this.filters = e, this.id = e.id, this.ajaxRoute = e.hasAttribute("action") ? e.action : "", this.ajaxMethod = e.hasAttribute("method") ? e.method : "GET", this.container = t, this.options = { ...$x, ...n }, delete this.options.selectors, this.selectors = { ...$x.selectors, ...n.selectors }, this.xhr, this.filters.addEventListener("submit", this.submit), this.filters.addEventListener("reset", this.reset), this.options.submitOnChange && (wx(this.filters, "change", "input, select", this.submit), wx(document, "change", `[form="${this.id}"]`, this.submit), wx(document, "click", ".js-clearfilter", this.submit)), this.totalPages = this.setPages(), wx(t, "click", `${this.selectors.loadMore} [type="submit"]`, this.loadMore), wx(t, "click", `${this.selectors.pagination} button`, this.paginate) } bindMethods() { this.submit = this.submit.bind(this), this.loadMore = this.loadMore.bind(this), this.paginate = this.paginate.bind(this), this.reset = this.reset.bind(this), this.load = this.load.bind(this), this.dispatchEvent = this.dispatchEvent.bind(this) } get pages() { return this.selectors.page ? this.container.querySelectorAll(this.selectors.page) : null } get items() { return this.selectors.item ? this.container.querySelectorAll(this.selectors.item) : null } get loadMoreElement() { return this.selectors.loadMore ? this.container.querySelector(this.selectors.loadMore) : null } get loaderElement() { return this.selectors.loader ? this.container.querySelector(this.selectors.loader) : null } get paginationElement() { return this.selectors.pagination ? this.container.querySelector(this.selectors.pagination) : null } setPages() { const e = this.container.dataset.pages ?? 1; return this.container.removeAttribute("data-pages"), parseInt(e) } load(e = Gx, t = 1) { this.dispatchEvent("beforeload", e); const n = new FormData(this.filters); if (this.options.updateURL) { let i = location.protocol + "//" + location.host + location.pathname; e !== Vx && (i = location.protocol + "//" + location.host + location.pathname.replace(/page\/(\d*)\//, "")), e === Wx && t > 1 && (i += `page/${t}/`), Rx(i, n) } this.dispatchEvent("loadstart", e, n), this.loaderElement.classList.add("active"), this.loaderElement.parentElement.setAttribute("aria-busy", !0), this.options.multilingual && n.append("lang", bx()), e !== Gx && t > 1 && n.append("page", t), this.xhr && this.xhr.abort(), this.xhr = new Kx({ url: this.ajaxRoute, method: this.ajaxMethod, data: n, onSuccess: t => { this.dispatchEvent("loadend", e), this.loaderElement.classList.remove("active"), this.loaderElement.parentElement.setAttribute("aria-busy", !1), e == Vx ? (this.paginationElement.remove(), this.loadMoreElement.remove(), this.pages[this.pages.length - 1].insertAdjacentHTML("afterend", t.html)) : (this.container.innerHTML = t.html, this.totalPages = t.pages), window.scroll({ top: this.filters.offsetTop, left: 0, behavior: "smooth" }), this.dispatchEvent("success", e, t) }, onError: (e, t) => { this.dispatchEvent("error", e, t) } }) } reset(e) { document.querySelectorAll(`form[id="${this.id}"] :checked, [form="${this.id}"]:checked`).forEach((e => { e.checked = !1 })), this.submit(e) } submit(e) { e && e.preventDefault && e.preventDefault(), this.filters.checkValidity() && this.load(Gx) } loadMore(e) { e.preventDefault(), this.load(Vx, this.pages.length + 1) } paginate(e) { e.preventDefault(), this.load(Wx, e.target.closest("button").dataset.page) } dispatchEvent(e, ...t) { this.filters.dispatchEvent(new CustomEvent(e, { bubbles: !0, detail: t })) } } var Jx = n(755); const Qx = { init: (e, t, n, i, r) => { document.querySelectorAll("[data-bg]").forEach((t => e.lazyLoader.observe(t))), document.querySelectorAll(".modal").forEach((t => { e.overlays[t.id] = new i(t) })); const s = document.querySelector(".header"); new t(document.querySelector(".menu-wrapper"), document.querySelector(".menu-toggle")), document.querySelectorAll(".submenu").forEach((e => new n(e))), addEventListener("opening", (e => { e.target.classList.contains("submenu") && s.style.setProperty("--submenu-h", `${e.target.getBoundingClientRect().height}px`) })), addEventListener("closing", (e => { e.target.classList.contains("submenu") && s.style.setProperty("--submenu-h", "") })); const a = document.querySelectorAll(".js-faq-dropdown-toggle"), o = e => { e.currentTarget.parentNode.classList.toggle("active") }; a.forEach((e => e.addEventListener("click", o))); document.querySelector(".js-scroll-top").addEventListener("click", (e => { window.scroll({ top: 0, left: 0, behavior: "smooth" }), document.querySelectorAll('[href="#contenu-principal"]')[0].focus() })); let l = document.querySelectorAll(".wEmbed"); for (let e = 0; e < l.length; e++)l[e].addEventListener("click", (function (e) { Jx(`.js-image[data-id="${this.dataset.wembed}"]`).hide(), Jx(`.js-cover[data-id="${this.dataset.wembed}"]`).hide(), Jx(`.js-player[data-id="${this.dataset.wembed}"]`).hide(); let t = document.createElement("iframe"), n = this.dataset.wembed; e.currentTarget.classList.add("active"), t.setAttribute("frameborder", "0"), t.setAttribute("id", n), t.setAttribute("allowfullscreen", ""), t.setAttribute("src", "https://www.youtube.com/embed/" + this.dataset.wembed + "?autoplay=1&rel=0&mute=0"), t.setAttribute("allow", "autoplay"), this.innerHTML = "", this.appendChild(t) })); new r(".js-swiper-products", { slidesPerView: "1", spaceBetween: 32, loop: !0, breakpoints: { 992: { slidesPerView: "3" } }, navigation: { prevEl: ".js-swiper-products-prev", nextEl: ".js-swiper-products-next" } }) } }, eb = { init: (e, t) => { new t(document.getElementById("filters"), document.querySelector(".news-container")) } }, tb = { init: (e, t, n, i) => { const r = document.querySelector(".page-loader"); if (null === sessionStorage.getItem("loaded_once") && sessionStorage.setItem("loaded_once", "loaded_once"), r.hidden) addEventListener("load", (() => e.dispachEvent(document.body, "dom:ready"))); else { const n = t.timeline({ paused: !0 }); n.to(r.querySelector(".page-loader-progress-bar"), { scaleX: 1, duration: .4, ease: "Power0.easeNone" }, "start"), n.call((() => { e.dispachEvent(document.body, "dom:ready") }), null), n.to(r, { autoAlpha: 0, duration: .8, delay: .3, ease: "Power1.easeOut" }), addEventListener("load", (() => n.play())) } document.querySelectorAll("[data-split-text]").forEach((e => { e.split = new n(e, { type: e.dataset.splitText ? e.dataset.splitText : "words, chars", linesClass: "child-split-line", wordsClass: "split-word", charsClass: "split-char" }); new n(e, { type: e.dataset.splitText ? e.dataset.splitText : "words, chars", linesClass: "parent-split-line", wordsClass: "split-word", charsClass: "split-char" }); e.classList.add("split-ready") })); const s = new i({ loadEvent: [document.body, "dom:ready"], scrollTrigger: { markers: !1 }, tweenParams: { start: "-=0.6" } }); s.add("fade-in-up", ((e, t, n, i, r) => { t.fromTo(e, { y: 50 }, { y: 0, autoAlpha: 1, duration: i || 1.3, ease: "cubic-bezier(0.29, 0.48, 0, 0.99)", delay: r || 0 }, n) })), s.add("fade-in-up-bouce", ((e, t, n, i, r) => { t.fromTo(e, { y: 50, autoAlpha: 1 }, { y: 0, autoAlpha: 1, duration: i || 1.3, ease: "bounce.out", delay: r || 0 }, n) })), s.add("fade-in", ((e, t, n, i, r) => { t.fromTo(e, { autoAlpha: 0 }, { autoAlpha: 1, duration: i || 1.3, ease: "cubic-bezier(0.29, 0.48, 0, 0.99)", delay: r || 0 }, n) })), s.add("scale-in-up", ((e, t, n, i, r) => { t.fromTo(e, { scale: 0 }, { scale: 1, autoAlpha: 1, duration: i || 1, ease: "cubic-bezier(0.29, 0.48, 0, 0.99)", delay: r || 0 }, n) })), s.add("fade-in-right", ((e, t, n, i, r) => { t.fromTo(e, { x: 50 }, { x: 0, autoAlpha: 1, duration: i || 1, ease: "cubic-bezier(0.29, 0.48, 0, 0.99)", delay: r || 0 }, n) })), s.add("split-lines", ((e, t, n, i, r) => { t.from(e.split.words ? e.split.words : e.split.chars, { yPercent: 101, delay: r || 0, duration: i || 1.35, ease: "easeSmooth" }, n) })), s.add("split-lines-up", ((e, t, n, i, r) => { const s = e.hasAttribute("data-kira-stagger") ? parseFloat(e.dataset.kiraStagger) : .1; t.from(e.split.lines ? e.split.lines : e.split.chars, { opacity: 0, y: 40, delay: r || 0, duration: i || 1, stagger: s, ease: "power4.out" }, n) })), s.add("split-chars", ((e, t, n, i, r) => { const s = e.hasAttribute("data-kira-stagger") ? parseFloat(e.dataset.kiraStagger) : .03; t.from(e.split.chars, { opacity: 0, yPercent: 30, delay: r || 0, duration: i || .2, stagger: s, ease: "Sine.ease0ut" }, n) })), s.add("counter", ((e, t, n, i, r) => { const s = e.hasAttribute("data-decimal-separator") ? e.dataset.decimalSeparator : ",", a = e.hasAttribute("data-thousands-separator") ? e.dataset.thousandsSeparator : " "; let o = e.textContent.replaceAll(",", ".").replaceAll(" ", ""), l = { val: 0 }, c = o.split(".")[1], u = !!c && c.length; o = u ? parseFloat(o) : parseInt(o); const h = document.createElement("span"); h.classList.add("counter-value"), e.setAttribute("data-counter-goal", e.textContent), e.textContent = "", e.appendChild(h), t.to(l, { val: o, duration: i || 1.3, delay: r || 0, ease: "easeSmooth", onUpdate: () => { let e = 0; if (u) { let [t, n] = l.val.toFixed(u).toString().split(".", 2); t = t.replaceAll(/\B(?=(\d{3})+(?!\d))/g, a), e = [t, n].join(s) } else e = Math.round(l.val).toString().replaceAll(/\B(?=(\d{3})+(?!\d))/g, a); h.textContent = e } }, n) })); const a = window.matchMedia("(prefers-reduced-motion: reduce)"); !a || a.matches ? console.log("no animation") : (console.log("kira"), s.init()) } }; var nb = n(755); const ib = { init: (e, t, n) => { const i = nb("#map"), r = nb(".contact-form"); nb.each(i, (function () { var e = nb(this); new n(e, { markers: e.find(".marker"), zoom: 16 }) })), new t(r, { selectors: { group: ".gfield", label: ".gfield_label", input: ".ginput_container_text input, .ginput_container_email input" }, labelEffect: { duration: .3, ease: Power2.easeOut } }) } }, rb = { init: (e, t, n, i, r, s, a, o, l, c, u, h, d) => { const p = window.matchMedia("(prefers-reduced-motion: reduce)"); if (!p || !p.matches) { window.onbeforeunload = e => { window.scrollTo(0, 0) }; const f = new i; f.rotation.y = -.2; const m = document.getElementById("bottle"); if (m) { const v = new s(75, window.innerWidth / window.innerHeight, .1, 1e3), _ = new r({ canvas: m, antialiasing: !0, alpha: !0 }); _.setSize(window.innerWidth, window.innerHeight), _.setPixelRatio(window.devicePixelRatio); const y = document.querySelector("html").getAttribute("lang").split("-")[0]; let x = null; const b = new h, E = (new a).load(`/wp-content/themes/yagami-adveris/web/src/models/yellow_${y}.webp`); E.colorSpace = c, E.flipY = !1; const T = (new a).load(`/wp-content/themes/yagami-adveris/web/src/models/blue_${y}.webp`); T.flipY = !1, T.colorSpace = c; const S = (new a).load(`/wp-content/themes/yagami-adveris/web/src/models/red_${y}.webp`); S.flipY = !1, S.colorSpace = c, b.load("/wp-content/themes/yagami-adveris/web/src/models/enjoy-bottle.glb", (function (e) { x = e.scene; var t = (new o).setFromObject(x), n = new l; t.getCenter(n), x.position.sub(n), x.traverse((function (e) { e.isMesh && (e.material.map = E, e.material.metalness = .1, e.material.roughness = .5, e.material.ior = 1) })), f.add(x) }), (function (e) { console.log(e.loaded / e.total * 100 + "% loaded") }), (function (e) { console.log("An error happened : ", e) })); const M = new u(16777215, 3.5); function w() { requestAnimationFrame(w), _.render(f, v) } f.add(M), window.innerHeight > 1e3 ? v.position.z = 5 : v.position.z = 3.5, w(); const A = document.getElementById("container-intro-home").offsetWidth, D = 30, C = (window.innerWidth - A) / 2 + document.getElementById("canvas-container").offsetWidth / 2 + D, R = document.getElementById("canvas-container").offsetWidth; t.set("#canvas-container", { x: -C }); let L = t.timeline({ scrollTrigger: { trigger: ".st-header", start: "top top", endTrigger: ".st-intro-end", end: "top 50%", scrub: 1, markers: !1, id: "header-intro" } }), P = t.timeline({ scrollTrigger: { trigger: ".st-intro-end", start: "top top", endTrigger: ".st-oat-end", end: "center 49%", scrub: 1, markers: !1, id: "intro-oat" } }), I = t.timeline({ scrollTrigger: { trigger: ".st-oat-end", start: "center top", endTrigger: ".st-nut-end", end: "center 48%", scrub: 1, markers: !1, id: "oat-nut", onUpdate: e => { console.log("bottle_anim_tl_oat_nut : ", e.progress), e.progress > .3 ? O(S) : O(E) } } }), N = t.timeline({ scrollTrigger: { trigger: ".st-nut-end", start: "center top", endTrigger: ".st-almond-end", end: "bottom bottom", scrub: 1, markers: !1, id: "nut-almond", onUpdate: e => { console.log("bottle_anim_tl_nut_almond : ", e.progress), e.progress > .3 ? O(T) : O(S) } } }); t.timeline({ scrollTrigger: { trigger: ".st-almond-end", start: "center 30%", endTrigger: ".c-section-listproducts", end: "top center", scrub: 1, markers: !1, id: "end" } }); const O = e => { x.traverse((function (t) { t.isMesh && (null == t.material.map ? t.material.map = e : t.material.map !== e && (t.material.map = e, t.material.metalness = .1, t.material.roughness = .5, t.material.ior = 1)) })) }; L.to(f.rotation, { y: 6, duration: 3e3 }).to("#canvas-container", { x: -window.innerWidth / 2 + R / 2, duration: 3e3 }, "<"), P.to(f.rotation, { y: 12.3, duration: 100 }).to("#canvas-container", { x: -window.innerWidth + R + C, duration: 100 }, "<"), I.to(f.rotation, { y: 6, duration: 100 }).to("#canvas-container", { x: -C, duration: 100 }, "<"), N.to(f.rotation, { y: 12.3, duration: 100 }).to("#canvas-container", { x: -window.innerWidth + R + C, duration: 100 }, "<") } const g = t.timeline(); t.set(".a-header-oat", { y: 30, opacity: 0 }), t.set(".a-header-potato-green", { scale: 0 }), t.set(".a-header-potato-pink", { scale: 0 }), t.set(".a-header-potato-yellow", { scale: 0 }), t.set(".a-header-features", { y: 30, opacity: 0 }), t.set(".a-header-milk", { y: 30, opacity: 0 }), t.set(".a-header-canvas", { xPercent: 200, opacity: 1 }), t.set(".a-home-link", { y: 30, opacity: 0 }), window.innerWidth > 992 ? g.to(".a-header-oat", { y: 0, opacity: 1, duration: 1 }).to(".a-header-canvas", { xPercent: 0, opacity: 1, duration: 1 }, "<+.5s").to(".a-header-potato-green", { scale: 1, duration: .5 }, "<+.5s").to(".a-header-potato-pink", { scale: 1, duration: .5 }, "<+.1s").to(".a-header-potato-yellow", { scale: 1, duration: .5 }, "<+.1s").to('.a-header-features[data-index="2"]', { y: -80, opacity: 1, duration: .5 }, "<+.1s").to('.a-header-features[data-index="1"]', { y: 0, opacity: 1, duration: .5 }, "<+.1s").to('.a-header-features[data-index="3"]', { y: 0, opacity: 1, duration: .5 }, "<+.1s").to(".a-home-link", { y: 0, opacity: 1, duration: .5 }, "<").to(".a-header-milk", { y: 0, opacity: 1, duration: .5 }, "<") : g.to(".a-header-oat", { y: 0, opacity: 1, duration: 1 }).to(".a-header-canvas", { xPercent: 0, opacity: 1, duration: 1 }, "<+.5s").to(".a-header-potato-green", { scale: 1, duration: .5 }, "<+.5s").to(".a-header-potato-pink", { scale: 1, duration: .5 }, "<+.1s").to(".a-header-potato-yellow", { scale: 1, duration: .5 }, "<+.1s").to('.a-header-features[data-index="2"]', { y: 0, opacity: 1, duration: .5 }, "<+.1s").to('.a-header-features[data-index="1"]', { y: 0, opacity: 1, duration: .5 }, "<+.1s").to('.a-header-features[data-index="3"]', { y: 0, opacity: 1, duration: .5 }, "<+.1s").to(".a-home-link", { y: 0, opacity: 1, duration: .5 }, "<").to(".a-header-milk", { y: 0, opacity: 1, duration: .5 }, "<"), document.querySelectorAll(".st-parallax").forEach((e => { t.fromTo(e, { y: 0 }, { y: e.dataset.parallax ? e.dataset.parallax : "-20%", ease: "none", scrollTrigger: { trigger: e, start: "top bottom", end: "bottom top", scrub: 1 } }) })) } new n(".js-swiper-enjoyallday", { slidesPerView: "auto", centeredSlides: !0, spaceBetween: 0, speed: 1e3, loop: !0, navigation: { prevEl: ".js-swiper-enjoyallday-prev", nextEl: ".js-swiper-enjoyallday-next" } }) } }, sb = { init: (e, t) => { const n = window.location.search, i = new URLSearchParams(n), r = i.get("recipe_products"), s = document.querySelector('select[name="recipe_products"]'), a = document.querySelector('select[name="recipe_levels"]'), o = document.querySelector(".js-clearfilter"); r && (s.value = r, o.classList.add("active")); const l = i.get("recipe_levels"); l && (a.value = l, o.classList.add("active"), o.setAttribute("tabindex", "")), (l || r) && document.addEventListener("DOMContentLoaded", (() => { setTimeout((() => { const e = document.getElementById("filters-recipes").getBoundingClientRect(); window.scrollTo(e.x, e.y) }), 100) })); const c = () => { s.value || a.value ? (o.classList.add("active"), o.setAttribute("tabindex", "")) : (o.classList.remove("active"), o.setAttribute("tabindex", -1)) }; s.addEventListener("change", c), a.addEventListener("change", c); o.addEventListener("click", (() => { s.value = "", a.value = "", o.classList.remove("active"), s.focus() })); new t(document.getElementById("filters-recipes"), document.querySelector(".js-recipes-container")) } }, ab = { init: e => { const t = document.querySelectorAll(".js-recipe-unit-trigger"), n = document.querySelectorAll(".js-recipe-unit-trigger"), i = document.querySelectorAll(".js-recipe-unit-target"), r = e => { const t = e.currentTarget.dataset.unit, r = e.currentTarget, s = document.querySelector(`.js-recipe-unit-target[data-unit="${t}"]`); i.forEach((e => { e.classList.remove("active") })), n.forEach((e => { e.classList.remove("active") })), r.classList.add("active"), s.classList.add("active") }; t.forEach((e => e.addEventListener("click", r))) } }, ob = { init: (e, t) => { const n = window.location.search, i = new URLSearchParams(n).get("store_province"), r = document.querySelector('select[name="store_province"]'); i && (r.value = i), i && document.addEventListener("DOMContentLoaded", (() => { setTimeout((() => { const e = document.getElementById("filters-stores").getBoundingClientRect(); window.scrollTo(e.x, e.y) }), 100) })); new t(document.getElementById("filters-stores"), document.querySelector(".js-stores-container")) } }; n(755); Gr.registerPlugin(cu, wl), Gr.registerPlugin(Cs), Z.use([function ({ swiper: e, extendParams: t, on: n, emit: i }) { t({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), e.navigation = { nextEl: null, prevEl: null }; const r = e => (Array.isArray(e) || (e = [e].filter((e => !!e))), e); function s(t) { let n; return t && "string" == typeof t && e.isElement && (n = e.el.shadowRoot.querySelector(t), n) ? n : (t && ("string" == typeof t && (n = [...document.querySelectorAll(t)]), e.params.uniqueNavElements && "string" == typeof t && n.length > 1 && 1 === e.el.querySelectorAll(t).length && (n = e.el.querySelector(t))), t && !n ? t : n) } function a(t, n) { const i = e.params.navigation; (t = r(t)).forEach((t => { t && (t.classList[n ? "add" : "remove"](...i.disabledClass.split(" ")), "BUTTON" === t.tagName && (t.disabled = n), e.params.watchOverflow && e.enabled && t.classList[e.isLocked ? "add" : "remove"](i.lockClass)) })) } function o() { const { nextEl: t, prevEl: n } = e.navigation; if (e.params.loop) return a(n, !1), void a(t, !1); a(n, e.isBeginning && !e.params.rewind), a(t, e.isEnd && !e.params.rewind) } function l(t) { t.preventDefault(), (!e.isBeginning || e.params.loop || e.params.rewind) && (e.slidePrev(), i("navigationPrev")) } function c(t) { t.preventDefault(), (!e.isEnd || e.params.loop || e.params.rewind) && (e.slideNext(), i("navigationNext")) } function u() { const t = e.params.navigation; if (e.params.navigation = function (e, t, n, i) { return e.params.createElements && Object.keys(i).forEach((r => { if (!n[r] && !0 === n.auto) { let s = m(e.el, `.${i[r]}`)[0]; s || (s = g("div", i[r]), s.className = i[r], e.el.append(s)), n[r] = s, t[r] = s } })), n }(e, e.originalParams.navigation, e.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !t.nextEl && !t.prevEl) return; let n = s(t.nextEl), i = s(t.prevEl); Object.assign(e.navigation, { nextEl: n, prevEl: i }), n = r(n), i = r(i); const a = (n, i) => { n && n.addEventListener("click", "next" === i ? c : l), !e.enabled && n && n.classList.add(...t.lockClass.split(" ")) }; n.forEach((e => a(e, "next"))), i.forEach((e => a(e, "prev"))) } function h() { let { nextEl: t, prevEl: n } = e.navigation; t = r(t), n = r(n); const i = (t, n) => { t.removeEventListener("click", "next" === n ? c : l), t.classList.remove(...e.params.navigation.disabledClass.split(" ")) }; t.forEach((e => i(e, "next"))), n.forEach((e => i(e, "prev"))) } n("init", (() => { !1 === e.params.navigation.enabled ? d() : (u(), o()) })), n("toEdge fromEdge lock unlock", (() => { o() })), n("destroy", (() => { h() })), n("enable disable", (() => { let { nextEl: t, prevEl: n } = e.navigation; t = r(t), n = r(n), [...t, ...n].filter((e => !!e)).forEach((t => t.classList[e.enabled ? "remove" : "add"](e.params.navigation.lockClass))) })), n("click", ((t, n) => { let { nextEl: s, prevEl: a } = e.navigation; s = r(s), a = r(a); const o = n.target; if (e.params.navigation.hideOnClick && !a.includes(o) && !s.includes(o)) { if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === o || e.pagination.el.contains(o))) return; let t; s.length ? t = s[0].classList.contains(e.params.navigation.hiddenClass) : a.length && (t = a[0].classList.contains(e.params.navigation.hiddenClass)), i(!0 === t ? "navigationShow" : "navigationHide"), [...s, ...a].filter((e => !!e)).forEach((t => t.classList.toggle(e.params.navigation.hiddenClass))) } })); const d = () => { e.el.classList.add(...e.params.navigation.navigationDisabledClass.split(" ")), h() }; Object.assign(e.navigation, { enable: () => { e.el.classList.remove(...e.params.navigation.navigationDisabledClass.split(" ")), u(), o() }, disable: d, update: o, init: u, destroy: h }) }, function ({ swiper: e, extendParams: t, on: n, emit: i, params: r }) { let a, o; e.autoplay = { running: !1, paused: !1, timeLeft: 0 }, t({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }); let l, c, u, h, d, p, f, m = r && r.autoplay ? r.autoplay.delay : 3e3, g = r && r.autoplay ? r.autoplay.delay : 3e3, v = (new Date).getTime; function _(t) { e && !e.destroyed && e.wrapperEl && t.target === e.wrapperEl && (e.wrapperEl.removeEventListener("transitionend", _), S()) } const y = () => { if (e.destroyed || !e.autoplay.running) return; e.autoplay.paused ? c = !0 : c && (g = l, c = !1); const t = e.autoplay.paused ? l : v + g - (new Date).getTime(); e.autoplay.timeLeft = t, i("autoplayTimeLeft", t, t / m), o = requestAnimationFrame((() => { y() })) }, x = t => { if (e.destroyed || !e.autoplay.running) return; cancelAnimationFrame(o), y(); let n = void 0 === t ? e.params.autoplay.delay : t; m = e.params.autoplay.delay, g = e.params.autoplay.delay; const r = (() => { let t; if (t = e.virtual && e.params.virtual.enabled ? e.slides.filter((e => e.classList.contains("swiper-slide-active")))[0] : e.slides[e.activeIndex], !t) return; return parseInt(t.getAttribute("data-swiper-autoplay"), 10) })(); !Number.isNaN(r) && r > 0 && void 0 === t && (n = r, m = r, g = r), l = n; const s = e.params.speed, c = () => { e && !e.destroyed && (e.params.autoplay.reverseDirection ? !e.isBeginning || e.params.loop || e.params.rewind ? (e.slidePrev(s, !0, !0), i("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(e.slides.length - 1, s, !0, !0), i("autoplay")) : !e.isEnd || e.params.loop || e.params.rewind ? (e.slideNext(s, !0, !0), i("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(0, s, !0, !0), i("autoplay")), e.params.cssMode && (v = (new Date).getTime(), requestAnimationFrame((() => { x() })))) }; return n > 0 ? (clearTimeout(a), a = setTimeout((() => { c() }), n)) : requestAnimationFrame((() => { c() })), n }, b = () => { e.autoplay.running = !0, x(), i("autoplayStart") }, E = () => { e.autoplay.running = !1, clearTimeout(a), cancelAnimationFrame(o), i("autoplayStop") }, T = (t, n) => { if (e.destroyed || !e.autoplay.running) return; clearTimeout(a), t || (f = !0); const r = () => { i("autoplayPause"), e.params.autoplay.waitForTransition ? e.wrapperEl.addEventListener("transitionend", _) : S() }; if (e.autoplay.paused = !0, n) return p && (l = e.params.autoplay.delay), p = !1, void r(); const s = l || e.params.autoplay.delay; l = s - ((new Date).getTime() - v), e.isEnd && l < 0 && !e.params.loop || (l < 0 && (l = 0), r()) }, S = () => { e.isEnd && l < 0 && !e.params.loop || e.destroyed || !e.autoplay.running || (v = (new Date).getTime(), f ? (f = !1, x(l)) : x(), e.autoplay.paused = !1, i("autoplayResume")) }, M = () => { if (e.destroyed || !e.autoplay.running) return; const t = s(); "hidden" === t.visibilityState && (f = !0, T(!0)), "visible" === t.visibilityState && S() }, w = e => { "mouse" === e.pointerType && (f = !0, T(!0)) }, A = t => { "mouse" === t.pointerType && e.autoplay.paused && S() }; n("init", (() => { e.params.autoplay.enabled && (e.params.autoplay.pauseOnMouseEnter && (e.el.addEventListener("pointerenter", w), e.el.addEventListener("pointerleave", A)), s().addEventListener("visibilitychange", M), v = (new Date).getTime(), b()) })), n("destroy", (() => { e.el.removeEventListener("pointerenter", w), e.el.removeEventListener("pointerleave", A), s().removeEventListener("visibilitychange", M), e.autoplay.running && E() })), n("beforeTransitionStart", ((t, n, i) => { !e.destroyed && e.autoplay.running && (i || !e.params.autoplay.disableOnInteraction ? T(!0, !0) : E()) })), n("sliderFirstMove", (() => { !e.destroyed && e.autoplay.running && (e.params.autoplay.disableOnInteraction ? E() : (u = !0, h = !1, f = !1, d = setTimeout((() => { f = !0, h = !0, T(!0) }), 200))) })), n("touchEnd", (() => { if (!e.destroyed && e.autoplay.running && u) { if (clearTimeout(d), clearTimeout(a), e.params.autoplay.disableOnInteraction) return h = !1, void (u = !1); h && e.params.cssMode && S(), h = !1, u = !1 } })), n("slideChange", (() => { !e.destroyed && e.autoplay.running && (p = !0) })), Object.assign(e.autoplay, { start: b, stop: E, pause: T, resume: S }) }]); const lb = new qx([{ file: tb, dependencies: [e, Gr, hs, xx] }, { file: Qx, dependencies: [e, class extends Xx { constructor(e, t) { super(e, { stackable: !0 }), this.button = t, this.button.addEventListener("click", this.toggle) } open() { super.open(), document.body.classList.add("has-menu"), this.button.setAttribute("aria-expanded", !0) } close() { super.close(), document.body.classList.remove("has-menu"), dispatchEvent(new CustomEvent("closesubmenus")), this.button.setAttribute("aria-expanded", !1) } }, class extends Xx { constructor(e) { super(e), this.triggers = document.querySelectorAll(`[aria-controls="${e.id}"]`), this.triggers[0].addEventListener("click", this.toggle), this.triggers[1].addEventListener("click", this.close), addEventListener("closesubmenus", this.close), addEventListener("click", (t => { !this.isOpened || e.contains(t.target) || t.target.closest(`[aria-controls="${e.id}"]`) || this.close() })) } open() { document.body.classList.add("has-submenu"), super.open(), this.triggers.forEach((e => { e.setAttribute("aria-expanded", !0) })) } close() { document.body.classList.remove("has-submenu"), super.close(), this.triggers.forEach((e => { e.setAttribute("aria-expanded", !1) })) } }, Xx, Z] }, { file: rb, dependencies: [e, Gr, Z, Dv, Av, Af, K_, gd, pd, hh, uy, class extends W_ { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (e) { return new wy(e) })), this.register((function (e) { return new Oy(e) })), this.register((function (e) { return new Fy(e) })), this.register((function (e) { return new Uy(e) })), this.register((function (e) { return new Dy(e) })), this.register((function (e) { return new Cy(e) })), this.register((function (e) { return new Ry(e) })), this.register((function (e) { return new Ly(e) })), this.register((function (e) { return new My(e) })), this.register((function (e) { return new Py(e) })), this.register((function (e) { return new Ay(e) })), this.register((function (e) { return new Ny(e) })), this.register((function (e) { return new Iy(e) })), this.register((function (e) { return new Ty(e) })), this.register((function (e) { return new By(e) })), this.register((function (e) { return new ky(e) })) } load(e, t, n, i) { const r = this; let s; if ("" !== this.resourcePath) s = this.resourcePath; else if ("" !== this.path) { const t = hy.extractUrlBase(e); s = hy.resolveURL(t, this.path) } else s = hy.extractUrlBase(e); this.manager.itemStart(e); const a = function (t) { i ? i(t) : console.error(t), r.manager.itemError(e), r.manager.itemEnd(e) }, o = new q_(this.manager); o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function (n) { try { r.parse(n, s, (function (n) { t(n), r.manager.itemEnd(e) }), a) } catch (e) { a(e) } }), n, a) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this } unregister(e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, n, i) { let r; const s = {}, a = {}, o = new TextDecoder; if ("string" == typeof e) r = JSON.parse(e); else if (e instanceof ArrayBuffer) { if (o.decode(new Uint8Array(e, 0, 4)) === zy) { try { s[Ey.KHR_BINARY_GLTF] = new Vy(e) } catch (e) { return void (i && i(e)) } r = JSON.parse(s[Ey.KHR_BINARY_GLTF].content) } else r = JSON.parse(o.decode(e)) } else r = e; if (void 0 === r.asset || r.asset.version[0] < 2) return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."))); const l = new fx(r, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); l.fileLoader.setRequestHeader(this.requestHeader); for (let e = 0; e < this.pluginCallbacks.length; e++) { const t = this.pluginCallbacks[e](l); t.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[t.name] = t, s[t.name] = !0 } if (r.extensionsUsed) for (let e = 0; e < r.extensionsUsed.length; ++e) { const t = r.extensionsUsed[e], n = r.extensionsRequired || []; switch (t) { case Ey.KHR_MATERIALS_UNLIT: s[t] = new Sy; break; case Ey.KHR_DRACO_MESH_COMPRESSION: s[t] = new Wy(r, this.dracoLoader); break; case Ey.KHR_TEXTURE_TRANSFORM: s[t] = new jy; break; case Ey.KHR_MESH_QUANTIZATION: s[t] = new Xy; break; default: n.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".') } } l.setExtensions(s), l.setPlugins(a), l.parse(n, i) } parseAsync(e, t) { const n = this; return new Promise((function (i, r) { n.parse(e, t, i, r) })) } }, wl], resolve: ".c-home" }, { file: eb, dependencies: [e, Zx], resolve: ".news-container" }, { file: sb, dependencies: [e, Zx], resolve: ".js-recipes-container" }, { file: ab, dependencies: [e], resolve: ".c-singlerecipe" }, { file: ob, dependencies: [e, Zx], resolve: ".js-stores-container" }, { file: ib, dependencies: [e, yx, vx], resolve: "#page-contact" }, { file: { init: (e, t) => { new t(".js-swiper-list", { slidesPerView: 1, spaceBetween: 32, autoplay: { delay: 1500, disableOnInteraction: !1, pauseOnMouseEnter: !0 }, speed: 1e3, breakpoints: { 992: { slidesPerView: 1.5, slidesPerGroup: 1 } } }) } }, dependencies: [e, Z], resolve: ".c-modular" }]); lb.load() })() })();